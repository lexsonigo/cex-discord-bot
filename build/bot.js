import {createRequire} from "node:module";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = createRequire(import.meta.url);

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
          } catch (e) {
            fail(e);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// node_modules/@discordjs/util/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var lazy = function(cb) {
    let defaultValue;
    return () => defaultValue ??= cb();
  };
  function* range(range2) {
    let rangeEnd;
    let start = 0;
    let step = 1;
    if (typeof range2 === "number") {
      rangeEnd = range2;
    } else {
      start = range2.start;
      rangeEnd = range2.end;
      step = range2.step ?? 1;
    }
    for (let index = start;index < rangeEnd; index += step) {
      yield index;
    }
  }
  var calculateShardId = function(guildId, shardCount) {
    return Number(BigInt(guildId) >> 22n) % shardCount;
  };
  var shouldUseGlobalFetchAndWebSocket = function() {
    if (typeof globalThis.process === "undefined") {
      return "fetch" in globalThis && "WebSocket" in globalThis;
    }
    if ("versions" in globalThis.process) {
      return "deno" in globalThis.process.versions || "bun" in globalThis.process.versions;
    }
    return false;
  };
  var getUserAgentAppendix = function() {
    if (typeof globalThis.EdgeRuntime !== "undefined") {
      return "Vercel-Edge-Functions";
    }
    if (typeof globalThis.R2 !== "undefined" && typeof globalThis.WebSocketPair !== "undefined") {
      return "Cloudflare-Workers";
    }
    if (typeof globalThis.Netlify !== "undefined") {
      return "Netlify-Edge-Functions";
    }
    if (typeof globalThis.process !== "object") {
      if (typeof globalThis.navigator === "object") {
        return globalThis.navigator.userAgent;
      }
      return "UnknownEnvironment";
    }
    if ("versions" in globalThis.process) {
      if ("deno" in globalThis.process.versions) {
        return `Deno/${globalThis.process.versions.deno}`;
      }
      if ("bun" in globalThis.process.versions) {
        return `Bun/${globalThis.process.versions.bun}`;
      }
      if ("node" in globalThis.process.versions) {
        return `Node.js/${globalThis.process.versions.node}`;
      }
    }
    return "UnknownEnvironment";
  };
  var isJSONEncodable = function(maybeEncodable) {
    return maybeEncodable !== null && typeof maybeEncodable === "object" && "toJSON" in maybeEncodable;
  };
  var isEquatable = function(maybeEquatable) {
    return maybeEquatable !== null && typeof maybeEquatable === "object" && "equals" in maybeEquatable;
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    calculateShardId: () => calculateShardId,
    getUserAgentAppendix: () => getUserAgentAppendix,
    isEquatable: () => isEquatable,
    isJSONEncodable: () => isJSONEncodable,
    lazy: () => lazy,
    range: () => range,
    shouldUseGlobalFetchAndWebSocket: () => shouldUseGlobalFetchAndWebSocket
  });
  module.exports = __toCommonJS(src_exports);
  __name(lazy, "lazy");
  __name(range, "range");
  __name(calculateShardId, "calculateShardId");
  __name(shouldUseGlobalFetchAndWebSocket, "shouldUseGlobalFetchAndWebSocket");
  __name(getUserAgentAppendix, "getUserAgentAppendix");
  __name(isJSONEncodable, "isJSONEncodable");
  __name(isEquatable, "isEquatable");
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS((exports, module) => {
  module.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kHeadersList: Symbol("headers list"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kHTTP2BuildRequest: Symbol("http2 build request"),
    kHTTP1BuildRequest: Symbol("http1 build request"),
    kHTTP2CopyHeaders: Symbol("http2 copy headers"),
    kHTTPConnVersion: Symbol("http connection version")
  };
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS((exports, module) => {
  class UndiciError extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
  }

  class ConnectTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ConnectTimeoutError);
      this.name = "ConnectTimeoutError";
      this.message = message || "Connect Timeout Error";
      this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }

  class HeadersTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersTimeoutError);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }

  class HeadersOverflowError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersOverflowError);
      this.name = "HeadersOverflowError";
      this.message = message || "Headers Overflow Error";
      this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }

  class BodyTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, BodyTimeoutError);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }

  class ResponseStatusCodeError extends UndiciError {
    constructor(message, statusCode, headers, body) {
      super(message);
      Error.captureStackTrace(this, ResponseStatusCodeError);
      this.name = "ResponseStatusCodeError";
      this.message = message || "Response Status Code Error";
      this.code = "UND_ERR_RESPONSE_STATUS_CODE";
      this.body = body;
      this.status = statusCode;
      this.statusCode = statusCode;
      this.headers = headers;
    }
  }

  class InvalidArgumentError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidArgumentError);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
  }

  class InvalidReturnValueError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidReturnValueError);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }

  class RequestAbortedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestAbortedError);
      this.name = "AbortError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
  }

  class InformationalError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InformationalError);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
  }

  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestContentLengthMismatchError);
      this.name = "RequestContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseContentLengthMismatchError);
      this.name = "ResponseContentLengthMismatchError";
      this.message = message || "Response body length does not match content-length header";
      this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ClientDestroyedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientDestroyedError);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
  }

  class ClientClosedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientClosedError);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
  }

  class SocketError extends UndiciError {
    constructor(message, socket) {
      super(message);
      Error.captureStackTrace(this, SocketError);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
      this.socket = socket;
    }
  }

  class NotSupportedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }

  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "MissingUpstreamError";
      this.message = message || "No upstream has been added to the BalancedPool";
      this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  }

  class HTTPParserError extends Error {
    constructor(message, code, data) {
      super(message);
      Error.captureStackTrace(this, HTTPParserError);
      this.name = "HTTPParserError";
      this.code = code ? `HPE_${code}` : undefined;
      this.data = data ? data.toString() : undefined;
    }
  }

  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseExceededMaxSizeError);
      this.name = "ResponseExceededMaxSizeError";
      this.message = message || "Response content exceeded max size";
      this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }
  module.exports = {
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    ResponseStatusCodeError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError
  };
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS((exports, module) => {
  var nop = function() {
  };
  var isStream = function(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  };
  var isBlobLike = function(object) {
    return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  };
  var buildURL = function(url, queryParams) {
    if (url.includes("?") || url.includes("#")) {
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    }
    const stringified = stringify(queryParams);
    if (stringified) {
      url += "?" + stringified;
    }
    return url;
  };
  var parseURL = function(url) {
    if (typeof url === "string") {
      url = new URL(url);
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    }
    if (!/^https?:/.test(url.origin || url.protocol)) {
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
        throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      }
      if (url.path != null && typeof url.path !== "string") {
        throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      }
      if (url.pathname != null && typeof url.pathname !== "string") {
        throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      }
      if (url.hostname != null && typeof url.hostname !== "string") {
        throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      }
      if (url.origin != null && typeof url.origin !== "string") {
        throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      }
      const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
      let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
      let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin.endsWith("/")) {
        origin = origin.substring(0, origin.length - 1);
      }
      if (path && !path.startsWith("/")) {
        path = `/${path}`;
      }
      url = new URL(origin + path);
    }
    return url;
  };
  var parseOrigin = function(url) {
    url = parseURL(url);
    if (url.pathname !== "/" || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  };
  var getHostname = function(host) {
    if (host[0] === "[") {
      const idx2 = host.indexOf("]");
      assert(idx2 !== -1);
      return host.substr(1, idx2 - 1);
    }
    const idx = host.indexOf(":");
    if (idx === -1)
      return host;
    return host.substr(0, idx);
  };
  var getServerName = function(host) {
    if (!host) {
      return null;
    }
    assert.strictEqual(typeof host, "string");
    const servername = getHostname(host);
    if (net.isIP(servername)) {
      return "";
    }
    return servername;
  };
  var deepClone = function(obj) {
    return JSON.parse(JSON.stringify(obj));
  };
  var isAsyncIterable = function(obj) {
    return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
  };
  var isIterable = function(obj) {
    return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
  };
  var bodyLength = function(body) {
    if (body == null) {
      return 0;
    } else if (isStream(body)) {
      const state = body._readableState;
      return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
    } else if (isBlobLike(body)) {
      return body.size != null ? body.size : null;
    } else if (isBuffer(body)) {
      return body.byteLength;
    }
    return null;
  };
  var isDestroyed = function(stream2) {
    return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
  };
  var isReadableAborted = function(stream2) {
    const state = stream2 && stream2._readableState;
    return isDestroyed(stream2) && state && !state.endEmitted;
  };
  var destroy = function(stream2, err) {
    if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
      return;
    }
    if (typeof stream2.destroy === "function") {
      if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
        stream2.socket = null;
      }
      stream2.destroy(err);
    } else if (err) {
      process.nextTick((stream3, err2) => {
        stream3.emit("error", err2);
      }, stream2, err);
    }
    if (stream2.destroyed !== true) {
      stream2[kDestroyed] = true;
    }
  };
  var parseKeepAliveTimeout = function(val) {
    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1000 : null;
  };
  var parseHeaders = function(headers, obj = {}) {
    if (!Array.isArray(headers))
      return headers;
    for (let i = 0;i < headers.length; i += 2) {
      const key = headers[i].toString().toLowerCase();
      let val = obj[key];
      if (!val) {
        if (Array.isArray(headers[i + 1])) {
          obj[key] = headers[i + 1];
        } else {
          obj[key] = headers[i + 1].toString("utf8");
        }
      } else {
        if (!Array.isArray(val)) {
          val = [val];
          obj[key] = val;
        }
        val.push(headers[i + 1].toString("utf8"));
      }
    }
    if ("content-length" in obj && "content-disposition" in obj) {
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    }
    return obj;
  };
  var parseRawHeaders = function(headers) {
    const ret = [];
    let hasContentLength = false;
    let contentDispositionIdx = -1;
    for (let n = 0;n < headers.length; n += 2) {
      const key = headers[n + 0].toString();
      const val = headers[n + 1].toString("utf8");
      if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
        ret.push(key, val);
        hasContentLength = true;
      } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
        contentDispositionIdx = ret.push(key, val) - 1;
      } else {
        ret.push(key, val);
      }
    }
    if (hasContentLength && contentDispositionIdx !== -1) {
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    }
    return ret;
  };
  var isBuffer = function(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  };
  var validateHandler = function(handler, method, upgrade) {
    if (!handler || typeof handler !== "object") {
      throw new InvalidArgumentError("handler must be an object");
    }
    if (typeof handler.onConnect !== "function") {
      throw new InvalidArgumentError("invalid onConnect method");
    }
    if (typeof handler.onError !== "function") {
      throw new InvalidArgumentError("invalid onError method");
    }
    if (typeof handler.onBodySent !== "function" && handler.onBodySent !== undefined) {
      throw new InvalidArgumentError("invalid onBodySent method");
    }
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade !== "function") {
        throw new InvalidArgumentError("invalid onUpgrade method");
      }
    } else {
      if (typeof handler.onHeaders !== "function") {
        throw new InvalidArgumentError("invalid onHeaders method");
      }
      if (typeof handler.onData !== "function") {
        throw new InvalidArgumentError("invalid onData method");
      }
      if (typeof handler.onComplete !== "function") {
        throw new InvalidArgumentError("invalid onComplete method");
      }
    }
  };
  var isDisturbed = function(body) {
    return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
  };
  var isErrored = function(body) {
    return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
  };
  var isReadable = function(body) {
    return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
  };
  var getSocketInfo = function(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  };
  async function* convertIterableToBuffer(iterable) {
    for await (const chunk of iterable) {
      yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
    }
  }
  var ReadableStreamFrom = function(iterable) {
    if (!ReadableStream) {
      ReadableStream = __require("stream/web").ReadableStream;
    }
    if (ReadableStream.from) {
      return ReadableStream.from(convertIterableToBuffer(iterable));
    }
    let iterator;
    return new ReadableStream({
      async start() {
        iterator = iterable[Symbol.asyncIterator]();
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (done) {
          queueMicrotask(() => {
            controller.close();
          });
        } else {
          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
          controller.enqueue(new Uint8Array(buf));
        }
        return controller.desiredSize > 0;
      },
      async cancel(reason) {
        await iterator.return();
      }
    }, 0);
  };
  var isFormDataLike = function(object) {
    return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
  };
  var throwIfAborted = function(signal) {
    if (!signal) {
      return;
    }
    if (typeof signal.throwIfAborted === "function") {
      signal.throwIfAborted();
    } else {
      if (signal.aborted) {
        const err = new Error("The operation was aborted");
        err.name = "AbortError";
        throw err;
      }
    }
  };
  var addAbortListener = function(signal, listener) {
    if (typeof Symbol.dispose === "symbol") {
      if (!events) {
        events = __require("events");
      }
      if (typeof events.addAbortListener === "function" && "aborted" in signal) {
        return events.addAbortListener(signal, listener);
      }
    }
    if ("addEventListener" in signal) {
      signal.addEventListener("abort", listener, { once: true });
      return () => signal.removeEventListener("abort", listener);
    }
    signal.addListener("abort", listener);
    return () => signal.removeListener("abort", listener);
  };
  var toUSVString = function(val) {
    if (hasToWellFormed) {
      return `${val}`.toWellFormed();
    } else if (nodeUtil.toUSVString) {
      return nodeUtil.toUSVString(val);
    }
    return `${val}`;
  };
  var assert = __require("assert");
  var { kDestroyed, kBodyUsed } = require_symbols();
  var { IncomingMessage } = __require("http");
  var stream = __require("stream");
  var net = __require("net");
  var { InvalidArgumentError } = require_errors();
  var { Blob: Blob2 } = __require("buffer");
  var nodeUtil = __require("util");
  var { stringify } = __require("querystring");
  var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  var ReadableStream;
  var events;
  var hasToWellFormed = !!String.prototype.toWellFormed;
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = true;
  module.exports = {
    kEnumerableProperty,
    nop,
    isDisturbed,
    isErrored,
    isReadable,
    toUSVString,
    isReadableAborted,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    parseRawHeaders,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer,
    validateHandler,
    getSocketInfo,
    isFormDataLike,
    buildURL,
    throwIfAborted,
    addAbortListener,
    nodeMajor,
    nodeMinor,
    nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13
  };
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS((exports, module) => {
  var onTimeout = function() {
    fastNow = Date.now();
    let len = fastTimers.length;
    let idx = 0;
    while (idx < len) {
      const timer = fastTimers[idx];
      if (timer.state === 0) {
        timer.state = fastNow + timer.delay;
      } else if (timer.state > 0 && fastNow >= timer.state) {
        timer.state = -1;
        timer.callback(timer.opaque);
      }
      if (timer.state === -1) {
        timer.state = -2;
        if (idx !== len - 1) {
          fastTimers[idx] = fastTimers.pop();
        } else {
          fastTimers.pop();
        }
        len -= 1;
      } else {
        idx += 1;
      }
    }
    if (fastTimers.length > 0) {
      refreshTimeout();
    }
  };
  var refreshTimeout = function() {
    if (fastNowTimeout && fastNowTimeout.refresh) {
      fastNowTimeout.refresh();
    } else {
      clearTimeout(fastNowTimeout);
      fastNowTimeout = setTimeout(onTimeout, 1000);
      if (fastNowTimeout.unref) {
        fastNowTimeout.unref();
      }
    }
  };
  var fastNow = Date.now();
  var fastNowTimeout;
  var fastTimers = [];

  class Timeout {
    constructor(callback, delay, opaque) {
      this.callback = callback;
      this.delay = delay;
      this.opaque = opaque;
      this.state = -2;
      this.refresh();
    }
    refresh() {
      if (this.state === -2) {
        fastTimers.push(this);
        if (!fastNowTimeout || fastTimers.length === 1) {
          refreshTimeout();
        }
      }
      this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  }
  module.exports = {
    setTimeout(callback, delay, opaque) {
      return delay < 1000 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
    },
    clearTimeout(timeout) {
      if (timeout instanceof Timeout) {
        timeout.clear();
      } else {
        clearTimeout(timeout);
      }
    }
  };
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS((exports, module) => {
  var SBMH = function(needle) {
    if (typeof needle === "string") {
      needle = Buffer.from(needle);
    }
    if (!Buffer.isBuffer(needle)) {
      throw new TypeError("The needle has to be a String or a Buffer.");
    }
    const needleLength = needle.length;
    if (needleLength === 0) {
      throw new Error("The needle cannot be an empty String/Buffer.");
    }
    if (needleLength > 256) {
      throw new Error("The needle cannot have a length bigger than 256.");
    }
    this.maxMatches = Infinity;
    this.matches = 0;
    this._occ = new Array(256).fill(needleLength);
    this._lookbehind_size = 0;
    this._needle = needle;
    this._bufpos = 0;
    this._lookbehind = Buffer.alloc(needleLength);
    for (var i = 0;i < needleLength - 1; ++i) {
      this._occ[needle[i]] = needleLength - 1 - i;
    }
  };
  var EventEmitter = __require("node:events").EventEmitter;
  var inherits = __require("node:util").inherits;
  inherits(SBMH, EventEmitter);
  SBMH.prototype.reset = function() {
    this._lookbehind_size = 0;
    this.matches = 0;
    this._bufpos = 0;
  };
  SBMH.prototype.push = function(chunk, pos) {
    if (!Buffer.isBuffer(chunk)) {
      chunk = Buffer.from(chunk, "binary");
    }
    const chlen = chunk.length;
    this._bufpos = pos || 0;
    let r;
    while (r !== chlen && this.matches < this.maxMatches) {
      r = this._sbmh_feed(chunk);
    }
    return r;
  };
  SBMH.prototype._sbmh_feed = function(data) {
    const len = data.length;
    const needle = this._needle;
    const needleLength = needle.length;
    const lastNeedleChar = needle[needleLength - 1];
    let pos = -this._lookbehind_size;
    let ch;
    if (pos < 0) {
      while (pos < 0 && pos <= len - needleLength) {
        ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
        if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
          this._lookbehind_size = 0;
          ++this.matches;
          this.emit("info", true);
          return this._bufpos = pos + needleLength;
        }
        pos += this._occ[ch];
      }
      if (pos < 0) {
        while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
          ++pos;
        }
      }
      if (pos >= 0) {
        this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
        this._lookbehind_size = 0;
      } else {
        const bytesToCutOff = this._lookbehind_size + pos;
        if (bytesToCutOff > 0) {
          this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
        }
        this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);
        this._lookbehind_size -= bytesToCutOff;
        data.copy(this._lookbehind, this._lookbehind_size);
        this._lookbehind_size += len;
        this._bufpos = len;
        return len;
      }
    }
    pos += (pos >= 0) * this._bufpos;
    if (data.indexOf(needle, pos) !== -1) {
      pos = data.indexOf(needle, pos);
      ++this.matches;
      if (pos > 0) {
        this.emit("info", true, data, this._bufpos, pos);
      } else {
        this.emit("info", true);
      }
      return this._bufpos = pos + needleLength;
    } else {
      pos = len - needleLength;
    }
    while (pos < len && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos, pos + len - pos), needle.subarray(0, len - pos)) !== 0)) {
      ++pos;
    }
    if (pos < len) {
      data.copy(this._lookbehind, 0, pos, pos + (len - pos));
      this._lookbehind_size = len - pos;
    }
    if (pos > 0) {
      this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
    }
    this._bufpos = len;
    return len;
  };
  SBMH.prototype._sbmh_lookup_char = function(data, pos) {
    return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
  };
  SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
    for (var i = 0;i < len; ++i) {
      if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
        return false;
      }
    }
    return true;
  };
  module.exports = SBMH;
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS((exports, module) => {
  var PartStream = function(opts) {
    ReadableStream.call(this, opts);
  };
  var inherits = __require("node:util").inherits;
  var ReadableStream = __require("node:stream").Readable;
  inherits(PartStream, ReadableStream);
  PartStream.prototype._read = function(n) {
  };
  module.exports = PartStream;
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS((exports, module) => {
  module.exports = function getLimit(limits, name, defaultLimit) {
    if (!limits || limits[name] === undefined || limits[name] === null) {
      return defaultLimit;
    }
    if (typeof limits[name] !== "number" || isNaN(limits[name])) {
      throw new TypeError("Limit " + name + " is not a valid number");
    }
    return limits[name];
  };
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS((exports, module) => {
  var HeaderParser = function(cfg) {
    EventEmitter.call(this);
    cfg = cfg || {};
    const self2 = this;
    this.nread = 0;
    this.maxed = false;
    this.npairs = 0;
    this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2000);
    this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
    this.buffer = "";
    this.header = {};
    this.finished = false;
    this.ss = new StreamSearch(B_DCRLF);
    this.ss.on("info", function(isMatch, data, start, end) {
      if (data && !self2.maxed) {
        if (self2.nread + end - start >= self2.maxHeaderSize) {
          end = self2.maxHeaderSize - self2.nread + start;
          self2.nread = self2.maxHeaderSize;
          self2.maxed = true;
        } else {
          self2.nread += end - start;
        }
        self2.buffer += data.toString("binary", start, end);
      }
      if (isMatch) {
        self2._finish();
      }
    });
  };
  var EventEmitter = __require("node:events").EventEmitter;
  var inherits = __require("node:util").inherits;
  var getLimit = require_getLimit();
  var StreamSearch = require_sbmh();
  var B_DCRLF = Buffer.from("\r\n\r\n");
  var RE_CRLF = /\r\n/g;
  var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
  inherits(HeaderParser, EventEmitter);
  HeaderParser.prototype.push = function(data) {
    const r = this.ss.push(data);
    if (this.finished) {
      return r;
    }
  };
  HeaderParser.prototype.reset = function() {
    this.finished = false;
    this.buffer = "";
    this.header = {};
    this.ss.reset();
  };
  HeaderParser.prototype._finish = function() {
    if (this.buffer) {
      this._parseHeader();
    }
    this.ss.matches = this.ss.maxMatches;
    const header = this.header;
    this.header = {};
    this.buffer = "";
    this.finished = true;
    this.nread = this.npairs = 0;
    this.maxed = false;
    this.emit("header", header);
  };
  HeaderParser.prototype._parseHeader = function() {
    if (this.npairs === this.maxHeaderPairs) {
      return;
    }
    const lines = this.buffer.split(RE_CRLF);
    const len = lines.length;
    let m, h;
    for (var i = 0;i < len; ++i) {
      if (lines[i].length === 0) {
        continue;
      }
      if (lines[i][0] === "\t" || lines[i][0] === " ") {
        if (h) {
          this.header[h][this.header[h].length - 1] += lines[i];
          continue;
        }
      }
      const posColon = lines[i].indexOf(":");
      if (posColon === -1 || posColon === 0) {
        return;
      }
      m = RE_HDR.exec(lines[i]);
      h = m[1].toLowerCase();
      this.header[h] = this.header[h] || [];
      this.header[h].push(m[2] || "");
      if (++this.npairs === this.maxHeaderPairs) {
        break;
      }
    }
  };
  module.exports = HeaderParser;
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS((exports, module) => {
  var Dicer = function(cfg) {
    if (!(this instanceof Dicer)) {
      return new Dicer(cfg);
    }
    WritableStream.call(this, cfg);
    if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
      throw new TypeError("Boundary required");
    }
    if (typeof cfg.boundary === "string") {
      this.setBoundary(cfg.boundary);
    } else {
      this._bparser = undefined;
    }
    this._headerFirst = cfg.headerFirst;
    this._dashes = 0;
    this._parts = 0;
    this._finished = false;
    this._realFinish = false;
    this._isPreamble = true;
    this._justMatched = false;
    this._firstWrite = true;
    this._inHeader = true;
    this._part = undefined;
    this._cb = undefined;
    this._ignoreData = false;
    this._partOpts = { highWaterMark: cfg.partHwm };
    this._pause = false;
    const self2 = this;
    this._hparser = new HeaderParser(cfg);
    this._hparser.on("header", function(header) {
      self2._inHeader = false;
      self2._part.emit("header", header);
    });
  };
  var WritableStream = __require("node:stream").Writable;
  var inherits = __require("node:util").inherits;
  var StreamSearch = require_sbmh();
  var PartStream = require_PartStream();
  var HeaderParser = require_HeaderParser();
  var DASH = 45;
  var B_ONEDASH = Buffer.from("-");
  var B_CRLF = Buffer.from("\r\n");
  var EMPTY_FN = function() {
  };
  inherits(Dicer, WritableStream);
  Dicer.prototype.emit = function(ev) {
    if (ev === "finish" && !this._realFinish) {
      if (!this._finished) {
        const self2 = this;
        process.nextTick(function() {
          self2.emit("error", new Error("Unexpected end of multipart data"));
          if (self2._part && !self2._ignoreData) {
            const type = self2._isPreamble ? "Preamble" : "Part";
            self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
            self2._part.push(null);
            process.nextTick(function() {
              self2._realFinish = true;
              self2.emit("finish");
              self2._realFinish = false;
            });
            return;
          }
          self2._realFinish = true;
          self2.emit("finish");
          self2._realFinish = false;
        });
      }
    } else {
      WritableStream.prototype.emit.apply(this, arguments);
    }
  };
  Dicer.prototype._write = function(data, encoding, cb) {
    if (!this._hparser && !this._bparser) {
      return cb();
    }
    if (this._headerFirst && this._isPreamble) {
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        if (this._events.preamble) {
          this.emit("preamble", this._part);
        } else {
          this._ignore();
        }
      }
      const r = this._hparser.push(data);
      if (!this._inHeader && r !== undefined && r < data.length) {
        data = data.slice(r);
      } else {
        return cb();
      }
    }
    if (this._firstWrite) {
      this._bparser.push(B_CRLF);
      this._firstWrite = false;
    }
    this._bparser.push(data);
    if (this._pause) {
      this._cb = cb;
    } else {
      cb();
    }
  };
  Dicer.prototype.reset = function() {
    this._part = undefined;
    this._bparser = undefined;
    this._hparser = undefined;
  };
  Dicer.prototype.setBoundary = function(boundary) {
    const self2 = this;
    this._bparser = new StreamSearch("\r\n--" + boundary);
    this._bparser.on("info", function(isMatch, data, start, end) {
      self2._oninfo(isMatch, data, start, end);
    });
  };
  Dicer.prototype._ignore = function() {
    if (this._part && !this._ignoreData) {
      this._ignoreData = true;
      this._part.on("error", EMPTY_FN);
      this._part.resume();
    }
  };
  Dicer.prototype._oninfo = function(isMatch, data, start, end) {
    let buf;
    const self2 = this;
    let i = 0;
    let r;
    let shouldWriteMore = true;
    if (!this._part && this._justMatched && data) {
      while (this._dashes < 2 && start + i < end) {
        if (data[start + i] === DASH) {
          ++i;
          ++this._dashes;
        } else {
          if (this._dashes) {
            buf = B_ONEDASH;
          }
          this._dashes = 0;
          break;
        }
      }
      if (this._dashes === 2) {
        if (start + i < end && this._events.trailer) {
          this.emit("trailer", data.slice(start + i, end));
        }
        this.reset();
        this._finished = true;
        if (self2._parts === 0) {
          self2._realFinish = true;
          self2.emit("finish");
          self2._realFinish = false;
        }
      }
      if (this._dashes) {
        return;
      }
    }
    if (this._justMatched) {
      this._justMatched = false;
    }
    if (!this._part) {
      this._part = new PartStream(this._partOpts);
      this._part._read = function(n) {
        self2._unpause();
      };
      if (this._isPreamble && this._events.preamble) {
        this.emit("preamble", this._part);
      } else if (this._isPreamble !== true && this._events.part) {
        this.emit("part", this._part);
      } else {
        this._ignore();
      }
      if (!this._isPreamble) {
        this._inHeader = true;
      }
    }
    if (data && start < end && !this._ignoreData) {
      if (this._isPreamble || !this._inHeader) {
        if (buf) {
          shouldWriteMore = this._part.push(buf);
        }
        shouldWriteMore = this._part.push(data.slice(start, end));
        if (!shouldWriteMore) {
          this._pause = true;
        }
      } else if (!this._isPreamble && this._inHeader) {
        if (buf) {
          this._hparser.push(buf);
        }
        r = this._hparser.push(data.slice(start, end));
        if (!this._inHeader && r !== undefined && r < end) {
          this._oninfo(false, data, start + r, end);
        }
      }
    }
    if (isMatch) {
      this._hparser.reset();
      if (this._isPreamble) {
        this._isPreamble = false;
      } else {
        if (start !== end) {
          ++this._parts;
          this._part.on("end", function() {
            if (--self2._parts === 0) {
              if (self2._finished) {
                self2._realFinish = true;
                self2.emit("finish");
                self2._realFinish = false;
              } else {
                self2._unpause();
              }
            }
          });
        }
      }
      this._part.push(null);
      this._part = undefined;
      this._ignoreData = false;
      this._justMatched = true;
      this._dashes = 0;
    }
  };
  Dicer.prototype._unpause = function() {
    if (!this._pause) {
      return;
    }
    this._pause = false;
    if (this._cb) {
      const cb = this._cb;
      this._cb = undefined;
      cb();
    }
  };
  module.exports = Dicer;
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS((exports, module) => {
  var getDecoder = function(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === undefined) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  };
  var decodeText = function(text, sourceEncoding, destEncoding) {
    if (text) {
      return getDecoder(destEncoding)(text, sourceEncoding);
    }
    return text;
  };
  var utf8Decoder = new TextDecoder("utf-8");
  var textDecoders = new Map([
    ["utf-8", utf8Decoder],
    ["utf8", utf8Decoder]
  ]);
  var decoders = {
    utf8: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        return data;
      }
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.base64Slice(0, data.length);
    },
    other: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      if (textDecoders.has(exports.toString())) {
        try {
          return textDecoders.get(exports).decode(data);
        } catch (e) {
        }
      }
      return typeof data === "string" ? data : data.toString();
    }
  };
  module.exports = decodeText;
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS((exports, module) => {
  var encodedReplacer = function(match) {
    return EncodedLookup[match];
  };
  var parseParams = function(str) {
    const res = [];
    let state = STATE_KEY;
    let charset = "";
    let inquote = false;
    let escaping = false;
    let p = 0;
    let tmp = "";
    const len = str.length;
    for (var i = 0;i < len; ++i) {
      const char = str[i];
      if (char === "\\" && inquote) {
        if (escaping) {
          escaping = false;
        } else {
          escaping = true;
          continue;
        }
      } else if (char === '"') {
        if (!escaping) {
          if (inquote) {
            inquote = false;
            state = STATE_KEY;
          } else {
            inquote = true;
          }
          continue;
        } else {
          escaping = false;
        }
      } else {
        if (escaping && inquote) {
          tmp += "\\";
        }
        escaping = false;
        if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
          if (state === STATE_CHARSET) {
            state = STATE_LANG;
            charset = tmp.substring(1);
          } else {
            state = STATE_VALUE;
          }
          tmp = "";
          continue;
        } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
          state = char === "*" ? STATE_CHARSET : STATE_VALUE;
          res[p] = [tmp, undefined];
          tmp = "";
          continue;
        } else if (!inquote && char === ";") {
          state = STATE_KEY;
          if (charset) {
            if (tmp.length) {
              tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
            }
            charset = "";
          } else if (tmp.length) {
            tmp = decodeText(tmp, "binary", "utf8");
          }
          if (res[p] === undefined) {
            res[p] = tmp;
          } else {
            res[p][1] = tmp;
          }
          tmp = "";
          ++p;
          continue;
        } else if (!inquote && (char === " " || char === "\t")) {
          continue;
        }
      }
      tmp += char;
    }
    if (charset && tmp.length) {
      tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
    } else if (tmp) {
      tmp = decodeText(tmp, "binary", "utf8");
    }
    if (res[p] === undefined) {
      if (tmp) {
        res[p] = tmp;
      }
    } else {
      res[p][1] = tmp;
    }
    return res;
  };
  var decodeText = require_decodeText();
  var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
  var EncodedLookup = {
    "%00": "\0",
    "%01": "\x01",
    "%02": "\x02",
    "%03": "\x03",
    "%04": "\x04",
    "%05": "\x05",
    "%06": "\x06",
    "%07": "\x07",
    "%08": "\b",
    "%09": "\t",
    "%0a": `
`,
    "%0A": `
`,
    "%0b": "\v",
    "%0B": "\v",
    "%0c": "\f",
    "%0C": "\f",
    "%0d": `\r`,
    "%0D": `\r`,
    "%0e": "\x0E",
    "%0E": "\x0E",
    "%0f": "\x0F",
    "%0F": "\x0F",
    "%10": "\x10",
    "%11": "\x11",
    "%12": "\x12",
    "%13": "\x13",
    "%14": "\x14",
    "%15": "\x15",
    "%16": "\x16",
    "%17": "\x17",
    "%18": "\x18",
    "%19": "\x19",
    "%1a": "\x1A",
    "%1A": "\x1A",
    "%1b": "\x1B",
    "%1B": "\x1B",
    "%1c": "\x1C",
    "%1C": "\x1C",
    "%1d": "\x1D",
    "%1D": "\x1D",
    "%1e": "\x1E",
    "%1E": "\x1E",
    "%1f": "\x1F",
    "%1F": "\x1F",
    "%20": " ",
    "%21": "!",
    "%22": '"',
    "%23": "#",
    "%24": "$",
    "%25": "%",
    "%26": "&",
    "%27": "'",
    "%28": "(",
    "%29": ")",
    "%2a": "*",
    "%2A": "*",
    "%2b": "+",
    "%2B": "+",
    "%2c": ",",
    "%2C": ",",
    "%2d": "-",
    "%2D": "-",
    "%2e": ".",
    "%2E": ".",
    "%2f": "/",
    "%2F": "/",
    "%30": "0",
    "%31": "1",
    "%32": "2",
    "%33": "3",
    "%34": "4",
    "%35": "5",
    "%36": "6",
    "%37": "7",
    "%38": "8",
    "%39": "9",
    "%3a": ":",
    "%3A": ":",
    "%3b": ";",
    "%3B": ";",
    "%3c": "<",
    "%3C": "<",
    "%3d": "=",
    "%3D": "=",
    "%3e": ">",
    "%3E": ">",
    "%3f": "?",
    "%3F": "?",
    "%40": "@",
    "%41": "A",
    "%42": "B",
    "%43": "C",
    "%44": "D",
    "%45": "E",
    "%46": "F",
    "%47": "G",
    "%48": "H",
    "%49": "I",
    "%4a": "J",
    "%4A": "J",
    "%4b": "K",
    "%4B": "K",
    "%4c": "L",
    "%4C": "L",
    "%4d": "M",
    "%4D": "M",
    "%4e": "N",
    "%4E": "N",
    "%4f": "O",
    "%4F": "O",
    "%50": "P",
    "%51": "Q",
    "%52": "R",
    "%53": "S",
    "%54": "T",
    "%55": "U",
    "%56": "V",
    "%57": "W",
    "%58": "X",
    "%59": "Y",
    "%5a": "Z",
    "%5A": "Z",
    "%5b": "[",
    "%5B": "[",
    "%5c": "\\",
    "%5C": "\\",
    "%5d": "]",
    "%5D": "]",
    "%5e": "^",
    "%5E": "^",
    "%5f": "_",
    "%5F": "_",
    "%60": "`",
    "%61": "a",
    "%62": "b",
    "%63": "c",
    "%64": "d",
    "%65": "e",
    "%66": "f",
    "%67": "g",
    "%68": "h",
    "%69": "i",
    "%6a": "j",
    "%6A": "j",
    "%6b": "k",
    "%6B": "k",
    "%6c": "l",
    "%6C": "l",
    "%6d": "m",
    "%6D": "m",
    "%6e": "n",
    "%6E": "n",
    "%6f": "o",
    "%6F": "o",
    "%70": "p",
    "%71": "q",
    "%72": "r",
    "%73": "s",
    "%74": "t",
    "%75": "u",
    "%76": "v",
    "%77": "w",
    "%78": "x",
    "%79": "y",
    "%7a": "z",
    "%7A": "z",
    "%7b": "{",
    "%7B": "{",
    "%7c": "|",
    "%7C": "|",
    "%7d": "}",
    "%7D": "}",
    "%7e": "~",
    "%7E": "~",
    "%7f": "\x7F",
    "%7F": "\x7F",
    "%80": "\x80",
    "%81": "\x81",
    "%82": "\x82",
    "%83": "\x83",
    "%84": "\x84",
    "%85": "\x85",
    "%86": "\x86",
    "%87": "\x87",
    "%88": "\x88",
    "%89": "\x89",
    "%8a": "\x8A",
    "%8A": "\x8A",
    "%8b": "\x8B",
    "%8B": "\x8B",
    "%8c": "\x8C",
    "%8C": "\x8C",
    "%8d": "\x8D",
    "%8D": "\x8D",
    "%8e": "\x8E",
    "%8E": "\x8E",
    "%8f": "\x8F",
    "%8F": "\x8F",
    "%90": "\x90",
    "%91": "\x91",
    "%92": "\x92",
    "%93": "\x93",
    "%94": "\x94",
    "%95": "\x95",
    "%96": "\x96",
    "%97": "\x97",
    "%98": "\x98",
    "%99": "\x99",
    "%9a": "\x9A",
    "%9A": "\x9A",
    "%9b": "\x9B",
    "%9B": "\x9B",
    "%9c": "\x9C",
    "%9C": "\x9C",
    "%9d": "\x9D",
    "%9D": "\x9D",
    "%9e": "\x9E",
    "%9E": "\x9E",
    "%9f": "\x9F",
    "%9F": "\x9F",
    "%a0": "\xA0",
    "%A0": "\xA0",
    "%a1": "\xA1",
    "%A1": "\xA1",
    "%a2": "\xA2",
    "%A2": "\xA2",
    "%a3": "\xA3",
    "%A3": "\xA3",
    "%a4": "\xA4",
    "%A4": "\xA4",
    "%a5": "\xA5",
    "%A5": "\xA5",
    "%a6": "\xA6",
    "%A6": "\xA6",
    "%a7": "\xA7",
    "%A7": "\xA7",
    "%a8": "\xA8",
    "%A8": "\xA8",
    "%a9": "\xA9",
    "%A9": "\xA9",
    "%aa": "\xAA",
    "%Aa": "\xAA",
    "%aA": "\xAA",
    "%AA": "\xAA",
    "%ab": "\xAB",
    "%Ab": "\xAB",
    "%aB": "\xAB",
    "%AB": "\xAB",
    "%ac": "\xAC",
    "%Ac": "\xAC",
    "%aC": "\xAC",
    "%AC": "\xAC",
    "%ad": "\xAD",
    "%Ad": "\xAD",
    "%aD": "\xAD",
    "%AD": "\xAD",
    "%ae": "\xAE",
    "%Ae": "\xAE",
    "%aE": "\xAE",
    "%AE": "\xAE",
    "%af": "\xAF",
    "%Af": "\xAF",
    "%aF": "\xAF",
    "%AF": "\xAF",
    "%b0": "\xB0",
    "%B0": "\xB0",
    "%b1": "\xB1",
    "%B1": "\xB1",
    "%b2": "\xB2",
    "%B2": "\xB2",
    "%b3": "\xB3",
    "%B3": "\xB3",
    "%b4": "\xB4",
    "%B4": "\xB4",
    "%b5": "\xB5",
    "%B5": "\xB5",
    "%b6": "\xB6",
    "%B6": "\xB6",
    "%b7": "\xB7",
    "%B7": "\xB7",
    "%b8": "\xB8",
    "%B8": "\xB8",
    "%b9": "\xB9",
    "%B9": "\xB9",
    "%ba": "\xBA",
    "%Ba": "\xBA",
    "%bA": "\xBA",
    "%BA": "\xBA",
    "%bb": "\xBB",
    "%Bb": "\xBB",
    "%bB": "\xBB",
    "%BB": "\xBB",
    "%bc": "\xBC",
    "%Bc": "\xBC",
    "%bC": "\xBC",
    "%BC": "\xBC",
    "%bd": "\xBD",
    "%Bd": "\xBD",
    "%bD": "\xBD",
    "%BD": "\xBD",
    "%be": "\xBE",
    "%Be": "\xBE",
    "%bE": "\xBE",
    "%BE": "\xBE",
    "%bf": "\xBF",
    "%Bf": "\xBF",
    "%bF": "\xBF",
    "%BF": "\xBF",
    "%c0": "\xC0",
    "%C0": "\xC0",
    "%c1": "\xC1",
    "%C1": "\xC1",
    "%c2": "\xC2",
    "%C2": "\xC2",
    "%c3": "\xC3",
    "%C3": "\xC3",
    "%c4": "\xC4",
    "%C4": "\xC4",
    "%c5": "\xC5",
    "%C5": "\xC5",
    "%c6": "\xC6",
    "%C6": "\xC6",
    "%c7": "\xC7",
    "%C7": "\xC7",
    "%c8": "\xC8",
    "%C8": "\xC8",
    "%c9": "\xC9",
    "%C9": "\xC9",
    "%ca": "\xCA",
    "%Ca": "\xCA",
    "%cA": "\xCA",
    "%CA": "\xCA",
    "%cb": "\xCB",
    "%Cb": "\xCB",
    "%cB": "\xCB",
    "%CB": "\xCB",
    "%cc": "\xCC",
    "%Cc": "\xCC",
    "%cC": "\xCC",
    "%CC": "\xCC",
    "%cd": "\xCD",
    "%Cd": "\xCD",
    "%cD": "\xCD",
    "%CD": "\xCD",
    "%ce": "\xCE",
    "%Ce": "\xCE",
    "%cE": "\xCE",
    "%CE": "\xCE",
    "%cf": "\xCF",
    "%Cf": "\xCF",
    "%cF": "\xCF",
    "%CF": "\xCF",
    "%d0": "\xD0",
    "%D0": "\xD0",
    "%d1": "\xD1",
    "%D1": "\xD1",
    "%d2": "\xD2",
    "%D2": "\xD2",
    "%d3": "\xD3",
    "%D3": "\xD3",
    "%d4": "\xD4",
    "%D4": "\xD4",
    "%d5": "\xD5",
    "%D5": "\xD5",
    "%d6": "\xD6",
    "%D6": "\xD6",
    "%d7": "\xD7",
    "%D7": "\xD7",
    "%d8": "\xD8",
    "%D8": "\xD8",
    "%d9": "\xD9",
    "%D9": "\xD9",
    "%da": "\xDA",
    "%Da": "\xDA",
    "%dA": "\xDA",
    "%DA": "\xDA",
    "%db": "\xDB",
    "%Db": "\xDB",
    "%dB": "\xDB",
    "%DB": "\xDB",
    "%dc": "\xDC",
    "%Dc": "\xDC",
    "%dC": "\xDC",
    "%DC": "\xDC",
    "%dd": "\xDD",
    "%Dd": "\xDD",
    "%dD": "\xDD",
    "%DD": "\xDD",
    "%de": "\xDE",
    "%De": "\xDE",
    "%dE": "\xDE",
    "%DE": "\xDE",
    "%df": "\xDF",
    "%Df": "\xDF",
    "%dF": "\xDF",
    "%DF": "\xDF",
    "%e0": "\xE0",
    "%E0": "\xE0",
    "%e1": "\xE1",
    "%E1": "\xE1",
    "%e2": "\xE2",
    "%E2": "\xE2",
    "%e3": "\xE3",
    "%E3": "\xE3",
    "%e4": "\xE4",
    "%E4": "\xE4",
    "%e5": "\xE5",
    "%E5": "\xE5",
    "%e6": "\xE6",
    "%E6": "\xE6",
    "%e7": "\xE7",
    "%E7": "\xE7",
    "%e8": "\xE8",
    "%E8": "\xE8",
    "%e9": "\xE9",
    "%E9": "\xE9",
    "%ea": "\xEA",
    "%Ea": "\xEA",
    "%eA": "\xEA",
    "%EA": "\xEA",
    "%eb": "\xEB",
    "%Eb": "\xEB",
    "%eB": "\xEB",
    "%EB": "\xEB",
    "%ec": "\xEC",
    "%Ec": "\xEC",
    "%eC": "\xEC",
    "%EC": "\xEC",
    "%ed": "\xED",
    "%Ed": "\xED",
    "%eD": "\xED",
    "%ED": "\xED",
    "%ee": "\xEE",
    "%Ee": "\xEE",
    "%eE": "\xEE",
    "%EE": "\xEE",
    "%ef": "\xEF",
    "%Ef": "\xEF",
    "%eF": "\xEF",
    "%EF": "\xEF",
    "%f0": "\xF0",
    "%F0": "\xF0",
    "%f1": "\xF1",
    "%F1": "\xF1",
    "%f2": "\xF2",
    "%F2": "\xF2",
    "%f3": "\xF3",
    "%F3": "\xF3",
    "%f4": "\xF4",
    "%F4": "\xF4",
    "%f5": "\xF5",
    "%F5": "\xF5",
    "%f6": "\xF6",
    "%F6": "\xF6",
    "%f7": "\xF7",
    "%F7": "\xF7",
    "%f8": "\xF8",
    "%F8": "\xF8",
    "%f9": "\xF9",
    "%F9": "\xF9",
    "%fa": "\xFA",
    "%Fa": "\xFA",
    "%fA": "\xFA",
    "%FA": "\xFA",
    "%fb": "\xFB",
    "%Fb": "\xFB",
    "%fB": "\xFB",
    "%FB": "\xFB",
    "%fc": "\xFC",
    "%Fc": "\xFC",
    "%fC": "\xFC",
    "%FC": "\xFC",
    "%fd": "\xFD",
    "%Fd": "\xFD",
    "%fD": "\xFD",
    "%FD": "\xFD",
    "%fe": "\xFE",
    "%Fe": "\xFE",
    "%fE": "\xFE",
    "%FE": "\xFE",
    "%ff": "\xFF",
    "%Ff": "\xFF",
    "%fF": "\xFF",
    "%FF": "\xFF"
  };
  var STATE_KEY = 0;
  var STATE_VALUE = 1;
  var STATE_CHARSET = 2;
  var STATE_LANG = 3;
  module.exports = parseParams;
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS((exports, module) => {
  module.exports = function basename(path) {
    if (typeof path !== "string") {
      return "";
    }
    for (var i = path.length - 1;i >= 0; --i) {
      switch (path.charCodeAt(i)) {
        case 47:
        case 92:
          path = path.slice(i + 1);
          return path === ".." || path === "." ? "" : path;
      }
    }
    return path === ".." || path === "." ? "" : path;
  };
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS((exports, module) => {
  var Multipart = function(boy, cfg) {
    let i;
    let len;
    const self2 = this;
    let boundary;
    const limits = cfg.limits;
    const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== undefined);
    const parsedConType = cfg.parsedConType || [];
    const defCharset = cfg.defCharset || "utf8";
    const preservePath = cfg.preservePath;
    const fileOpts = { highWaterMark: cfg.fileHwm };
    for (i = 0, len = parsedConType.length;i < len; ++i) {
      if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
        boundary = parsedConType[i][1];
        break;
      }
    }
    function checkFinished() {
      if (nends === 0 && finished && !boy._done) {
        finished = false;
        self2.end();
      }
    }
    if (typeof boundary !== "string") {
      throw new Error("Multipart: Boundary not found");
    }
    const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
    const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
    const filesLimit = getLimit(limits, "files", Infinity);
    const fieldsLimit = getLimit(limits, "fields", Infinity);
    const partsLimit = getLimit(limits, "parts", Infinity);
    const headerPairsLimit = getLimit(limits, "headerPairs", 2000);
    const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
    let nfiles = 0;
    let nfields = 0;
    let nends = 0;
    let curFile;
    let curField;
    let finished = false;
    this._needDrain = false;
    this._pause = false;
    this._cb = undefined;
    this._nparts = 0;
    this._boy = boy;
    const parserCfg = {
      boundary,
      maxHeaderPairs: headerPairsLimit,
      maxHeaderSize: headerSizeLimit,
      partHwm: fileOpts.highWaterMark,
      highWaterMark: cfg.highWaterMark
    };
    this.parser = new Dicer(parserCfg);
    this.parser.on("drain", function() {
      self2._needDrain = false;
      if (self2._cb && !self2._pause) {
        const cb = self2._cb;
        self2._cb = undefined;
        cb();
      }
    }).on("part", function onPart(part) {
      if (++self2._nparts > partsLimit) {
        self2.parser.removeListener("part", onPart);
        self2.parser.on("part", skipPart);
        boy.hitPartsLimit = true;
        boy.emit("partsLimit");
        return skipPart(part);
      }
      if (curField) {
        const field = curField;
        field.emit("end");
        field.removeAllListeners("end");
      }
      part.on("header", function(header) {
        let contype;
        let fieldname;
        let parsed;
        let charset;
        let encoding;
        let filename;
        let nsize = 0;
        if (header["content-type"]) {
          parsed = parseParams(header["content-type"][0]);
          if (parsed[0]) {
            contype = parsed[0].toLowerCase();
            for (i = 0, len = parsed.length;i < len; ++i) {
              if (RE_CHARSET.test(parsed[i][0])) {
                charset = parsed[i][1].toLowerCase();
                break;
              }
            }
          }
        }
        if (contype === undefined) {
          contype = "text/plain";
        }
        if (charset === undefined) {
          charset = defCharset;
        }
        if (header["content-disposition"]) {
          parsed = parseParams(header["content-disposition"][0]);
          if (!RE_FIELD.test(parsed[0])) {
            return skipPart(part);
          }
          for (i = 0, len = parsed.length;i < len; ++i) {
            if (RE_NAME.test(parsed[i][0])) {
              fieldname = parsed[i][1];
            } else if (RE_FILENAME.test(parsed[i][0])) {
              filename = parsed[i][1];
              if (!preservePath) {
                filename = basename(filename);
              }
            }
          }
        } else {
          return skipPart(part);
        }
        if (header["content-transfer-encoding"]) {
          encoding = header["content-transfer-encoding"][0].toLowerCase();
        } else {
          encoding = "7bit";
        }
        let onData, onEnd;
        if (isPartAFile(fieldname, contype, filename)) {
          if (nfiles === filesLimit) {
            if (!boy.hitFilesLimit) {
              boy.hitFilesLimit = true;
              boy.emit("filesLimit");
            }
            return skipPart(part);
          }
          ++nfiles;
          if (!boy._events.file) {
            self2.parser._ignore();
            return;
          }
          ++nends;
          const file = new FileStream(fileOpts);
          curFile = file;
          file.on("end", function() {
            --nends;
            self2._pause = false;
            checkFinished();
            if (self2._cb && !self2._needDrain) {
              const cb = self2._cb;
              self2._cb = undefined;
              cb();
            }
          });
          file._read = function(n) {
            if (!self2._pause) {
              return;
            }
            self2._pause = false;
            if (self2._cb && !self2._needDrain) {
              const cb = self2._cb;
              self2._cb = undefined;
              cb();
            }
          };
          boy.emit("file", fieldname, file, filename, encoding, contype);
          onData = function(data) {
            if ((nsize += data.length) > fileSizeLimit) {
              const extralen = fileSizeLimit - nsize + data.length;
              if (extralen > 0) {
                file.push(data.slice(0, extralen));
              }
              file.truncated = true;
              file.bytesRead = fileSizeLimit;
              part.removeAllListeners("data");
              file.emit("limit");
              return;
            } else if (!file.push(data)) {
              self2._pause = true;
            }
            file.bytesRead = nsize;
          };
          onEnd = function() {
            curFile = undefined;
            file.push(null);
          };
        } else {
          if (nfields === fieldsLimit) {
            if (!boy.hitFieldsLimit) {
              boy.hitFieldsLimit = true;
              boy.emit("fieldsLimit");
            }
            return skipPart(part);
          }
          ++nfields;
          ++nends;
          let buffer = "";
          let truncated = false;
          curField = part;
          onData = function(data) {
            if ((nsize += data.length) > fieldSizeLimit) {
              const extralen = fieldSizeLimit - (nsize - data.length);
              buffer += data.toString("binary", 0, extralen);
              truncated = true;
              part.removeAllListeners("data");
            } else {
              buffer += data.toString("binary");
            }
          };
          onEnd = function() {
            curField = undefined;
            if (buffer.length) {
              buffer = decodeText(buffer, "binary", charset);
            }
            boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
            --nends;
            checkFinished();
          };
        }
        part._readableState.sync = false;
        part.on("data", onData);
        part.on("end", onEnd);
      }).on("error", function(err) {
        if (curFile) {
          curFile.emit("error", err);
        }
      });
    }).on("error", function(err) {
      boy.emit("error", err);
    }).on("finish", function() {
      finished = true;
      checkFinished();
    });
  };
  var skipPart = function(part) {
    part.resume();
  };
  var FileStream = function(opts) {
    Readable.call(this, opts);
    this.bytesRead = 0;
    this.truncated = false;
  };
  var { Readable } = __require("node:stream");
  var { inherits } = __require("node:util");
  var Dicer = require_Dicer();
  var parseParams = require_parseParams();
  var decodeText = require_decodeText();
  var basename = require_basename();
  var getLimit = require_getLimit();
  var RE_BOUNDARY = /^boundary$/i;
  var RE_FIELD = /^form-data$/i;
  var RE_CHARSET = /^charset$/i;
  var RE_FILENAME = /^filename$/i;
  var RE_NAME = /^name$/i;
  Multipart.detect = /^multipart\/form-data/i;
  Multipart.prototype.write = function(chunk, cb) {
    const r = this.parser.write(chunk);
    if (r && !this._pause) {
      cb();
    } else {
      this._needDrain = !r;
      this._cb = cb;
    }
  };
  Multipart.prototype.end = function() {
    const self2 = this;
    if (self2.parser.writable) {
      self2.parser.end();
    } else if (!self2._boy._done) {
      process.nextTick(function() {
        self2._boy._done = true;
        self2._boy.emit("finish");
      });
    }
  };
  inherits(FileStream, Readable);
  FileStream.prototype._read = function(n) {
  };
  module.exports = Multipart;
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS((exports, module) => {
  var Decoder = function() {
    this.buffer = undefined;
  };
  var RE_PLUS = /\+/g;
  var HEX = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  Decoder.prototype.write = function(str) {
    str = str.replace(RE_PLUS, " ");
    let res = "";
    let i = 0;
    let p = 0;
    const len = str.length;
    for (;i < len; ++i) {
      if (this.buffer !== undefined) {
        if (!HEX[str.charCodeAt(i)]) {
          res += "%" + this.buffer;
          this.buffer = undefined;
          --i;
        } else {
          this.buffer += str[i];
          ++p;
          if (this.buffer.length === 2) {
            res += String.fromCharCode(parseInt(this.buffer, 16));
            this.buffer = undefined;
          }
        }
      } else if (str[i] === "%") {
        if (i > p) {
          res += str.substring(p, i);
          p = i;
        }
        this.buffer = "";
        ++p;
      }
    }
    if (p < len && this.buffer === undefined) {
      res += str.substring(p);
    }
    return res;
  };
  Decoder.prototype.reset = function() {
    this.buffer = undefined;
  };
  module.exports = Decoder;
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var UrlEncoded = function(boy, cfg) {
    const limits = cfg.limits;
    const parsedConType = cfg.parsedConType;
    this.boy = boy;
    this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
    this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
    this.fieldsLimit = getLimit(limits, "fields", Infinity);
    let charset;
    for (var i = 0, len = parsedConType.length;i < len; ++i) {
      if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
        charset = parsedConType[i][1].toLowerCase();
        break;
      }
    }
    if (charset === undefined) {
      charset = cfg.defCharset || "utf8";
    }
    this.decoder = new Decoder;
    this.charset = charset;
    this._fields = 0;
    this._state = "key";
    this._checkingBytes = true;
    this._bytesKey = 0;
    this._bytesVal = 0;
    this._key = "";
    this._val = "";
    this._keyTrunc = false;
    this._valTrunc = false;
    this._hitLimit = false;
  };
  var Decoder = require_Decoder();
  var decodeText = require_decodeText();
  var getLimit = require_getLimit();
  var RE_CHARSET = /^charset$/i;
  UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
  UrlEncoded.prototype.write = function(data, cb) {
    if (this._fields === this.fieldsLimit) {
      if (!this.boy.hitFieldsLimit) {
        this.boy.hitFieldsLimit = true;
        this.boy.emit("fieldsLimit");
      }
      return cb();
    }
    let idxeq;
    let idxamp;
    let i;
    let p = 0;
    const len = data.length;
    while (p < len) {
      if (this._state === "key") {
        idxeq = idxamp = undefined;
        for (i = p;i < len; ++i) {
          if (!this._checkingBytes) {
            ++p;
          }
          if (data[i] === 61) {
            idxeq = i;
            break;
          } else if (data[i] === 38) {
            idxamp = i;
            break;
          }
          if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
            this._hitLimit = true;
            break;
          } else if (this._checkingBytes) {
            ++this._bytesKey;
          }
        }
        if (idxeq !== undefined) {
          if (idxeq > p) {
            this._key += this.decoder.write(data.toString("binary", p, idxeq));
          }
          this._state = "val";
          this._hitLimit = false;
          this._checkingBytes = true;
          this._val = "";
          this._bytesVal = 0;
          this._valTrunc = false;
          this.decoder.reset();
          p = idxeq + 1;
        } else if (idxamp !== undefined) {
          ++this._fields;
          let key;
          const keyTrunc = this._keyTrunc;
          if (idxamp > p) {
            key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
          } else {
            key = this._key;
          }
          this._hitLimit = false;
          this._checkingBytes = true;
          this._key = "";
          this._bytesKey = 0;
          this._keyTrunc = false;
          this.decoder.reset();
          if (key.length) {
            this.boy.emit("field", decodeText(key, "binary", this.charset), "", keyTrunc, false);
          }
          p = idxamp + 1;
          if (this._fields === this.fieldsLimit) {
            return cb();
          }
        } else if (this._hitLimit) {
          if (i > p) {
            this._key += this.decoder.write(data.toString("binary", p, i));
          }
          p = i;
          if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
            this._checkingBytes = false;
            this._keyTrunc = true;
          }
        } else {
          if (p < len) {
            this._key += this.decoder.write(data.toString("binary", p));
          }
          p = len;
        }
      } else {
        idxamp = undefined;
        for (i = p;i < len; ++i) {
          if (!this._checkingBytes) {
            ++p;
          }
          if (data[i] === 38) {
            idxamp = i;
            break;
          }
          if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
            this._hitLimit = true;
            break;
          } else if (this._checkingBytes) {
            ++this._bytesVal;
          }
        }
        if (idxamp !== undefined) {
          ++this._fields;
          if (idxamp > p) {
            this._val += this.decoder.write(data.toString("binary", p, idxamp));
          }
          this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
          this._state = "key";
          this._hitLimit = false;
          this._checkingBytes = true;
          this._key = "";
          this._bytesKey = 0;
          this._keyTrunc = false;
          this.decoder.reset();
          p = idxamp + 1;
          if (this._fields === this.fieldsLimit) {
            return cb();
          }
        } else if (this._hitLimit) {
          if (i > p) {
            this._val += this.decoder.write(data.toString("binary", p, i));
          }
          p = i;
          if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
            this._checkingBytes = false;
            this._valTrunc = true;
          }
        } else {
          if (p < len) {
            this._val += this.decoder.write(data.toString("binary", p));
          }
          p = len;
        }
      }
    }
    cb();
  };
  UrlEncoded.prototype.end = function() {
    if (this.boy._done) {
      return;
    }
    if (this._state === "key" && this._key.length > 0) {
      this.boy.emit("field", decodeText(this._key, "binary", this.charset), "", this._keyTrunc, false);
    } else if (this._state === "val") {
      this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
    }
    this.boy._done = true;
    this.boy.emit("finish");
  };
  module.exports = UrlEncoded;
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS((exports, module) => {
  var Busboy = function(opts) {
    if (!(this instanceof Busboy)) {
      return new Busboy(opts);
    }
    if (typeof opts !== "object") {
      throw new TypeError("Busboy expected an options-Object.");
    }
    if (typeof opts.headers !== "object") {
      throw new TypeError("Busboy expected an options-Object with headers-attribute.");
    }
    if (typeof opts.headers["content-type"] !== "string") {
      throw new TypeError("Missing Content-Type-header.");
    }
    const {
      headers,
      ...streamOptions
    } = opts;
    this.opts = {
      autoDestroy: false,
      ...streamOptions
    };
    WritableStream.call(this, this.opts);
    this._done = false;
    this._parser = this.getParserByHeaders(headers);
    this._finished = false;
  };
  var WritableStream = __require("node:stream").Writable;
  var { inherits } = __require("node:util");
  var Dicer = require_Dicer();
  var MultipartParser = require_multipart();
  var UrlencodedParser = require_urlencoded();
  var parseParams = require_parseParams();
  inherits(Busboy, WritableStream);
  Busboy.prototype.emit = function(ev) {
    if (ev === "finish") {
      if (!this._done) {
        this._parser?.end();
        return;
      } else if (this._finished) {
        return;
      }
      this._finished = true;
    }
    WritableStream.prototype.emit.apply(this, arguments);
  };
  Busboy.prototype.getParserByHeaders = function(headers) {
    const parsed = parseParams(headers["content-type"]);
    const cfg = {
      defCharset: this.opts.defCharset,
      fileHwm: this.opts.fileHwm,
      headers,
      highWaterMark: this.opts.highWaterMark,
      isPartAFile: this.opts.isPartAFile,
      limits: this.opts.limits,
      parsedConType: parsed,
      preservePath: this.opts.preservePath
    };
    if (MultipartParser.detect.test(parsed[0])) {
      return new MultipartParser(this, cfg);
    }
    if (UrlencodedParser.detect.test(parsed[0])) {
      return new UrlencodedParser(this, cfg);
    }
    throw new Error("Unsupported Content-Type.");
  };
  Busboy.prototype._write = function(chunk, encoding, cb) {
    this._parser.write(chunk, cb);
  };
  module.exports = Busboy;
  module.exports.default = Busboy;
  module.exports.Busboy = Busboy;
  module.exports.Dicer = Dicer;
});

// node_modules/undici/lib/fetch/constants.js
var require_constants = __commonJS((exports, module) => {
  var { MessageChannel, receiveMessageOnPort } = __require("worker_threads");
  var corsSafeListedMethods = ["GET", "HEAD", "POST"];
  var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
  var nullBodyStatus = [101, 204, 205, 304];
  var redirectStatus = [301, 302, 303, 307, 308];
  var redirectStatusSet = new Set(redirectStatus);
  var badPorts = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6697",
    "10080"
  ];
  var badPortsSet = new Set(badPorts);
  var referrerPolicy = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ];
  var referrerPolicySet = new Set(referrerPolicy);
  var requestRedirect = ["follow", "manual", "error"];
  var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
  var safeMethodsSet = new Set(safeMethods);
  var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
  var requestCredentials = ["omit", "same-origin", "include"];
  var requestCache = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ];
  var requestBodyHeader = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    "content-length"
  ];
  var requestDuplex = [
    "half"
  ];
  var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
  var forbiddenMethodsSet = new Set(forbiddenMethods);
  var subresource = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ];
  var subresourceSet = new Set(subresource);
  var DOMException2 = globalThis.DOMException ?? (() => {
    try {
      atob("~");
    } catch (err) {
      return Object.getPrototypeOf(err).constructor;
    }
  })();
  var channel;
  var structuredClone = globalThis.structuredClone ?? function structuredClone(value, options = undefined) {
    if (arguments.length === 0) {
      throw new TypeError("missing argument");
    }
    if (!channel) {
      channel = new MessageChannel;
    }
    channel.port1.unref();
    channel.port2.unref();
    channel.port1.postMessage(value, options?.transfer);
    return receiveMessageOnPort(channel.port2).message;
  };
  module.exports = {
    DOMException: DOMException2,
    structuredClone,
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicySet
  };
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS((exports, module) => {
  var getGlobalOrigin = function() {
    return globalThis[globalOrigin];
  };
  var setGlobalOrigin = function(newOrigin) {
    if (newOrigin === undefined) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: undefined,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  };
  var globalOrigin = Symbol.for("undici.globalOrigin.1");
  module.exports = {
    getGlobalOrigin,
    setGlobalOrigin
  };
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS((exports, module) => {
  var responseURL = function(response) {
    const urlList = response.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  };
  var responseLocationURL = function(response, requestFragment) {
    if (!redirectStatusSet.has(response.status)) {
      return null;
    }
    let location = response.headersList.get("location");
    if (location !== null && isValidHeaderValue(location)) {
      location = new URL(location, responseURL(response));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  };
  var requestCurrentURL = function(request) {
    return request.urlList[request.urlList.length - 1];
  };
  var requestBadPort = function(request) {
    const url = requestCurrentURL(request);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
      return "blocked";
    }
    return "allowed";
  };
  var isErrorLike = function(object) {
    return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
  };
  var isValidReasonPhrase = function(statusText) {
    for (let i = 0;i < statusText.length; ++i) {
      const c = statusText.charCodeAt(i);
      if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {
        return false;
      }
    }
    return true;
  };
  var isTokenChar = function(c) {
    return !(c >= 127 || c <= 32 || c === "(" || c === ")" || c === "<" || c === ">" || c === "@" || c === "," || c === ";" || c === ":" || c === "\\" || c === '"' || c === "/" || c === "[" || c === "]" || c === "?" || c === "=" || c === "{" || c === "}");
  };
  var isValidHTTPToken = function(characters) {
    if (!characters || typeof characters !== "string") {
      return false;
    }
    for (let i = 0;i < characters.length; ++i) {
      const c = characters.charCodeAt(i);
      if (c > 127 || !isTokenChar(c)) {
        return false;
      }
    }
    return true;
  };
  var isValidHeaderName = function(potentialValue) {
    if (potentialValue.length === 0) {
      return false;
    }
    return isValidHTTPToken(potentialValue);
  };
  var isValidHeaderValue = function(potentialValue) {
    if (potentialValue.startsWith("\t") || potentialValue.startsWith(" ") || potentialValue.endsWith("\t") || potentialValue.endsWith(" ")) {
      return false;
    }
    if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
      return false;
    }
    return true;
  };
  var setRequestReferrerPolicyOnRedirect = function(request, actualResponse) {
    const { headersList } = actualResponse;
    const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
    let policy = "";
    if (policyHeader.length > 0) {
      for (let i = policyHeader.length;i !== 0; i--) {
        const token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    }
    if (policy !== "") {
      request.referrerPolicy = policy;
    }
  };
  var crossOriginResourcePolicyCheck = function() {
    return "allowed";
  };
  var corsCheck = function() {
    return "success";
  };
  var TAOCheck = function() {
    return "success";
  };
  var appendFetchMetadata = function(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header);
  };
  var appendRequestOriginHeader = function(request) {
    let serializedOrigin = request.origin;
    if (request.responseTainting === "cors" || request.mode === "websocket") {
      if (serializedOrigin) {
        request.headersList.append("origin", serializedOrigin);
      }
    } else if (request.method !== "GET" && request.method !== "HEAD") {
      switch (request.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request, requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        default:
      }
      if (serializedOrigin) {
        request.headersList.append("origin", serializedOrigin);
      }
    }
  };
  var coarsenedSharedCurrentTime = function(crossOriginIsolatedCapability) {
    return performance2.now();
  };
  var createOpaqueTimingInfo = function(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  };
  var makePolicyContainer = function() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  };
  var clonePolicyContainer = function(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  };
  var determineRequestsReferrer = function(request) {
    const policy = request.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request.referrer === "client") {
      const globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (request.referrer instanceof URL) {
      referrerSource = request.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    const areSameOrigin = sameOrigin(request, referrerURL);
    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  };
  var stripURLForReferrer = function(url, originOnly) {
    assert(url instanceof URL);
    if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  };
  var isURLPotentiallyTrustworthy = function(url) {
    if (!(url instanceof URL)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:")
      return true;
    if (url.protocol === "file:")
      return true;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null")
        return false;
      const originAsURL = new URL(origin);
      if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
        return true;
      }
      if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
        return true;
      }
      return false;
    }
  };
  var bytesMatch = function(bytes, metadataList) {
    if (crypto === undefined) {
      return true;
    }
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata") {
      return true;
    }
    if (parsedMetadata.length === 0) {
      return true;
    }
    const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));
    const strongest = list[0].algo;
    const metadata = list.filter((item) => item.algo === strongest);
    for (const item of metadata) {
      const algorithm = item.algo;
      let expectedValue = item.hash;
      if (expectedValue.endsWith("==")) {
        expectedValue = expectedValue.slice(0, -2);
      }
      let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue.endsWith("==")) {
        actualValue = actualValue.slice(0, -2);
      }
      if (actualValue === expectedValue) {
        return true;
      }
      let actualBase64URL = crypto.createHash(algorithm).update(bytes).digest("base64url");
      if (actualBase64URL.endsWith("==")) {
        actualBase64URL = actualBase64URL.slice(0, -2);
      }
      if (actualBase64URL === expectedValue) {
        return true;
      }
    }
    return false;
  };
  var parseMetadata = function(metadata) {
    const result = [];
    let empty = true;
    const supportedHashes = crypto.getHashes();
    for (const token of metadata.split(" ")) {
      empty = false;
      const parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === undefined) {
        continue;
      }
      const algorithm = parsedToken.groups.algo;
      if (supportedHashes.includes(algorithm.toLowerCase())) {
        result.push(parsedToken.groups);
      }
    }
    if (empty === true) {
      return "no metadata";
    }
    return result;
  };
  var tryUpgradeRequestToAPotentiallyTrustworthyURL = function(request) {
  };
  var sameOrigin = function(A, B) {
    if (A.origin === B.origin && A.origin === "null") {
      return true;
    }
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
      return true;
    }
    return false;
  };
  var createDeferredPromise = function() {
    let res;
    let rej;
    const promise = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    return { promise, resolve: res, reject: rej };
  };
  var isAborted = function(fetchParams) {
    return fetchParams.controller.state === "aborted";
  };
  var isCancelled = function(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  };
  var normalizeMethod = function(method) {
    return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;
  };
  var serializeJavascriptValueToJSONString = function(value) {
    const result = JSON.stringify(value);
    if (result === undefined) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert(typeof result === "string");
    return result;
  };
  var makeIterator = function(iterator, name, kind) {
    const object = {
      index: 0,
      kind,
      target: iterator
    };
    const i = {
      next() {
        if (Object.getPrototypeOf(this) !== i) {
          throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
        }
        const { index, kind: kind2, target } = object;
        const values = target();
        const len = values.length;
        if (index >= len) {
          return { value: undefined, done: true };
        }
        const pair = values[index];
        object.index = index + 1;
        return iteratorResult(pair, kind2);
      },
      [Symbol.toStringTag]: `${name} Iterator`
    };
    Object.setPrototypeOf(i, esIteratorPrototype);
    return Object.setPrototypeOf({}, i);
  };
  var iteratorResult = function(pair, kind) {
    let result;
    switch (kind) {
      case "key": {
        result = pair[0];
        break;
      }
      case "value": {
        result = pair[1];
        break;
      }
      case "key+value": {
        result = pair;
        break;
      }
    }
    return { value: result, done: false };
  };
  async function fullyReadBody(body, processBody, processBodyError) {
    const successSteps = processBody;
    const errorSteps = processBodyError;
    let reader;
    try {
      reader = body.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    try {
      const result = await readAllBytes(reader);
      successSteps(result);
    } catch (e) {
      errorSteps(e);
    }
  }
  var isReadableStreamLike = function(stream) {
    if (!ReadableStream) {
      ReadableStream = __require("stream/web").ReadableStream;
    }
    return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
  };
  var isomorphicDecode = function(input) {
    if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
      return String.fromCharCode(...input);
    }
    return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
  };
  var readableStreamClose = function(controller) {
    try {
      controller.close();
    } catch (err) {
      if (!err.message.includes("Controller is already closed")) {
        throw err;
      }
    }
  };
  var isomorphicEncode = function(input) {
    for (let i = 0;i < input.length; i++) {
      assert(input.charCodeAt(i) <= 255);
    }
    return input;
  };
  async function readAllBytes(reader) {
    const bytes = [];
    let byteLength = 0;
    while (true) {
      const { done, value: chunk } = await reader.read();
      if (done) {
        return Buffer.concat(bytes, byteLength);
      }
      if (!isUint8Array(chunk)) {
        throw new TypeError("Received non-Uint8Array chunk");
      }
      bytes.push(chunk);
      byteLength += chunk.length;
    }
  }
  var urlIsLocal = function(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  };
  var urlHasHttpsScheme = function(url) {
    if (typeof url === "string") {
      return url.startsWith("https:");
    }
    return url.protocol === "https:";
  };
  var urlIsHttpHttpsScheme = function(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  };
  var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants();
  var { getGlobalOrigin } = require_global();
  var { performance: performance2 } = __require("perf_hooks");
  var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
  var assert = __require("assert");
  var { isUint8Array } = __require("util/types");
  var crypto;
  try {
    crypto = __require("crypto");
  } catch {
  }
  var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\x21-\x7e]?)?/i;
  var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  var ReadableStream = globalThis.ReadableStream;
  var MAXIMUM_ARGUMENT_LENGTH = 65535;
  var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
  module.exports = {
    isAborted,
    isCancelled,
    createDeferredPromise,
    ReadableStreamFrom,
    toUSVString,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isBlobLike,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue,
    hasOwn,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    isReadableStreamLike,
    readableStreamClose,
    isomorphicEncode,
    isomorphicDecode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes
  };
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS((exports, module) => {
  module.exports = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kGuard: Symbol("guard"),
    kRealm: Symbol("realm")
  };
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS((exports, module) => {
  var { types } = __require("util");
  var { hasOwn, toUSVString } = require_util2();
  var webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function(message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    const plural = context.types.length === 1 ? "" : " one of";
    const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I, opts = undefined) {
    if (opts?.strict !== false && !(V instanceof I)) {
      throw new TypeError("Illegal invocation");
    } else {
      return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
    }
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, ` + `but${length ? " only" : ""} ${length} found.`,
        ...ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (V === null) {
          return "Null";
        }
        return "Object";
      }
    }
  };
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
    let upperBound;
    let lowerBound;
    if (bitLength === 64) {
      upperBound = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound = 0;
      } else {
        lowerBound = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound = 0;
      upperBound = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound = Math.pow(-2, bitLength) - 1;
      upperBound = Math.pow(2, bitLength - 1) - 1;
    }
    let x = Number(V);
    if (x === 0) {
      x = 0;
    }
    if (opts.enforceRange === true) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${V} to an integer.`
        });
      }
      x = webidl.util.IntegerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      }
      return x;
    }
    if (!Number.isNaN(x) && opts.clamp === true) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      if (Math.floor(x) % 2 === 0) {
        x = Math.floor(x);
      } else {
        x = Math.ceil(x);
      }
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x = webidl.util.IntegerPart(x);
    x = x % Math.pow(2, bitLength);
    if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
      return x - Math.pow(2, bitLength);
    }
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    const r = Math.floor(Math.abs(n));
    if (n < 0) {
      return -1 * r;
    }
    return r;
  };
  webidl.sequenceConverter = function(converter) {
    return (V) => {
      if (webidl.util.Type(V) !== "Object") {
        throw webidl.errors.exception({
          header: "Sequence",
          message: `Value of type ${webidl.util.Type(V)} is not an Object.`
        });
      }
      const method = V?.[Symbol.iterator]?.();
      const seq = [];
      if (method === undefined || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: "Sequence",
          message: "Object is not an iterator."
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O) => {
      if (webidl.util.Type(O) !== "Object") {
        throw webidl.errors.exception({
          header: "Record",
          message: `Value of type ${webidl.util.Type(O)} is not an Object.`
        });
      }
      const result = {};
      if (!types.isProxy(O)) {
        const keys2 = Object.keys(O);
        for (const key of keys2) {
          const typedKey = keyConverter(key);
          const typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
        return result;
      }
      const keys = Reflect.ownKeys(O);
      for (const key of keys) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc?.enumerable) {
          const typedKey = keyConverter(key);
          const typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
      }
      return result;
    };
  };
  webidl.interfaceConverter = function(i) {
    return (V, opts = {}) => {
      if (opts.strict !== false && !(V instanceof i)) {
        throw webidl.errors.exception({
          header: i.name,
          message: `Expected ${V} to be an instance of ${i.name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary) => {
      const type = webidl.util.Type(dictionary);
      const dict = {};
      if (type === "Null" || type === "Undefined") {
        return dict;
      } else if (type !== "Object") {
        throw webidl.errors.exception({
          header: "Dictionary",
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options of converters) {
        const { key, defaultValue, required, converter } = options;
        if (required === true) {
          if (!hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary[key];
        const hasDefault = hasOwn(options, "defaultValue");
        if (hasDefault && value !== null) {
          value = value ?? defaultValue;
        }
        if (required || hasDefault || value !== undefined) {
          value = converter(value);
          if (options.allowedValues && !options.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V) => {
      if (V === null) {
        return V;
      }
      return converter(V);
    };
  };
  webidl.converters.DOMString = function(V, opts = {}) {
    if (V === null && opts.legacyNullToEmptyString) {
      return "";
    }
    if (typeof V === "symbol") {
      throw new TypeError("Could not convert argument of type symbol to string.");
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V) {
    const x = webidl.converters.DOMString(V);
    for (let index = 0;index < x.length; index++) {
      const charCode = x.charCodeAt(index);
      if (charCode > 255) {
        throw new TypeError("Cannot convert argument to a ByteString because the character at " + `index ${index} has a value of ${charCode} which is greater than 255.`);
      }
    }
    return x;
  };
  webidl.converters.USVString = toUSVString;
  webidl.converters.boolean = function(V) {
    const x = Boolean(V);
    return x;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 64, "signed");
    return x;
  };
  webidl.converters["unsigned long long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 64, "unsigned");
    return x;
  };
  webidl.converters["unsigned long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 32, "unsigned");
    return x;
  };
  webidl.converters["unsigned short"] = function(V, opts) {
    const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
    return x;
  };
  webidl.converters.ArrayBuffer = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix: `${V}`,
        argument: `${V}`,
        types: ["ArrayBuffer"]
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix: `${T.name}`,
        argument: `${V}`,
        types: [T.name]
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
      throw webidl.errors.exception({
        header: "DataView",
        message: "Object is not a DataView."
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.BufferSource = function(V, opts = {}) {
    if (types.isAnyArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, opts);
    }
    if (types.isTypedArray(V)) {
      return webidl.converters.TypedArray(V, V.constructor);
    }
    if (types.isDataView(V)) {
      return webidl.converters.DataView(V, opts);
    }
    throw new TypeError(`Could not convert ${V} to a BufferSource.`);
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
  module.exports = {
    webidl
  };
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS((exports, module) => {
  var dataURLProcessor = function(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(",", input, position);
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      const stringBody = isomorphicDecode(body);
      body = forgivingBase64(stringBody);
      if (body === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020)+$/, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body };
  };
  var URLSerializer = function(url, excludeFragment = false) {
    const href = url.href;
    if (!excludeFragment) {
      return href;
    }
    const hash = href.lastIndexOf("#");
    if (hash === -1) {
      return href;
    }
    return href.slice(0, hash);
  };
  var collectASequenceOfCodePoints = function(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position])) {
      result += input[position.position];
      position.position++;
    }
    return result;
  };
  var collectASequenceOfCodePointsFast = function(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start);
    }
    position.position = idx;
    return input.slice(start, position.position);
  };
  var stringPercentDecode = function(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  };
  var percentDecode = function(input) {
    const output = [];
    for (let i = 0;i < input.length; i++) {
      const byte = input[i];
      if (byte !== 37) {
        output.push(byte);
      } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
        output.push(37);
      } else {
        const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
        const bytePoint = Number.parseInt(nextTwoBytes, 16);
        output.push(bytePoint);
        i += 2;
      }
    }
    return Uint8Array.from(output);
  };
  var parseMIMEType = function(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type = collectASequenceOfCodePointsFast("/", input, position);
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
      return "failure";
    }
    if (position.position > input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(";", input, position);
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      parameters: new Map,
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
      let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position > input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(";", input, position);
      } else {
        parameterValue = collectASequenceOfCodePointsFast(";", input, position);
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  };
  var forgivingBase64 = function(data) {
    data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
    if (data.length % 4 === 0) {
      data = data.replace(/=?=$/, "");
    }
    if (data.length % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data)) {
      return "failure";
    }
    const binary = atob2(data);
    const bytes = new Uint8Array(binary.length);
    for (let byte = 0;byte < binary.length; byte++) {
      bytes[byte] = binary.charCodeAt(byte);
    }
    return bytes;
  };
  var collectAnHTTPQuotedString = function(input, position, extractValue) {
    const positionStart = position.position;
    let value = "";
    assert(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints((char) => char !== '"' && char !== "\\", input, position);
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  };
  var serializeAMimeType = function(mimeType) {
    assert(mimeType !== "failure");
    const { parameters, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/(\\|")/g, "\\$1");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  };
  var isHTTPWhiteSpace = function(char) {
    return char === "\r" || char === "\n" || char === "\t" || char === " ";
  };
  var removeHTTPWhitespace = function(str, leading = true, trailing = true) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      for (;lead < str.length && isHTTPWhiteSpace(str[lead]); lead++)
        ;
    }
    if (trailing) {
      for (;trail > 0 && isHTTPWhiteSpace(str[trail]); trail--)
        ;
    }
    return str.slice(lead, trail + 1);
  };
  var isASCIIWhitespace = function(char) {
    return char === "\r" || char === "\n" || char === "\t" || char === "\f" || char === " ";
  };
  var removeASCIIWhitespace = function(str, leading = true, trailing = true) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      for (;lead < str.length && isASCIIWhitespace(str[lead]); lead++)
        ;
    }
    if (trailing) {
      for (;trail > 0 && isASCIIWhitespace(str[trail]); trail--)
        ;
    }
    return str.slice(lead, trail + 1);
  };
  var assert = __require("assert");
  var { atob: atob2 } = __require("buffer");
  var { isomorphicDecode } = require_util2();
  var encoder = new TextEncoder;
  var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
  var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
  var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
  module.exports = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType
  };
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS((exports, module) => {
  var processBlobParts = function(parts, options) {
    const bytes = [];
    for (const element of parts) {
      if (typeof element === "string") {
        let s = element;
        if (options.endings === "native") {
          s = convertLineEndingsNative(s);
        }
        bytes.push(encoder.encode(s));
      } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
        if (!element.buffer) {
          bytes.push(new Uint8Array(element));
        } else {
          bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
        }
      } else if (isBlobLike(element)) {
        bytes.push(element);
      }
    }
    return bytes;
  };
  var convertLineEndingsNative = function(s) {
    let nativeLineEnding = "\n";
    if (process.platform === "win32") {
      nativeLineEnding = "\r\n";
    }
    return s.replace(/\r?\n/g, nativeLineEnding);
  };
  var isFileLike = function(object) {
    return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
  };
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var { types } = __require("util");
  var { kState } = require_symbols2();
  var { isBlobLike } = require_util2();
  var { webidl } = require_webidl();
  var { parseMIMEType, serializeAMimeType } = require_dataURL();
  var { kEnumerableProperty } = require_util();
  var encoder = new TextEncoder;

  class File extends Blob2 {
    constructor(fileBits, fileName, options = {}) {
      webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
      fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
      fileName = webidl.converters.USVString(fileName);
      options = webidl.converters.FilePropertyBag(options);
      const n = fileName;
      let t = options.type;
      let d;
      substep: {
        if (t) {
          t = parseMIMEType(t);
          if (t === "failure") {
            t = "";
            break substep;
          }
          t = serializeAMimeType(t).toLowerCase();
        }
        d = options.lastModified;
      }
      super(processBlobParts(fileBits, options), { type: t });
      this[kState] = {
        name: n,
        lastModified: d,
        type: t
      };
    }
    get name() {
      webidl.brandCheck(this, File);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, File);
      return this[kState].lastModified;
    }
    get type() {
      webidl.brandCheck(this, File);
      return this[kState].type;
    }
  }

  class FileLike {
    constructor(blobLike, fileName, options = {}) {
      const n = fileName;
      const t = options.type;
      const d = options.lastModified ?? Date.now();
      this[kState] = {
        blobLike,
        name: n,
        type: t,
        lastModified: d
      };
    }
    stream(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.stream(...args);
    }
    arrayBuffer(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.arrayBuffer(...args);
    }
    slice(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.slice(...args);
    }
    text(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.text(...args);
    }
    get size() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.size;
    }
    get type() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.type;
    }
    get name() {
      webidl.brandCheck(this, FileLike);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, FileLike);
      return this[kState].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  Object.defineProperties(File.prototype, {
    [Symbol.toStringTag]: {
      value: "File",
      configurable: true
    },
    name: kEnumerableProperty,
    lastModified: kEnumerableProperty
  });
  webidl.converters.Blob = webidl.interfaceConverter(Blob2);
  webidl.converters.BlobPart = function(V, opts) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
        return webidl.converters.BufferSource(V, opts);
      }
    }
    return webidl.converters.USVString(V, opts);
  };
  webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(webidl.converters.BlobPart);
  webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
    {
      key: "lastModified",
      converter: webidl.converters["long long"],
      get defaultValue() {
        return Date.now();
      }
    },
    {
      key: "type",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "endings",
      converter: (value) => {
        value = webidl.converters.DOMString(value);
        value = value.toLowerCase();
        if (value !== "native") {
          value = "transparent";
        }
        return value;
      },
      defaultValue: "transparent"
    }
  ]);
  module.exports = { File, FileLike, isFileLike };
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS((exports, module) => {
  var makeEntry = function(name, value, filename) {
    name = Buffer.from(name).toString("utf8");
    if (typeof value === "string") {
      value = Buffer.from(value).toString("utf8");
    } else {
      if (!isFileLike(value)) {
        value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
      }
      if (filename !== undefined) {
        const options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
      }
    }
    return { name, value };
  };
  var { isBlobLike, toUSVString, makeIterator } = require_util2();
  var { kState } = require_symbols2();
  var { File: UndiciFile, FileLike, isFileLike } = require_file();
  var { webidl } = require_webidl();
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var File = NativeFile ?? UndiciFile;

  class FormData2 {
    constructor(form) {
      if (form !== undefined) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
      this[kState] = [];
    }
    append(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name);
      value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
      filename = arguments.length === 3 ? webidl.converters.USVString(filename) : undefined;
      const entry = makeEntry(name, value, filename);
      this[kState].push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
      name = webidl.converters.USVString(name);
      this[kState] = this[kState].filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
      name = webidl.converters.USVString(name);
      const idx = this[kState].findIndex((entry) => entry.name === name);
      if (idx === -1) {
        return null;
      }
      return this[kState][idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
      name = webidl.converters.USVString(name);
      return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
      name = webidl.converters.USVString(name);
      return this[kState].findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name);
      value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
      filename = arguments.length === 3 ? toUSVString(filename) : undefined;
      const entry = makeEntry(name, value, filename);
      const idx = this[kState].findIndex((entry2) => entry2.name === name);
      if (idx !== -1) {
        this[kState] = [
          ...this[kState].slice(0, idx),
          entry,
          ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      } else {
        this[kState].push(entry);
      }
    }
    entries() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key+value");
    }
    keys() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key");
    }
    values() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
      if (typeof callbackFn !== "function") {
        throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
      }
      for (const [key, value] of this) {
        callbackFn.apply(thisArg, [value, key, this]);
      }
    }
  }
  FormData2.prototype[Symbol.iterator] = FormData2.prototype.entries;
  Object.defineProperties(FormData2.prototype, {
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  module.exports = { FormData: FormData2 };
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS((exports, module) => {
  var extractBody = function(object, keepalive = false) {
    if (!ReadableStream) {
      ReadableStream = __require("stream/web").ReadableStream;
    }
    let stream = null;
    if (object instanceof ReadableStream) {
      stream = object;
    } else if (isBlobLike(object)) {
      stream = object.stream();
    } else {
      stream = new ReadableStream({
        async pull(controller) {
          controller.enqueue(typeof source === "string" ? textEncoder.encode(source) : source);
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {
        },
        type: undefined
      });
    }
    assert(isReadableStreamLike(stream));
    let action = null;
    let source = null;
    let length = null;
    let type = null;
    if (typeof object === "string") {
      source = object;
      type = "text/plain;charset=UTF-8";
    } else if (object instanceof URLSearchParams) {
      source = object.toString();
      type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isArrayBuffer(object)) {
      source = new Uint8Array(object.slice());
    } else if (ArrayBuffer.isView(object)) {
      source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    } else if (util.isFormDataLike(object)) {
      const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 100000000000)}`.padStart(11, "0")}`;
      const prefix = `--${boundary}\r\nContent-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
      const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object) {
        if (typeof value === "string") {
          const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"` + `\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
          blobParts.push(chunk2);
          length += chunk2.byteLength;
        } else {
          const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + "\r\n" + `Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`);
          blobParts.push(chunk2, value, rn);
          if (typeof value.size === "number") {
            length += chunk2.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk = textEncoder.encode(`--${boundary}--`);
      blobParts.push(chunk);
      length += chunk.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object;
      action = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type = "multipart/form-data; boundary=" + boundary;
    } else if (isBlobLike(object)) {
      source = object;
      length = object.size;
      if (object.type) {
        type = object.type;
      }
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util.isDisturbed(object) || object.locked) {
        throw new TypeError("Response body object should not be disturbed or locked");
      }
      stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
    }
    if (typeof source === "string" || util.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action != null) {
      let iterator;
      stream = new ReadableStream({
        async start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { value, done } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              controller.close();
            });
          } else {
            if (!isErrored(stream)) {
              controller.enqueue(new Uint8Array(value));
            }
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: undefined
      });
    }
    const body = { stream, source, length };
    return [body, type];
  };
  var safelyExtractBody = function(object, keepalive = false) {
    if (!ReadableStream) {
      ReadableStream = __require("stream/web").ReadableStream;
    }
    if (object instanceof ReadableStream) {
      assert(!util.isDisturbed(object), "The body has already been consumed.");
      assert(!object.locked, "The stream is locked.");
    }
    return extractBody(object, keepalive);
  };
  var cloneBody = function(body) {
    const [out1, out2] = body.stream.tee();
    const out2Clone = structuredClone(out2, { transfer: [out2] });
    const [, finalClone] = out2Clone.tee();
    body.stream = out1;
    return {
      stream: finalClone,
      length: body.length,
      source: body.source
    };
  };
  async function* consumeBody(body) {
    if (body) {
      if (isUint8Array(body)) {
        yield body;
      } else {
        const stream = body.stream;
        if (util.isDisturbed(stream)) {
          throw new TypeError("The body has already been consumed.");
        }
        if (stream.locked) {
          throw new TypeError("The stream is locked.");
        }
        stream[kBodyUsed] = true;
        yield* stream;
      }
    }
  }
  var throwIfAborted = function(state) {
    if (state.aborted) {
      throw new DOMException2("The operation was aborted.", "AbortError");
    }
  };
  var bodyMixinMethods = function(instance) {
    const methods = {
      blob() {
        return specConsumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(this);
          if (mimeType === "failure") {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType(mimeType);
          }
          return new Blob2([bytes], { type: mimeType });
        }, instance);
      },
      arrayBuffer() {
        return specConsumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance);
      },
      text() {
        return specConsumeBody(this, utf8DecodeBytes, instance);
      },
      json() {
        return specConsumeBody(this, parseJSONFromBytes, instance);
      },
      async formData() {
        webidl.brandCheck(this, instance);
        throwIfAborted(this[kState]);
        const contentType = this.headers.get("Content-Type");
        if (/multipart\/form-data/.test(contentType)) {
          const headers = {};
          for (const [key, value] of this.headers)
            headers[key.toLowerCase()] = value;
          const responseFormData = new FormData2;
          let busboy;
          try {
            busboy = new Busboy({
              headers,
              preservePath: true
            });
          } catch (err) {
            throw new DOMException2(`${err}`, "AbortError");
          }
          busboy.on("field", (name, value) => {
            responseFormData.append(name, value);
          });
          busboy.on("file", (name, value, filename, encoding, mimeType) => {
            const chunks = [];
            if (encoding === "base64" || encoding.toLowerCase() === "base64") {
              let base64chunk = "";
              value.on("data", (chunk) => {
                base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                const end = base64chunk.length - base64chunk.length % 4;
                chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                base64chunk = base64chunk.slice(end);
              });
              value.on("end", () => {
                chunks.push(Buffer.from(base64chunk, "base64"));
                responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
              });
            } else {
              value.on("data", (chunk) => {
                chunks.push(chunk);
              });
              value.on("end", () => {
                responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
              });
            }
          });
          const busboyResolve = new Promise((resolve, reject) => {
            busboy.on("finish", resolve);
            busboy.on("error", (err) => reject(new TypeError(err)));
          });
          if (this.body !== null)
            for await (const chunk of consumeBody(this[kState].body))
              busboy.write(chunk);
          busboy.end();
          await busboyResolve;
          return responseFormData;
        } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
          let entries;
          try {
            let text = "";
            const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
            for await (const chunk of consumeBody(this[kState].body)) {
              if (!isUint8Array(chunk)) {
                throw new TypeError("Expected Uint8Array chunk");
              }
              text += streamingDecoder.decode(chunk, { stream: true });
            }
            text += streamingDecoder.decode();
            entries = new URLSearchParams(text);
          } catch (err) {
            throw Object.assign(new TypeError, { cause: err });
          }
          const formData = new FormData2;
          for (const [name, value] of entries) {
            formData.append(name, value);
          }
          return formData;
        } else {
          await Promise.resolve();
          throwIfAborted(this[kState]);
          throw webidl.errors.exception({
            header: `${instance.name}.formData`,
            message: "Could not parse content as FormData."
          });
        }
      }
    };
    return methods;
  };
  var mixinBody = function(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  };
  async function specConsumeBody(object, convertBytesToJSValue, instance) {
    webidl.brandCheck(object, instance);
    throwIfAborted(object[kState]);
    if (bodyUnusable(object[kState].body)) {
      throw new TypeError("Body is unusable");
    }
    const promise = createDeferredPromise();
    const errorSteps = (error) => promise.reject(error);
    const successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (object[kState].body == null) {
      successSteps(new Uint8Array);
      return promise.promise;
    }
    await fullyReadBody(object[kState].body, successSteps, errorSteps);
    return promise.promise;
  }
  var bodyUnusable = function(body) {
    return body != null && (body.stream.locked || util.isDisturbed(body.stream));
  };
  var utf8DecodeBytes = function(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output = textDecoder.decode(buffer);
    return output;
  };
  var parseJSONFromBytes = function(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  };
  var bodyMimeType = function(object) {
    const { headersList } = object[kState];
    const contentType = headersList.get("content-type");
    if (contentType === null) {
      return "failure";
    }
    return parseMIMEType(contentType);
  };
  var Busboy = require_main();
  var util = require_util();
  var {
    ReadableStreamFrom,
    isBlobLike,
    isReadableStreamLike,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody
  } = require_util2();
  var { FormData: FormData2 } = require_formdata();
  var { kState } = require_symbols2();
  var { webidl } = require_webidl();
  var { DOMException: DOMException2, structuredClone } = require_constants();
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var { kBodyUsed } = require_symbols();
  var assert = __require("assert");
  var { isErrored } = require_util();
  var { isUint8Array, isArrayBuffer } = __require("util/types");
  var { File: UndiciFile } = require_file();
  var { parseMIMEType, serializeAMimeType } = require_dataURL();
  var ReadableStream = globalThis.ReadableStream;
  var File = NativeFile ?? UndiciFile;
  var textEncoder = new TextEncoder;
  var textDecoder = new TextDecoder;
  module.exports = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody
  };
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS((exports, module) => {
  var processHeaderValue = function(key, val, skipAppend) {
    if (val && typeof val === "object") {
      throw new InvalidArgumentError(`invalid ${key} header`);
    }
    val = val != null ? `${val}` : "";
    if (headerCharRegex.exec(val) !== null) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    }
    return skipAppend ? val : `${key}: ${val}\r\n`;
  };
  var processHeader = function(request, key, val, skipAppend = false) {
    if (val && (typeof val === "object" && !Array.isArray(val))) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === undefined) {
      return;
    }
    if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      request.host = val;
    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
      request.contentLength = parseInt(val, 10);
      if (!Number.isFinite(request.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
      request.contentType = val;
      if (skipAppend)
        request.headers[key] = processHeaderValue(key, val, skipAppend);
      else
        request.headers += processHeaderValue(key, val);
    } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
      throw new InvalidArgumentError("invalid transfer-encoding header");
    } else if (key.length === 10 && key.toLowerCase() === "connection") {
      const value = typeof val === "string" ? val.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive") {
        throw new InvalidArgumentError("invalid connection header");
      } else if (value === "close") {
        request.reset = true;
      }
    } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
      throw new InvalidArgumentError("invalid keep-alive header");
    } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
      throw new InvalidArgumentError("invalid upgrade header");
    } else if (key.length === 6 && key.toLowerCase() === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else if (tokenRegExp.exec(key) === null) {
      throw new InvalidArgumentError("invalid header key");
    } else {
      if (Array.isArray(val)) {
        for (let i = 0;i < val.length; i++) {
          if (skipAppend) {
            if (request.headers[key])
              request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
            else
              request.headers[key] = processHeaderValue(key, val[i], skipAppend);
          } else {
            request.headers += processHeaderValue(key, val[i]);
          }
        }
      } else {
        if (skipAppend)
          request.headers[key] = processHeaderValue(key, val, skipAppend);
        else
          request.headers += processHeaderValue(key, val);
      }
    }
  };
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors();
  var assert = __require("assert");
  var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
  var util = require_util();
  var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
  var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  var invalidPathRegex = /[^\u0021-\u00ff]/;
  var kHandler = Symbol("handler");
  var channels = {};
  var extractBody;
  try {
    const diagnosticsChannel = __require("diagnostics_channel");
    channels.create = diagnosticsChannel.channel("undici:request:create");
    channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
    channels.headers = diagnosticsChannel.channel("undici:request:headers");
    channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
    channels.error = diagnosticsChannel.channel("undici:request:error");
  } catch {
    channels.create = { hasSubscribers: false };
    channels.bodySent = { hasSubscribers: false };
    channels.headers = { hasSubscribers: false };
    channels.trailers = { hasSubscribers: false };
    channels.error = { hasSubscribers: false };
  }

  class Request {
    constructor(origin, {
      path,
      method,
      body,
      headers,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset,
      throwOnError,
      expectContinue
    }, handler) {
      if (typeof path !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      } else if (invalidPathRegex.exec(path) !== null) {
        throw new InvalidArgumentError("invalid request path");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      } else if (tokenRegExp.exec(method) === null) {
        throw new InvalidArgumentError("invalid request method");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("invalid headersTimeout");
      }
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("invalid bodyTimeout");
      }
      if (reset != null && typeof reset !== "boolean") {
        throw new InvalidArgumentError("invalid reset");
      }
      if (expectContinue != null && typeof expectContinue !== "boolean") {
        throw new InvalidArgumentError("invalid expectContinue");
      }
      this.headersTimeout = headersTimeout;
      this.bodyTimeout = bodyTimeout;
      this.throwOnError = throwOnError === true;
      this.method = method;
      this.abort = null;
      if (body == null) {
        this.body = null;
      } else if (util.isStream(body)) {
        this.body = body;
        const rState = this.body._readableState;
        if (!rState || !rState.autoDestroy) {
          this.endHandler = function autoDestroy() {
            util.destroy(this);
          };
          this.body.on("end", this.endHandler);
        }
        this.errorHandler = (err) => {
          if (this.abort) {
            this.abort(err);
          } else {
            this.error = err;
          }
        };
        this.body.on("error", this.errorHandler);
      } else if (util.isBuffer(body)) {
        this.body = body.byteLength ? body : null;
      } else if (ArrayBuffer.isView(body)) {
        this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
      } else if (body instanceof ArrayBuffer) {
        this.body = body.byteLength ? Buffer.from(body) : null;
      } else if (typeof body === "string") {
        this.body = body.length ? Buffer.from(body) : null;
      } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
        this.body = body;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      }
      this.completed = false;
      this.aborted = false;
      this.upgrade = upgrade || null;
      this.path = query ? util.buildURL(path, query) : path;
      this.origin = origin;
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.blocking = blocking == null ? false : blocking;
      this.reset = reset == null ? null : reset;
      this.host = null;
      this.contentLength = null;
      this.contentType = null;
      this.headers = "";
      this.expectContinue = expectContinue != null ? expectContinue : false;
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0;i < headers.length; i += 2) {
          processHeader(this, headers[i], headers[i + 1]);
        }
      } else if (headers && typeof headers === "object") {
        const keys = Object.keys(headers);
        for (let i = 0;i < keys.length; i++) {
          const key = keys[i];
          processHeader(this, key, headers[key]);
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      if (util.isFormDataLike(this.body)) {
        if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
          throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
        }
        if (!extractBody) {
          extractBody = require_body().extractBody;
        }
        const [bodyStream, contentType] = extractBody(body);
        if (this.contentType == null) {
          this.contentType = contentType;
          this.headers += `content-type: ${contentType}\r\n`;
        }
        this.body = bodyStream.stream;
        this.contentLength = bodyStream.length;
      } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
        this.contentType = body.type;
        this.headers += `content-type: ${body.type}\r\n`;
      }
      util.validateHandler(handler, method, upgrade);
      this.servername = util.getServerName(this.host);
      this[kHandler] = handler;
      if (channels.create.hasSubscribers) {
        channels.create.publish({ request: this });
      }
    }
    onBodySent(chunk) {
      if (this[kHandler].onBodySent) {
        try {
          this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.onError(err);
        }
      }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers) {
        channels.bodySent.publish({ request: this });
      }
      if (this[kHandler].onRequestSent) {
        try {
          this[kHandler].onRequestSent();
        } catch (err) {
          this.onError(err);
        }
      }
    }
    onConnect(abort) {
      assert(!this.aborted);
      assert(!this.completed);
      if (this.error) {
        abort(this.error);
      } else {
        this.abort = abort;
        return this[kHandler].onConnect(abort);
      }
    }
    onHeaders(statusCode, headers, resume, statusText) {
      assert(!this.aborted);
      assert(!this.completed);
      if (channels.headers.hasSubscribers) {
        channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
      }
      return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
    }
    onData(chunk) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onData(chunk);
    }
    onUpgrade(statusCode, headers, socket) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      this.onFinally();
      assert(!this.aborted);
      this.completed = true;
      if (channels.trailers.hasSubscribers) {
        channels.trailers.publish({ request: this, trailers });
      }
      return this[kHandler].onComplete(trailers);
    }
    onError(error) {
      this.onFinally();
      if (channels.error.hasSubscribers) {
        channels.error.publish({ request: this, error });
      }
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      return this[kHandler].onError(error);
    }
    onFinally() {
      if (this.errorHandler) {
        this.body.off("error", this.errorHandler);
        this.errorHandler = null;
      }
      if (this.endHandler) {
        this.body.off("end", this.endHandler);
        this.endHandler = null;
      }
    }
    addHeader(key, value) {
      processHeader(this, key, value);
      return this;
    }
    static [kHTTP1BuildRequest](origin, opts, handler) {
      return new Request(origin, opts, handler);
    }
    static [kHTTP2BuildRequest](origin, opts, handler) {
      const headers = opts.headers;
      opts = { ...opts, headers: null };
      const request = new Request(origin, opts, handler);
      request.headers = {};
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0;i < headers.length; i += 2) {
          processHeader(request, headers[i], headers[i + 1], true);
        }
      } else if (headers && typeof headers === "object") {
        const keys = Object.keys(headers);
        for (let i = 0;i < keys.length; i++) {
          const key = keys[i];
          processHeader(request, key, headers[key], true);
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      return request;
    }
    static [kHTTP2CopyHeaders](raw) {
      const rawHeaders = raw.split("\r\n");
      const headers = {};
      for (const header of rawHeaders) {
        const [key, value] = header.split(": ");
        if (value == null || value.length === 0)
          continue;
        if (headers[key])
          headers[key] += `,${value}`;
        else
          headers[key] = value;
      }
      return headers;
    }
  }
  module.exports = Request;
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS((exports, module) => {
  var EventEmitter = __require("events");

  class Dispatcher extends EventEmitter {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
  }
  module.exports = Dispatcher;
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher();
  var {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = require_errors();
  var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
  var kDestroyed = Symbol("destroyed");
  var kClosed = Symbol("closed");
  var kOnDestroyed = Symbol("onDestroyed");
  var kOnClosed = Symbol("onClosed");
  var kInterceptedDispatch = Symbol("Intercepted Dispatch");

  class DispatcherBase extends Dispatcher {
    constructor() {
      super();
      this[kDestroyed] = false;
      this[kOnDestroyed] = null;
      this[kClosed] = false;
      this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors];
    }
    set interceptors(newInterceptors) {
      if (newInterceptors) {
        for (let i = newInterceptors.length - 1;i >= 0; i--) {
          const interceptor = this[kInterceptors][i];
          if (typeof interceptor !== "function") {
            throw new InvalidArgumentError("interceptor must be an function");
          }
        }
      }
      this[kInterceptors] = newInterceptors;
    }
    close(callback) {
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        queueMicrotask(() => callback(new ClientDestroyedError, null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed]) {
          this[kOnClosed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      this[kClosed] = true;
      this[kOnClosed].push(callback);
      const onClosed = () => {
        const callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kClose]().then(() => this.destroy()).then(() => {
        queueMicrotask(onClosed);
      });
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject(err2) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError;
      }
      this[kDestroyed] = true;
      this[kOnDestroyed] = this[kOnDestroyed] || [];
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kDestroy](err).then(() => {
        queueMicrotask(onDestroyed);
      });
    }
    [kInterceptedDispatch](opts, handler) {
      if (!this[kInterceptors] || this[kInterceptors].length === 0) {
        this[kInterceptedDispatch] = this[kDispatch];
        return this[kDispatch](opts, handler);
      }
      let dispatch = this[kDispatch].bind(this);
      for (let i = this[kInterceptors].length - 1;i >= 0; i--) {
        dispatch = this[kInterceptors][i](dispatch);
      }
      this[kInterceptedDispatch] = dispatch;
      return dispatch(opts, handler);
    }
    dispatch(opts, handler) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      try {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object.");
        }
        if (this[kDestroyed] || this[kOnDestroyed]) {
          throw new ClientDestroyedError;
        }
        if (this[kClosed]) {
          throw new ClientClosedError;
        }
        return this[kInterceptedDispatch](opts, handler);
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
        return false;
      }
    }
  }
  module.exports = DispatcherBase;
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS((exports, module) => {
  var buildConnector = function({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    }
    const options = { path: socketPath, ...opts };
    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    timeout = timeout == null ? 1e4 : timeout;
    allowH2 = allowH2 != null ? allowH2 : false;
    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls) {
          tls = __require("tls");
        }
        servername = servername || options.servername || util.getServerName(host) || null;
        const sessionKey = servername || hostname;
        const session = sessionCache.get(sessionKey) || null;
        assert(sessionKey);
        socket = tls.connect({
          highWaterMark: 16384,
          ...options,
          servername,
          session,
          localAddress,
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          port: port || 443,
          host: hostname
        });
        socket.on("session", function(session2) {
          sessionCache.set(sessionKey, session2);
        });
      } else {
        assert(!httpSocket, "httpSocket can only be sent on TLS update");
        socket = net.connect({
          highWaterMark: 64 * 1024,
          ...options,
          localAddress,
          port: port || 80,
          host: hostname
        });
      }
      if (options.keepAlive == null || options.keepAlive) {
        const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60000 : options.keepAliveInitialDelay;
        socket.setKeepAlive(true, keepAliveInitialDelay);
      }
      const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
      socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(null, this);
        }
      }).on("error", function(err) {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(err);
        }
      });
      return socket;
    };
  };
  var setupTimeout = function(onConnectTimeout2, timeout) {
    if (!timeout) {
      return () => {
      };
    }
    let s1 = null;
    let s2 = null;
    const timeoutId = setTimeout(() => {
      s1 = setImmediate(() => {
        if (process.platform === "win32") {
          s2 = setImmediate(() => onConnectTimeout2());
        } else {
          onConnectTimeout2();
        }
      });
    }, timeout);
    return () => {
      clearTimeout(timeoutId);
      clearImmediate(s1);
      clearImmediate(s2);
    };
  };
  var onConnectTimeout = function(socket) {
    util.destroy(socket, new ConnectTimeoutError);
  };
  var net = __require("net");
  var assert = __require("assert");
  var util = require_util();
  var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
  var tls;
  var SessionCache;
  if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
    SessionCache = class WeakSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
        this._sessionRegistry = new global.FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions) {
            return;
          }
          const ref = this._sessionCache.get(key);
          if (ref !== undefined && ref.deref() === undefined) {
            this._sessionCache.delete(key);
          }
        });
      }
      get(sessionKey) {
        const ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        this._sessionCache.set(sessionKey, new WeakRef(session));
        this._sessionRegistry.register(session, sessionKey);
      }
    };
  } else {
    SessionCache = class SimpleSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
      }
      get(sessionKey) {
        return this._sessionCache.get(sessionKey);
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: oldestKey } = this._sessionCache.keys().next();
          this._sessionCache.delete(oldestKey);
        }
        this._sessionCache.set(sessionKey, session);
      }
    };
  }
  module.exports = buildConnector;
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils = __commonJS((exports) => {
  var enumToMap = function(obj) {
    const res = {};
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (typeof value === "number") {
        res[key] = value;
      }
    });
    return res;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.enumToMap = undefined;
  exports.enumToMap = enumToMap;
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = undefined;
  var utils_1 = require_utils();
  var ERROR;
  (function(ERROR2) {
    ERROR2[ERROR2["OK"] = 0] = "OK";
    ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
    ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
    ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
    ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
    ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
    ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
    ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
    ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
    ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
    ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
    ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
    ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
    ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
    ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
    ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
    ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
    ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
    ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
    ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
    ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
    ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
    ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
    ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
    ERROR2[ERROR2["USER"] = 24] = "USER";
  })(ERROR = exports.ERROR || (exports.ERROR = {}));
  var TYPE;
  (function(TYPE2) {
    TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
    TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
    TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
  })(TYPE = exports.TYPE || (exports.TYPE = {}));
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
    FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
    FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
    FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
    FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
    FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
    FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
    FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
    FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
  })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
  var LENIENT_FLAGS;
  (function(LENIENT_FLAGS2) {
    LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
    LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
    LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
  })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
  var METHODS;
  (function(METHODS2) {
    METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
    METHODS2[METHODS2["GET"] = 1] = "GET";
    METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
    METHODS2[METHODS2["POST"] = 3] = "POST";
    METHODS2[METHODS2["PUT"] = 4] = "PUT";
    METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
    METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
    METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
    METHODS2[METHODS2["COPY"] = 8] = "COPY";
    METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
    METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
    METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
    METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
    METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
    METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
    METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
    METHODS2[METHODS2["BIND"] = 16] = "BIND";
    METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
    METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
    METHODS2[METHODS2["ACL"] = 19] = "ACL";
    METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
    METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
    METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
    METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
    METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
    METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
    METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
    METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
    METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
    METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
    METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
    METHODS2[METHODS2["LINK"] = 31] = "LINK";
    METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
    METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
    METHODS2[METHODS2["PRI"] = 34] = "PRI";
    METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
    METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
    METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
    METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
    METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
    METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
    METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
    METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
    METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
    METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
    METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
  })(METHODS = exports.METHODS || (exports.METHODS = {}));
  exports.METHODS_HTTP = [
    METHODS.DELETE,
    METHODS.GET,
    METHODS.HEAD,
    METHODS.POST,
    METHODS.PUT,
    METHODS.CONNECT,
    METHODS.OPTIONS,
    METHODS.TRACE,
    METHODS.COPY,
    METHODS.LOCK,
    METHODS.MKCOL,
    METHODS.MOVE,
    METHODS.PROPFIND,
    METHODS.PROPPATCH,
    METHODS.SEARCH,
    METHODS.UNLOCK,
    METHODS.BIND,
    METHODS.REBIND,
    METHODS.UNBIND,
    METHODS.ACL,
    METHODS.REPORT,
    METHODS.MKACTIVITY,
    METHODS.CHECKOUT,
    METHODS.MERGE,
    METHODS["M-SEARCH"],
    METHODS.NOTIFY,
    METHODS.SUBSCRIBE,
    METHODS.UNSUBSCRIBE,
    METHODS.PATCH,
    METHODS.PURGE,
    METHODS.MKCALENDAR,
    METHODS.LINK,
    METHODS.UNLINK,
    METHODS.PRI,
    METHODS.SOURCE
  ];
  exports.METHODS_ICE = [
    METHODS.SOURCE
  ];
  exports.METHODS_RTSP = [
    METHODS.OPTIONS,
    METHODS.DESCRIBE,
    METHODS.ANNOUNCE,
    METHODS.SETUP,
    METHODS.PLAY,
    METHODS.PAUSE,
    METHODS.TEARDOWN,
    METHODS.GET_PARAMETER,
    METHODS.SET_PARAMETER,
    METHODS.REDIRECT,
    METHODS.RECORD,
    METHODS.FLUSH,
    METHODS.GET,
    METHODS.POST
  ];
  exports.METHOD_MAP = utils_1.enumToMap(METHODS);
  exports.H_METHOD_MAP = {};
  Object.keys(exports.METHOD_MAP).forEach((key) => {
    if (/^H/.test(key)) {
      exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
    }
  });
  var FINISH;
  (function(FINISH2) {
    FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
    FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
    FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
  })(FINISH = exports.FINISH || (exports.FINISH = {}));
  exports.ALPHA = [];
  for (let i = "A".charCodeAt(0);i <= "Z".charCodeAt(0); i++) {
    exports.ALPHA.push(String.fromCharCode(i));
    exports.ALPHA.push(String.fromCharCode(i + 32));
  }
  exports.NUM_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  };
  exports.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };
  exports.NUM = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
  exports.MARK = ["-", "_", ".", "!", "~", "*", "\'", "(", ")"];
  exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
  exports.STRICT_URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "\'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~"
  ].concat(exports.ALPHANUM);
  exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["\t", "\f"]);
  for (let i = 128;i <= 255; i++) {
    exports.URL_CHAR.push(i);
  }
  exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
  exports.STRICT_TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "\'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~"
  ].concat(exports.ALPHANUM);
  exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
  exports.HEADER_CHARS = ["\t"];
  for (let i = 32;i <= 255; i++) {
    if (i !== 127) {
      exports.HEADER_CHARS.push(i);
    }
  }
  exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
  exports.MAJOR = exports.NUM_MAP;
  exports.MINOR = exports.MAJOR;
  var HEADER_STATE;
  (function(HEADER_STATE2) {
    HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
    HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
    HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
    HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
  })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
  exports.SPECIAL_HEADERS = {
    connection: HEADER_STATE.CONNECTION,
    "content-length": HEADER_STATE.CONTENT_LENGTH,
    "proxy-connection": HEADER_STATE.CONNECTION,
    "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
    upgrade: HEADER_STATE.UPGRADE
  };
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS((exports, module) => {
  var parseLocation = function(statusCode, headers) {
    if (redirectableStatusCodes.indexOf(statusCode) === -1) {
      return null;
    }
    for (let i = 0;i < headers.length; i += 2) {
      if (headers[i].toString().toLowerCase() === "location") {
        return headers[i + 1];
      }
    }
  };
  var shouldRemoveHeader = function(header, removeContent, unknownOrigin) {
    return header.length === 4 && header.toString().toLowerCase() === "host" || removeContent && header.toString().toLowerCase().indexOf("content-") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === "authorization" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === "cookie";
  };
  var cleanRequestHeaders = function(headers, removeContent, unknownOrigin) {
    const ret = [];
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
          ret.push(headers[i], headers[i + 1]);
        }
      }
    } else if (headers && typeof headers === "object") {
      for (const key of Object.keys(headers)) {
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
          ret.push(key, headers[key]);
        }
      }
    } else {
      assert(headers == null, "headers must be an object or an array");
    }
    return ret;
  };
  var util = require_util();
  var { kBodyUsed } = require_symbols();
  var assert = __require("assert");
  var { InvalidArgumentError } = require_errors();
  var EE = __require("events");
  var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  var kBody = Symbol("body");

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body;
      this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }

  class RedirectHandler {
    constructor(dispatch, maxRedirections, opts, handler) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      util.validateHandler(handler, opts.method, opts.upgrade);
      this.dispatch = dispatch;
      this.location = null;
      this.abort = null;
      this.opts = { ...opts, maxRedirections: 0 };
      this.maxRedirections = maxRedirections;
      this.handler = handler;
      this.history = [];
      if (util.isStream(this.opts.body)) {
        if (util.bodyLength(this.opts.body) === 0) {
          this.opts.body.on("data", function() {
            assert(false);
          });
        }
        if (typeof this.opts.body.readableDidRead !== "boolean") {
          this.opts.body[kBodyUsed] = false;
          EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      }
    }
    onConnect(abort) {
      this.abort = abort;
      this.handler.onConnect(abort, { history: this.history });
    }
    onUpgrade(statusCode, headers, socket) {
      this.handler.onUpgrade(statusCode, headers, socket);
    }
    onError(error) {
      this.handler.onError(error);
    }
    onHeaders(statusCode, headers, resume, statusText) {
      this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
      if (this.opts.origin) {
        this.history.push(new URL(this.opts.path, this.opts.origin));
      }
      if (!this.location) {
        return this.handler.onHeaders(statusCode, headers, resume, statusText);
      }
      const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
      const path = search ? `${pathname}${search}` : pathname;
      this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
      this.opts.path = path;
      this.opts.origin = origin;
      this.opts.maxRedirections = 0;
      this.opts.query = null;
      if (statusCode === 303 && this.opts.method !== "HEAD") {
        this.opts.method = "GET";
        this.opts.body = null;
      }
    }
    onData(chunk) {
      if (this.location) {
      } else {
        return this.handler.onData(chunk);
      }
    }
    onComplete(trailers) {
      if (this.location) {
        this.location = null;
        this.abort = null;
        this.dispatch(this.opts, this);
      } else {
        this.handler.onComplete(trailers);
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent) {
        this.handler.onBodySent(chunk);
      }
    }
  }
  module.exports = RedirectHandler;
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS((exports, module) => {
  var createRedirectInterceptor = function({ maxRedirections: defaultMaxRedirections }) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { maxRedirections = defaultMaxRedirections } = opts;
        if (!maxRedirections) {
          return dispatch(opts, handler);
        }
        const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
        opts = { ...opts, maxRedirections: 0 };
        return dispatch(opts, redirectHandler);
      };
    };
  };
  var RedirectHandler = require_RedirectHandler();
  module.exports = createRedirectInterceptor;
});

// node_modules/undici/lib/client.js
var require_client = __commonJS((exports, module) => {
  var onHttp2SessionError = function(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kSocket][kError] = err;
    onError(this[kClient], err);
  };
  var onHttp2FrameError = function(type, code, id) {
    const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
    if (id === 0) {
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
  };
  var onHttp2SessionEnd = function() {
    util.destroy(this, new SocketError("other side closed"));
    util.destroy(this[kSocket], new SocketError("other side closed"));
  };
  var onHTTP2GoAway = function(code) {
    const client = this[kClient];
    const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
    client[kSocket] = null;
    client[kHTTP2Session] = null;
    if (client.destroyed) {
      assert(this[kPending] === 0);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        errorRequest(this, request, err);
      }
    } else if (client[kRunning] > 0) {
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx];
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    resume(client);
  };
  async function lazyllhttp() {
    const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : undefined;
    let mod;
    try {
      mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
    } catch (e) {
      mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
    }
    return await WebAssembly.instantiate(mod, {
      env: {
        wasm_on_url: (p, at, len) => {
          return 0;
        },
        wasm_on_status: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_begin: (p) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageBegin() || 0;
        },
        wasm_on_header_field: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_header_value: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
        },
        wasm_on_body: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_complete: (p) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageComplete() || 0;
        }
      }
    });
  }
  var onParserTimeout = function(parser) {
    const { socket, timeoutType, client } = parser;
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
        assert(!parser.paused, "cannot be paused while waiting for headers");
        util.destroy(socket, new HeadersTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!parser.paused) {
        util.destroy(socket, new BodyTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_IDLE) {
      assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
      util.destroy(socket, new InformationalError("socket idle timeout"));
    }
  };
  var onSocketReadable = function() {
    const { [kParser]: parser } = this;
    if (parser) {
      parser.readMore();
    }
  };
  var onSocketError = function(err) {
    const { [kClient]: client, [kParser]: parser } = this;
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    if (client[kHTTPConnVersion] !== "h2") {
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    this[kError] = err;
    onError(this[kClient], err);
  };
  var onError = function(client, err) {
    if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        errorRequest(client, request, err);
      }
      assert(client[kSize] === 0);
    }
  };
  var onSocketEnd = function() {
    const { [kParser]: parser, [kClient]: client } = this;
    if (client[kHTTPConnVersion] !== "h2") {
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
  };
  var onSocketClose = function() {
    const { [kClient]: client, [kParser]: parser } = this;
    if (client[kHTTPConnVersion] === "h1" && parser) {
      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
      }
      this[kParser].destroy();
      this[kParser] = null;
    }
    const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
    client[kSocket] = null;
    if (client.destroyed) {
      assert(client[kPending] === 0);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        errorRequest(client, request, err);
      }
    } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx];
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    resume(client);
  };
  async function connect(client) {
    assert(!client[kConnecting]);
    assert(!client[kSocket]);
    let { host, hostname, protocol, port } = client[kUrl];
    if (hostname[0] === "[") {
      const idx = hostname.indexOf("]");
      assert(idx !== -1);
      const ip = hostname.substr(1, idx - 1);
      assert(net.isIP(ip));
      hostname = ip;
    }
    client[kConnecting] = true;
    if (channels.beforeConnect.hasSubscribers) {
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector]
      });
    }
    try {
      const socket = await new Promise((resolve, reject) => {
        client[kConnector]({
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        }, (err, socket2) => {
          if (err) {
            reject(err);
          } else {
            resolve(socket2);
          }
        });
      });
      if (client.destroyed) {
        util.destroy(socket.on("error", () => {
        }), new ClientDestroyedError);
        return;
      }
      client[kConnecting] = false;
      assert(socket);
      const isH2 = socket.alpnProtocol === "h2";
      if (isH2) {
        if (!h2ExperimentalWarned) {
          h2ExperimentalWarned = true;
          process.emitWarning("H2 support is experimental, expect them to change at any time.", {
            code: "UNDICI-H2"
          });
        }
        const session = http2.connect(client[kUrl], {
          createConnection: () => socket,
          peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
        });
        client[kHTTPConnVersion] = "h2";
        session[kClient] = client;
        session[kSocket] = socket;
        session.on("error", onHttp2SessionError);
        session.on("frameError", onHttp2FrameError);
        session.on("end", onHttp2SessionEnd);
        session.on("goaway", onHTTP2GoAway);
        session.on("close", onSocketClose);
        session.unref();
        client[kHTTP2Session] = session;
        socket[kHTTP2Session] = session;
      } else {
        if (!llhttpInstance) {
          llhttpInstance = await llhttpPromise;
          llhttpPromise = null;
        }
        socket[kNoRef] = false;
        socket[kWriting] = false;
        socket[kReset] = false;
        socket[kBlocking] = false;
        socket[kParser] = new Parser(client, socket, llhttpInstance);
      }
      socket[kCounter] = 0;
      socket[kMaxRequests] = client[kMaxRequests];
      socket[kClient] = client;
      socket[kError] = null;
      socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
      client[kSocket] = socket;
      if (channels.connected.hasSubscribers) {
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          socket
        });
      }
      client.emit("connect", client[kUrl], [client]);
    } catch (err) {
      if (client.destroyed) {
        return;
      }
      client[kConnecting] = false;
      if (channels.connectError.hasSubscribers) {
        channels.connectError.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          error: err
        });
      }
      if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        assert(client[kRunning] === 0);
        while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
          const request = client[kQueue][client[kPendingIdx]++];
          errorRequest(client, request, err);
        }
      } else {
        onError(client, err);
      }
      client.emit("connectionError", client[kUrl], [client], err);
    }
    resume(client);
  }
  var emitDrain = function(client) {
    client[kNeedDrain] = 0;
    client.emit("drain", client[kUrl], [client]);
  };
  var resume = function(client, sync) {
    if (client[kResuming] === 2) {
      return;
    }
    client[kResuming] = 2;
    _resume(client, sync);
    client[kResuming] = 0;
    if (client[kRunningIdx] > 256) {
      client[kQueue].splice(0, client[kRunningIdx]);
      client[kPendingIdx] -= client[kRunningIdx];
      client[kRunningIdx] = 0;
    }
  };
  var _resume = function(client, sync) {
    while (true) {
      if (client.destroyed) {
        assert(client[kPending] === 0);
        return;
      }
      if (client[kClosedResolve] && !client[kSize]) {
        client[kClosedResolve]();
        client[kClosedResolve] = null;
        return;
      }
      const socket = client[kSocket];
      if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
        if (client[kSize] === 0) {
          if (!socket[kNoRef] && socket.unref) {
            socket.unref();
            socket[kNoRef] = true;
          }
        } else if (socket[kNoRef] && socket.ref) {
          socket.ref();
          socket[kNoRef] = false;
        }
        if (client[kSize] === 0) {
          if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
            socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
          }
        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
          if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            const request2 = client[kQueue][client[kRunningIdx]];
            const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
      }
      if (client[kBusy]) {
        client[kNeedDrain] = 2;
      } else if (client[kNeedDrain] === 2) {
        if (sync) {
          client[kNeedDrain] = 1;
          process.nextTick(emitDrain, client);
        } else {
          emitDrain(client);
        }
        continue;
      }
      if (client[kPending] === 0) {
        return;
      }
      if (client[kRunning] >= (client[kPipelining] || 1)) {
        return;
      }
      const request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
        if (client[kRunning] > 0) {
          return;
        }
        client[kServerName] = request.servername;
        if (socket && socket.servername !== request.servername) {
          util.destroy(socket, new InformationalError("servername changed"));
          return;
        }
      }
      if (client[kConnecting]) {
        return;
      }
      if (!socket && !client[kHTTP2Session]) {
        connect(client);
        return;
      }
      if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
        return;
      }
      if (client[kRunning] > 0 && !request.idempotent) {
        return;
      }
      if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
        return;
      }
      if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
        return;
      }
      if (!request.aborted && write(client, request)) {
        client[kPendingIdx]++;
      } else {
        client[kQueue].splice(client[kPendingIdx], 1);
      }
    }
  };
  var shouldSendContentLength = function(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  };
  var write = function(client, request) {
    if (client[kHTTPConnVersion] === "h2") {
      writeH2(client, client[kHTTP2Session], request);
      return;
    }
    const { body, method, path, host, upgrade, headers, blocking, reset } = request;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    const bodyLength = util.bodyLength(body);
    let contentLength = bodyLength;
    if (contentLength === null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    const socket = client[kSocket];
    try {
      request.onConnect((err) => {
        if (request.aborted || request.completed) {
          return;
        }
        errorRequest(client, request, err || new RequestAbortedError);
        util.destroy(socket, new InformationalError("aborted"));
      });
    } catch (err) {
      errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade || method === "CONNECT") {
      socket[kReset] = true;
    }
    if (reset != null) {
      socket[kReset] = reset;
    }
    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
      socket[kReset] = true;
    }
    if (blocking) {
      socket[kBlocking] = true;
    }
    let header = `${method} ${path} HTTP/1.1\r\n`;
    if (typeof host === "string") {
      header += `host: ${host}\r\n`;
    } else {
      header += client[kHostHeader];
    }
    if (upgrade) {
      header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`;
    } else if (client[kPipelining] && !socket[kReset]) {
      header += "connection: keep-alive\r\n";
    } else {
      header += "connection: close\r\n";
    }
    if (headers) {
      header += headers;
    }
    if (channels.sendHeaders.hasSubscribers) {
      channels.sendHeaders.publish({ request, headers: header, socket });
    }
    if (!body || bodyLength === 0) {
      if (contentLength === 0) {
        socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
      } else {
        assert(contentLength === null, "no body must not have content length");
        socket.write(`${header}\r\n`, "latin1");
      }
      request.onRequestSent();
    } else if (util.isBuffer(body)) {
      assert(contentLength === body.byteLength, "buffer body must have content length");
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
      socket.write(body);
      socket.uncork();
      request.onBodySent(body);
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
    } else if (util.isBlobLike(body)) {
      if (typeof body.stream === "function") {
        writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
      } else {
        writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
      }
    } else if (util.isStream(body)) {
      writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
    } else if (util.isIterable(body)) {
      writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
    } else {
      assert(false);
    }
    return true;
  };
  var writeH2 = function(client, session, request) {
    const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
    let headers;
    if (typeof reqHeaders === "string")
      headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
    else
      headers = reqHeaders;
    if (upgrade) {
      errorRequest(client, request, new Error("Upgrade not supported for H2"));
      return false;
    }
    try {
      request.onConnect((err) => {
        if (request.aborted || request.completed) {
          return;
        }
        errorRequest(client, request, err || new RequestAbortedError);
      });
    } catch (err) {
      errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    let stream;
    const h2State = client[kHTTP2SessionState];
    headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
    headers[HTTP2_HEADER_METHOD] = method;
    if (method === "CONNECT") {
      session.ref();
      stream = session.request(headers, { endStream: false, signal });
      if (stream.id && !stream.pending) {
        request.onUpgrade(null, null, stream);
        ++h2State.openStreams;
      } else {
        stream.once("ready", () => {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        });
      }
      stream.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0)
          session.unref();
      });
      return true;
    }
    headers[HTTP2_HEADER_PATH] = path;
    headers[HTTP2_HEADER_SCHEME] = "https";
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    let contentLength = util.bodyLength(body);
    if (contentLength == null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 || !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    if (contentLength != null) {
      assert(body, "no body must not have content length");
      headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
    }
    session.ref();
    const shouldEndStream = method === "GET" || method === "HEAD";
    if (expectContinue) {
      headers[HTTP2_HEADER_EXPECT] = "100-continue";
      stream = session.request(headers, { endStream: shouldEndStream, signal });
      stream.once("continue", writeBodyH2);
    } else {
      stream = session.request(headers, {
        endStream: shouldEndStream,
        signal
      });
      writeBodyH2();
    }
    ++h2State.openStreams;
    stream.once("response", (headers2) => {
      if (request.onHeaders(Number(headers2[HTTP2_HEADER_STATUS]), headers2, stream.resume.bind(stream), "") === false) {
        stream.pause();
      }
    });
    stream.once("end", () => {
      request.onComplete([]);
    });
    stream.on("data", (chunk) => {
      if (request.onData(chunk) === false)
        stream.pause();
    });
    stream.once("close", () => {
      h2State.openStreams -= 1;
      if (h2State.openStreams === 0)
        session.unref();
    });
    stream.once("error", function(err) {
      if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
        h2State.streams -= 1;
        util.destroy(stream, err);
      }
    });
    stream.once("frameError", (type, code) => {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      errorRequest(client, request, err);
      if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
        h2State.streams -= 1;
        util.destroy(stream, err);
      }
    });
    return true;
    function writeBodyH2() {
      if (!body) {
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        stream.cork();
        stream.write(body);
        stream.uncork();
        stream.end();
        request.onBodySent(body);
        request.onRequestSent();
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({
            client,
            request,
            contentLength,
            h2stream: stream,
            expectsPayload,
            body: body.stream(),
            socket: client[kSocket],
            header: ""
          });
        } else {
          writeBlob({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            h2stream: stream,
            header: "",
            socket: client[kSocket]
          });
        }
      } else if (util.isStream(body)) {
        writeStream({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          socket: client[kSocket],
          h2stream: stream,
          header: ""
        });
      } else if (util.isIterable(body)) {
        writeIterable({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          header: "",
          h2stream: stream,
          socket: client[kSocket]
        });
      } else {
        assert(false);
      }
    }
  };
  var writeStream = function({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    if (client[kHTTPConnVersion] === "h2") {
      let onPipeData = function(chunk) {
        request.onBodySent(chunk);
      };
      const pipe = pipeline(body, h2stream, (err) => {
        if (err) {
          util.destroy(body, err);
          util.destroy(h2stream, err);
        } else {
          request.onRequestSent();
        }
      });
      pipe.on("data", onPipeData);
      pipe.once("end", () => {
        pipe.removeListener("data", onPipeData);
        util.destroy(pipe);
      });
      return;
    }
    let finished = false;
    const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
    const onData = function(chunk) {
      if (finished) {
        return;
      }
      try {
        if (!writer.write(chunk) && this.pause) {
          this.pause();
        }
      } catch (err) {
        util.destroy(this, err);
      }
    };
    const onDrain = function() {
      if (finished) {
        return;
      }
      if (body.resume) {
        body.resume();
      }
    };
    const onAbort = function() {
      onFinished(new RequestAbortedError);
    };
    const onFinished = function(err) {
      if (finished) {
        return;
      }
      finished = true;
      assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
      socket.off("drain", onDrain).off("error", onFinished);
      body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
      if (!err) {
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      }
      writer.destroy(err);
      if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
        util.destroy(body, err);
      } else {
        util.destroy(body);
      }
    };
    body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
    if (body.resume) {
      body.resume();
    }
    socket.on("drain", onDrain).on("error", onFinished);
  };
  async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength === body.size, "blob body must have content length");
    const isH2 = client[kHTTPConnVersion] === "h2";
    try {
      if (contentLength != null && contentLength !== body.size) {
        throw new RequestContentLengthMismatchError;
      }
      const buffer = Buffer.from(await body.arrayBuffer());
      if (isH2) {
        h2stream.cork();
        h2stream.write(buffer);
        h2stream.uncork();
      } else {
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
        socket.write(buffer);
        socket.uncork();
      }
      request.onBodySent(buffer);
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      resume(client);
    } catch (err) {
      util.destroy(isH2 ? h2stream : socket, err);
    }
  }
  async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    if (client[kHTTPConnVersion] === "h2") {
      h2stream.on("close", onDrain).on("drain", onDrain);
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          const res = h2stream.write(chunk);
          request.onBodySent(chunk);
          if (!res) {
            await waitForDrain();
          }
        }
      } catch (err) {
        h2stream.destroy(err);
      } finally {
        request.onRequestSent();
        h2stream.end();
        h2stream.off("close", onDrain).off("drain", onDrain);
      }
      return;
    }
    socket.on("close", onDrain).on("drain", onDrain);
    const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
    try {
      for await (const chunk of body) {
        if (socket[kError]) {
          throw socket[kError];
        }
        if (!writer.write(chunk)) {
          await waitForDrain();
        }
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }
  var errorRequest = function(client, request, err) {
    try {
      request.onError(err);
      assert(request.aborted);
    } catch (err2) {
      client.emit("error", err2);
    }
  };
  var assert = __require("assert");
  var net = __require("net");
  var http = __require("http");
  var { pipeline } = __require("stream");
  var util = require_util();
  var timers = require_timers();
  var Request = require_request();
  var DispatcherBase = require_dispatcher_base();
  var {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    InvalidArgumentError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError,
    ClientDestroyedError
  } = require_errors();
  var buildConnector = require_connect();
  var {
    kUrl,
    kReset,
    kServerName,
    kClient,
    kBusy,
    kParser,
    kConnect,
    kBlocking,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRedirections,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kInterceptors,
    kLocalAddress,
    kMaxResponseSize,
    kHTTPConnVersion,
    kHost,
    kHTTP2Session,
    kHTTP2SessionState,
    kHTTP2BuildRequest,
    kHTTP2CopyHeaders,
    kHTTP1BuildRequest
  } = require_symbols();
  var http2;
  try {
    http2 = __require("http2");
  } catch {
    http2 = { constants: {} };
  }
  var {
    constants: {
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS
    }
  } = http2;
  var h2ExperimentalWarned = false;
  var FastBuffer = Buffer[Symbol.species];
  var kClosedResolve = Symbol("kClosedResolve");
  var channels = {};
  try {
    const diagnosticsChannel = __require("diagnostics_channel");
    channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
    channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
    channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
    channels.connected = diagnosticsChannel.channel("undici:client:connected");
  } catch {
    channels.sendHeaders = { hasSubscribers: false };
    channels.beforeConnect = { hasSubscribers: false };
    channels.connectError = { hasSubscribers: false };
    channels.connected = { hasSubscribers: false };
  }

  class Client2 extends DispatcherBase {
    constructor(url, {
      interceptors,
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      maxRedirections,
      connect: connect2,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      maxConcurrentStreams
    } = {}) {
      super();
      if (keepAlive !== undefined) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
        throw new InvalidArgumentError("invalid maxHeaderSize");
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
        throw new InvalidArgumentError("invalid connectTimeout");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      }
      if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      }
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      }
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      }
      if (allowH2 != null && typeof allowH2 !== "boolean") {
        throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      }
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
        throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
      }
      if (typeof connect2 !== "function") {
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect2
        });
      }
      this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
      this[kUrl] = util.parseOrigin(url);
      this[kConnector] = connect2;
      this[kSocket] = null;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4000 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600000 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1000 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kServerName] = null;
      this[kLocalAddress] = localAddress != null ? localAddress : null;
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r\n`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300000;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300000;
      this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
      this[kMaxRedirections] = maxRedirections;
      this[kMaxRequests] = maxRequestsPerClient;
      this[kClosedResolve] = null;
      this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
      this[kHTTPConnVersion] = "h1";
      this[kHTTP2Session] = null;
      this[kHTTP2SessionState] = !allowH2 ? null : {
        openStreams: 0,
        maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
      };
      this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      resume(this, true);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
    }
    get [kBusy]() {
      const socket = this[kSocket];
      return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
    }
    [kConnect](cb) {
      connect(this);
      this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      const origin = opts.origin || this[kUrl].origin;
      const request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
      this[kQueue].push(request);
      if (this[kResuming]) {
      } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
        this[kResuming] = 1;
        process.nextTick(resume, this);
      } else {
        resume(this, true);
      }
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
        this[kNeedDrain] = 2;
      }
      return this[kNeedDrain] < 2;
    }
    async[kClose]() {
      return new Promise((resolve) => {
        if (!this[kSize]) {
          resolve(null);
        } else {
          this[kClosedResolve] = resolve;
        }
      });
    }
    async[kDestroy](err) {
      return new Promise((resolve) => {
        const requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i = 0;i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
        const callback = () => {
          if (this[kClosedResolve]) {
            this[kClosedResolve]();
            this[kClosedResolve] = null;
          }
          resolve();
        };
        if (this[kHTTP2Session] != null) {
          util.destroy(this[kHTTP2Session], err);
          this[kHTTP2Session] = null;
          this[kHTTP2SessionState] = null;
        }
        if (!this[kSocket]) {
          queueMicrotask(callback);
        } else {
          util.destroy(this[kSocket].on("close", callback), err);
        }
        resume(this);
      });
    }
  }
  var constants = require_constants2();
  var createRedirectInterceptor = require_redirectInterceptor();
  var EMPTY_BUF = Buffer.alloc(0);
  var llhttpInstance = null;
  var llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  var currentParser = null;
  var currentBufferRef = null;
  var currentBufferSize = 0;
  var currentBufferPtr = null;
  var TIMEOUT_HEADERS = 1;
  var TIMEOUT_BODY = 2;
  var TIMEOUT_IDLE = 3;

  class Parser {
    constructor(client, socket, { exports: exports2 }) {
      assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
      this.llhttp = exports2;
      this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
      this.client = client;
      this.socket = socket;
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.statusCode = null;
      this.statusText = "";
      this.upgrade = false;
      this.headers = [];
      this.headersSize = 0;
      this.headersMaxSize = client[kMaxHeadersSize];
      this.shouldKeepAlive = false;
      this.paused = false;
      this.resume = this.resume.bind(this);
      this.bytesRead = 0;
      this.keepAlive = "";
      this.contentLength = "";
      this.connection = "";
      this.maxResponseSize = client[kMaxResponseSize];
    }
    setTimeout(value, type) {
      this.timeoutType = type;
      if (value !== this.timeoutValue) {
        timers.clearTimeout(this.timeout);
        if (value) {
          this.timeout = timers.setTimeout(onParserTimeout, value, this);
          if (this.timeout.unref) {
            this.timeout.unref();
          }
        } else {
          this.timeout = null;
        }
        this.timeoutValue = value;
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
    }
    resume() {
      if (this.socket.destroyed || !this.paused) {
        return;
      }
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_resume(this.ptr);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.paused = false;
      this.execute(this.socket.read() || EMPTY_BUF);
      this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        const chunk = this.socket.read();
        if (chunk === null) {
          break;
        }
        this.execute(chunk);
      }
    }
    execute(data) {
      assert(this.ptr != null);
      assert(currentParser == null);
      assert(!this.paused);
      const { socket, llhttp } = this;
      if (data.length > currentBufferSize) {
        if (currentBufferPtr) {
          llhttp.free(currentBufferPtr);
        }
        currentBufferSize = Math.ceil(data.length / 4096) * 4096;
        currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
      try {
        let ret;
        try {
          currentBufferRef = data;
          currentParser = this;
          ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
        } catch (err) {
          throw err;
        } finally {
          currentParser = null;
          currentBufferRef = null;
        }
        const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (ret === constants.ERROR.PAUSED_UPGRADE) {
          this.onUpgrade(data.slice(offset));
        } else if (ret === constants.ERROR.PAUSED) {
          this.paused = true;
          socket.unshift(data.slice(offset));
        } else if (ret !== constants.ERROR.OK) {
          const ptr = llhttp.llhttp_get_error_reason(this.ptr);
          let message = "";
          if (ptr) {
            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
            message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
          }
          throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
        }
      } catch (err) {
        util.destroy(socket, err);
      }
    }
    destroy() {
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_free(this.ptr);
      this.ptr = null;
      timers.clearTimeout(this.timeout);
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.paused = false;
    }
    onStatus(buf) {
      this.statusText = buf.toString();
    }
    onMessageBegin() {
      const { socket, client } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
    }
    onHeaderField(buf) {
      const len = this.headers.length;
      if ((len & 1) === 0) {
        this.headers.push(buf);
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      this.trackHeader(buf.length);
    }
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1) {
        this.headers.push(buf);
        len += 1;
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      const key = this.headers[len - 2];
      if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
        this.keepAlive += buf.toString();
      } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
        this.connection += buf.toString();
      } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
        this.contentLength += buf.toString();
      }
      this.trackHeader(buf.length);
    }
    trackHeader(len) {
      this.headersSize += len;
      if (this.headersSize >= this.headersMaxSize) {
        util.destroy(this.socket, new HeadersOverflowError);
      }
    }
    onUpgrade(head) {
      const { upgrade, client, socket, headers, statusCode } = this;
      assert(upgrade);
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(!socket.destroyed);
      assert(socket === client[kSocket]);
      assert(!this.paused);
      assert(request.upgrade || request.method === "CONNECT");
      this.statusCode = null;
      this.statusText = "";
      this.shouldKeepAlive = null;
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      socket.unshift(head);
      socket[kParser].destroy();
      socket[kParser] = null;
      socket[kClient] = null;
      socket[kError] = null;
      socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
      client[kSocket] = null;
      client[kQueue][client[kRunningIdx]++] = null;
      client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
      try {
        request.onUpgrade(statusCode, headers, socket);
      } catch (err) {
        util.destroy(socket, err);
      }
      resume(client);
    }
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      const { client, socket, headers, statusText } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
        return -1;
      }
      if (upgrade && !request.upgrade) {
        util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
        return -1;
      }
      assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive || request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
      if (this.statusCode >= 200) {
        const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      if (request.method === "CONNECT") {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      if (upgrade) {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (this.shouldKeepAlive && client[kPipelining]) {
        const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      let pause;
      try {
        pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
      } catch (err) {
        util.destroy(socket, err);
        return -1;
      }
      if (request.method === "HEAD") {
        return 1;
      }
      if (statusCode < 200) {
        return 1;
      }
      if (socket[kBlocking]) {
        socket[kBlocking] = false;
        resume(client);
      }
      return pause ? constants.ERROR.PAUSED : 0;
    }
    onBody(buf) {
      const { client, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      assert(statusCode >= 200);
      if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
        util.destroy(socket, new ResponseExceededMaxSizeError);
        return -1;
      }
      this.bytesRead += buf.length;
      try {
        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
      } catch (err) {
        util.destroy(socket, err);
        return -1;
      }
    }
    onMessageComplete() {
      const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
        return -1;
      }
      if (upgrade) {
        return;
      }
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(statusCode >= 100);
      this.statusCode = null;
      this.statusText = "";
      this.bytesRead = 0;
      this.contentLength = "";
      this.keepAlive = "";
      this.connection = "";
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (statusCode < 200) {
        return;
      }
      if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
        util.destroy(socket, new ResponseContentLengthMismatchError);
        return -1;
      }
      try {
        request.onComplete(headers);
      } catch (err) {
        errorRequest(client, request, err);
      }
      client[kQueue][client[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        assert.strictEqual(client[kRunning], 0);
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (!shouldKeepAlive) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (socket[kReset] && client[kRunning] === 0) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (client[kPipelining] === 1) {
        setImmediate(resume, client);
      } else {
        resume(client);
      }
    }
  }

  class AsyncWriter {
    constructor({ socket, request, contentLength, client, expectsPayload, header }) {
      this.socket = socket;
      this.request = request;
      this.contentLength = contentLength;
      this.client = client;
      this.bytesWritten = 0;
      this.expectsPayload = expectsPayload;
      this.header = header;
      socket[kWriting] = true;
    }
    write(chunk) {
      const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return false;
      }
      const len = Buffer.byteLength(chunk);
      if (!len) {
        return true;
      }
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        }
        process.emitWarning(new RequestContentLengthMismatchError);
      }
      socket.cork();
      if (bytesWritten === 0) {
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        if (contentLength === null) {
          socket.write(`${header}transfer-encoding: chunked\r\n`, "latin1");
        } else {
          socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
        }
      }
      if (contentLength === null) {
        socket.write(`\r\n${len.toString(16)}\r\n`, "latin1");
      }
      this.bytesWritten += len;
      const ret = socket.write(chunk);
      socket.uncork();
      request.onBodySent(chunk);
      if (!ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
      }
      return ret;
    }
    end() {
      const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
      request.onRequestSent();
      socket[kWriting] = false;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return;
      }
      if (bytesWritten === 0) {
        if (expectsPayload) {
          socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
        } else {
          socket.write(`${header}\r\n`, "latin1");
        }
      } else if (contentLength === null) {
        socket.write("\r\n0\r\n\r\n", "latin1");
      }
      if (contentLength !== null && bytesWritten !== contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        } else {
          process.emitWarning(new RequestContentLengthMismatchError);
        }
      }
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh();
        }
      }
      resume(client);
    }
    destroy(err) {
      const { socket, client } = this;
      socket[kWriting] = false;
      if (err) {
        assert(client[kRunning] <= 1, "pipeline should only contain this request");
        util.destroy(socket, err);
      }
    }
  }
  module.exports = Client2;
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS((exports, module) => {
  var kSize = 2048;
  var kMask = kSize - 1;

  class FixedCircularBuffer {
    constructor() {
      this.bottom = 0;
      this.top = 0;
      this.list = new Array(kSize);
      this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === undefined)
        return null;
      this.list[this.bottom] = undefined;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  }
  module.exports = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer;
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
      }
      return next;
    }
  };
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS((exports, module) => {
  var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
  var kPool = Symbol("pool");

  class PoolStats {
    constructor(pool) {
      this[kPool] = pool;
    }
    get connected() {
      return this[kPool][kConnected];
    }
    get free() {
      return this[kPool][kFree];
    }
    get pending() {
      return this[kPool][kPending];
    }
    get queued() {
      return this[kPool][kQueued];
    }
    get running() {
      return this[kPool][kRunning];
    }
    get size() {
      return this[kPool][kSize];
    }
  }
  module.exports = PoolStats;
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS((exports, module) => {
  var DispatcherBase = require_dispatcher_base();
  var FixedQueue = require_fixed_queue();
  var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
  var PoolStats = require_pool_stats();
  var kClients = Symbol("clients");
  var kNeedDrain = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kClosedResolve = Symbol("closed resolve");
  var kOnDrain = Symbol("onDrain");
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kGetDispatcher = Symbol("get dispatcher");
  var kAddClient = Symbol("add client");
  var kRemoveClient = Symbol("remove client");
  var kStats = Symbol("stats");

  class PoolBase extends DispatcherBase {
    constructor() {
      super();
      this[kQueue] = new FixedQueue;
      this[kClients] = [];
      this[kQueued] = 0;
      const pool = this;
      this[kOnDrain] = function onDrain(origin, targets) {
        const queue = pool[kQueue];
        let needDrain = false;
        while (!needDrain) {
          const item = queue.shift();
          if (!item) {
            break;
          }
          pool[kQueued]--;
          needDrain = !this.dispatch(item.opts, item.handler);
        }
        this[kNeedDrain] = needDrain;
        if (!this[kNeedDrain] && pool[kNeedDrain]) {
          pool[kNeedDrain] = false;
          pool.emit("drain", origin, [pool, ...targets]);
        }
        if (pool[kClosedResolve] && queue.isEmpty()) {
          Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
        }
      };
      this[kOnConnect] = (origin, targets) => {
        pool.emit("connect", origin, [pool, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        pool.emit("disconnect", origin, [pool, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        pool.emit("connectionError", origin, [pool, ...targets], err);
      };
      this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      return this[kClients].filter((client) => client[kConnected]).length;
    }
    get [kFree]() {
      return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (const { [kPending]: pending } of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (const { [kRunning]: running } of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (const { [kSize]: size } of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get stats() {
      return this[kStats];
    }
    async[kClose]() {
      if (this[kQueue].isEmpty()) {
        return Promise.all(this[kClients].map((c) => c.close()));
      } else {
        return new Promise((resolve) => {
          this[kClosedResolve] = resolve;
        });
      }
    }
    async[kDestroy](err) {
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      return Promise.all(this[kClients].map((c) => c.destroy(err)));
    }
    [kDispatch](opts, handler) {
      const dispatcher = this[kGetDispatcher]();
      if (!dispatcher) {
        this[kNeedDrain] = true;
        this[kQueue].push({ opts, handler });
        this[kQueued]++;
      } else if (!dispatcher.dispatch(opts, handler)) {
        dispatcher[kNeedDrain] = true;
        this[kNeedDrain] = !this[kGetDispatcher]();
      }
      return !this[kNeedDrain];
    }
    [kAddClient](client) {
      client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
      this[kClients].push(client);
      if (this[kNeedDrain]) {
        process.nextTick(() => {
          if (this[kNeedDrain]) {
            this[kOnDrain](client[kUrl], [this, client]);
          }
        });
      }
      return this;
    }
    [kRemoveClient](client) {
      client.close(() => {
        const idx = this[kClients].indexOf(client);
        if (idx !== -1) {
          this[kClients].splice(idx, 1);
        }
      });
      this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
    }
  }
  module.exports = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS((exports, module) => {
  var defaultFactory = function(origin, opts) {
    return new Client2(origin, opts);
  };
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher
  } = require_pool_base();
  var Client2 = require_client();
  var {
    InvalidArgumentError
  } = require_errors();
  var util = require_util();
  var { kUrl, kInterceptors } = require_symbols();
  var buildConnector = require_connect();
  var kOptions = Symbol("options");
  var kConnections = Symbol("connections");
  var kFactory = Symbol("factory");

  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      ...options
    } = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect !== "function") {
        connect = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect
        });
      }
      this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
      this[kConnections] = connections || null;
      this[kUrl] = util.parseOrigin(origin);
      this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kFactory] = factory;
    }
    [kGetDispatcher]() {
      let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
      if (dispatcher) {
        return dispatcher;
      }
      if (!this[kConnections] || this[kClients].length < this[kConnections]) {
        dispatcher = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher);
      }
      return dispatcher;
    }
  }
  module.exports = Pool;
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS((exports, module) => {
  var getGreatestCommonDivisor = function(a, b) {
    if (b === 0)
      return a;
    return getGreatestCommonDivisor(b, a % b);
  };
  var defaultFactory = function(origin, opts) {
    return new Pool(origin, opts);
  };
  var {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = require_errors();
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = require_pool_base();
  var Pool = require_pool();
  var { kUrl, kInterceptors } = require_symbols();
  var { parseOrigin } = require_util();
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
  var kCurrentWeight = Symbol("kCurrentWeight");
  var kIndex = Symbol("kIndex");
  var kWeight = Symbol("kWeight");
  var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
  var kErrorPenalty = Symbol("kErrorPenalty");

  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      super();
      this[kOptions] = opts;
      this[kIndex] = -1;
      this[kCurrentWeight] = 0;
      this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
      this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
      if (!Array.isArray(upstreams)) {
        upstreams = [upstreams];
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
      this[kFactory] = factory;
      for (const upstream of upstreams) {
        this.addUpstream(upstream);
      }
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
        return this;
      }
      const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool);
      pool.on("connect", () => {
        pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
      });
      pool.on("connectionError", () => {
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
        this._updateBalancedPoolStats();
      });
      pool.on("disconnect", (...args) => {
        const err = args[2];
        if (err && err.code === "UND_ERR_SOCKET") {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        }
      });
      for (const client of this[kClients]) {
        client[kWeight] = this[kMaxWeightPerServer];
      }
      this._updateBalancedPoolStats();
      return this;
    }
    _updateBalancedPoolStats() {
      this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
    }
    removeUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
      if (pool) {
        this[kRemoveClient](pool);
      }
      return this;
    }
    get upstreams() {
      return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0) {
        throw new BalancedPoolMissingUpstreamError;
      }
      const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
      if (!dispatcher) {
        return;
      }
      const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
      if (allClientsBusy) {
        return;
      }
      let counter = 0;
      let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        const pool = this[kClients][this[kIndex]];
        if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
          maxWeightIndex = this[kIndex];
        }
        if (this[kIndex] === 0) {
          this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
          if (this[kCurrentWeight] <= 0) {
            this[kCurrentWeight] = this[kMaxWeightPerServer];
          }
        }
        if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
          return pool;
        }
      }
      this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
      this[kIndex] = maxWeightIndex;
      return this[kClients][maxWeightIndex];
    }
  }
  module.exports = BalancedPool;
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS((exports, module) => {
  var { kConnected, kSize } = require_symbols();

  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected] === 0 && this.value[kSize] === 0 ? undefined : this.value;
    }
  }

  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher, key) {
      if (dispatcher.on) {
        dispatcher.on("disconnect", () => {
          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
            this.finalizer(key);
          }
        });
      }
    }
  }
  module.exports = function() {
    if (process.env.NODE_V8_COVERAGE) {
      return {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      };
    }
    return {
      WeakRef: global.WeakRef || CompatWeakRef,
      FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
    };
  };
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS((exports, module) => {
  var defaultFactory = function(origin, opts) {
    return opts && opts.connections === 1 ? new Client2(origin, opts) : new Pool(origin, opts);
  };
  var { InvalidArgumentError } = require_errors();
  var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
  var DispatcherBase = require_dispatcher_base();
  var Pool = require_pool();
  var Client2 = require_client();
  var util = require_util();
  var createRedirectInterceptor = require_redirectInterceptor();
  var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kMaxRedirections = Symbol("maxRedirections");
  var kOnDrain = Symbol("onDrain");
  var kFactory = Symbol("factory");
  var kFinalizer = Symbol("finalizer");
  var kOptions = Symbol("options");

  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
      super();
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (connect && typeof connect !== "function") {
        connect = { ...connect };
      }
      this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
      this[kOptions] = { ...util.deepClone(options), connect };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kMaxRedirections] = maxRedirections;
      this[kFactory] = factory;
      this[kClients] = new Map;
      this[kFinalizer] = new FinalizationRegistry((key) => {
        const ref = this[kClients].get(key);
        if (ref !== undefined && ref.deref() === undefined) {
          this[kClients].delete(key);
        }
      });
      const agent = this;
      this[kOnDrain] = (origin, targets) => {
        agent.emit("drain", origin, [agent, ...targets]);
      };
      this[kOnConnect] = (origin, targets) => {
        agent.emit("connect", origin, [agent, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        agent.emit("disconnect", origin, [agent, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        agent.emit("connectionError", origin, [agent, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          ret += client[kRunning];
        }
      }
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
        key = String(opts.origin);
      } else {
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      }
      const ref = this[kClients].get(key);
      let dispatcher = ref ? ref.deref() : null;
      if (!dispatcher) {
        dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].set(key, new WeakRef2(dispatcher));
        this[kFinalizer].register(dispatcher, key);
      }
      return dispatcher.dispatch(opts, handler);
    }
    async[kClose]() {
      const closePromises = [];
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          closePromises.push(client.close());
        }
      }
      await Promise.all(closePromises);
    }
    async[kDestroy](err) {
      const destroyPromises = [];
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          destroyPromises.push(client.destroy(err));
        }
      }
      await Promise.all(destroyPromises);
    }
  }
  module.exports = Agent;
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS((exports, module) => {
  var isLocked = function(self2) {
    return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
  };
  var isUnusable = function(self2) {
    return util.isDisturbed(self2) || isLocked(self2);
  };
  async function consume(stream, type) {
    if (isUnusable(stream)) {
      throw new TypeError("unusable");
    }
    assert(!stream[kConsume]);
    return new Promise((resolve, reject) => {
      stream[kConsume] = {
        type,
        stream,
        resolve,
        reject,
        length: 0,
        body: []
      };
      stream.on("error", function(err) {
        consumeFinish(this[kConsume], err);
      }).on("close", function() {
        if (this[kConsume].body !== null) {
          consumeFinish(this[kConsume], new RequestAbortedError);
        }
      });
      process.nextTick(consumeStart, stream[kConsume]);
    });
  }
  var consumeStart = function(consume2) {
    if (consume2.body === null) {
      return;
    }
    const { _readableState: state } = consume2.stream;
    for (const chunk of state.buffer) {
      consumePush(consume2, chunk);
    }
    if (state.endEmitted) {
      consumeEnd(this[kConsume]);
    } else {
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume]);
      });
    }
    consume2.stream.resume();
    while (consume2.stream.read() != null) {
    }
  };
  var consumeEnd = function(consume2) {
    const { type, body, resolve, stream, length } = consume2;
    try {
      if (type === "text") {
        resolve(toUSVString(Buffer.concat(body)));
      } else if (type === "json") {
        resolve(JSON.parse(Buffer.concat(body)));
      } else if (type === "arrayBuffer") {
        const dst = new Uint8Array(length);
        let pos = 0;
        for (const buf of body) {
          dst.set(buf, pos);
          pos += buf.byteLength;
        }
        resolve(dst.buffer);
      } else if (type === "blob") {
        if (!Blob2) {
          Blob2 = __require("buffer").Blob;
        }
        resolve(new Blob2(body, { type: stream[kContentType] }));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream.destroy(err);
    }
  };
  var consumePush = function(consume2, chunk) {
    consume2.length += chunk.length;
    consume2.body.push(chunk);
  };
  var consumeFinish = function(consume2, err) {
    if (consume2.body === null) {
      return;
    }
    if (err) {
      consume2.reject(err);
    } else {
      consume2.resolve();
    }
    consume2.type = null;
    consume2.stream = null;
    consume2.resolve = null;
    consume2.reject = null;
    consume2.length = 0;
    consume2.body = null;
  };
  var assert = __require("assert");
  var { Readable } = __require("stream");
  var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
  var util = require_util();
  var { ReadableStreamFrom, toUSVString } = require_util();
  var Blob2;
  var kConsume = Symbol("kConsume");
  var kReading = Symbol("kReading");
  var kBody = Symbol("kBody");
  var kAbort = Symbol("abort");
  var kContentType = Symbol("kContentType");
  module.exports = class BodyReadable extends Readable {
    constructor({
      resume,
      abort,
      contentType = "",
      highWaterMark = 64 * 1024
    }) {
      super({
        autoDestroy: true,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = false;
      this[kAbort] = abort;
      this[kConsume] = null;
      this[kBody] = null;
      this[kContentType] = contentType;
      this[kReading] = false;
    }
    destroy(err) {
      if (this.destroyed) {
        return this;
      }
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      if (err) {
        this[kAbort]();
      }
      return super.destroy(err);
    }
    emit(ev, ...args) {
      if (ev === "data") {
        this._readableState.dataEmitted = true;
      } else if (ev === "error") {
        this._readableState.errorEmitted = true;
      }
      return super.emit(ev, ...args);
    }
    on(ev, ...args) {
      if (ev === "data" || ev === "readable") {
        this[kReading] = true;
      }
      return super.on(ev, ...args);
    }
    addListener(ev, ...args) {
      return this.on(ev, ...args);
    }
    off(ev, ...args) {
      const ret = super.off(ev, ...args);
      if (ev === "data" || ev === "readable") {
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      }
      return ret;
    }
    removeListener(ev, ...args) {
      return this.off(ev, ...args);
    }
    push(chunk) {
      if (this[kConsume] && chunk !== null && this.readableLength === 0) {
        consumePush(this[kConsume], chunk);
        return this[kReading] ? super.push(chunk) : true;
      }
      return super.push(chunk);
    }
    async text() {
      return consume(this, "text");
    }
    async json() {
      return consume(this, "json");
    }
    async blob() {
      return consume(this, "blob");
    }
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    async formData() {
      throw new NotSupportedError;
    }
    get bodyUsed() {
      return util.isDisturbed(this);
    }
    get body() {
      if (!this[kBody]) {
        this[kBody] = ReadableStreamFrom(this);
        if (this[kConsume]) {
          this[kBody].getReader();
          assert(this[kBody].locked);
        }
      }
      return this[kBody];
    }
    async dump(opts) {
      let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
      const signal = opts && opts.signal;
      const abortFn = () => {
        this.destroy();
      };
      let signalListenerCleanup;
      if (signal) {
        if (typeof signal !== "object" || !("aborted" in signal)) {
          throw new InvalidArgumentError("signal must be an AbortSignal");
        }
        util.throwIfAborted(signal);
        signalListenerCleanup = util.addAbortListener(signal, abortFn);
      }
      try {
        for await (const chunk of this) {
          util.throwIfAborted(signal);
          limit -= Buffer.byteLength(chunk);
          if (limit < 0) {
            return;
          }
        }
      } catch {
        util.throwIfAborted(signal);
      } finally {
        if (typeof signalListenerCleanup === "function") {
          signalListenerCleanup();
        } else if (signalListenerCleanup) {
          signalListenerCleanup[Symbol.dispose]();
        }
      }
    }
  };
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS((exports, module) => {
  async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
    assert(body);
    let chunks = [];
    let limit = 0;
    for await (const chunk of body) {
      chunks.push(chunk);
      limit += chunk.length;
      if (limit > 128 * 1024) {
        chunks = null;
        break;
      }
    }
    if (statusCode === 204 || !contentType || !chunks) {
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
      return;
    }
    try {
      if (contentType.startsWith("application/json")) {
        const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
      if (contentType.startsWith("text/")) {
        const payload = toUSVString(Buffer.concat(chunks));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
    } catch (err) {
    }
    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
  }
  var assert = __require("assert");
  var {
    ResponseStatusCodeError
  } = require_errors();
  var { toUSVString } = require_util();
  module.exports = { getResolveErrorBodyCallback };
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS((exports, module) => {
  var abort = function(self2) {
    if (self2.abort) {
      self2.abort();
    } else {
      self2.onError(new RequestAbortedError);
    }
  };
  var addSignal = function(self2, signal) {
    self2[kSignal] = null;
    self2[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal;
    self2[kListener] = () => {
      abort(self2);
    };
    addAbortListener(self2[kSignal], self2[kListener]);
  };
  var removeSignal = function(self2) {
    if (!self2[kSignal]) {
      return;
    }
    if ("removeEventListener" in self2[kSignal]) {
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].removeListener("abort", self2[kListener]);
    }
    self2[kSignal] = null;
    self2[kListener] = null;
  };
  var { addAbortListener } = require_util();
  var { RequestAbortedError } = require_errors();
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  module.exports = {
    addSignal,
    removeSignal
  };
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS((exports, module) => {
  var request = function(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        request.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  };
  var Readable = require_readable();
  var {
    InvalidArgumentError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();

  class RequestHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
          throw new InvalidArgumentError("invalid highWaterMark");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body;
      this.trailers = {};
      this.context = null;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError;
      this.highWaterMark = highWaterMark;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
      const contentType = parsedHeaders["content-type"];
      const body = new Readable({ resume, abort, contentType, highWaterMark });
      this.callback = null;
      this.res = body;
      if (callback !== null) {
        if (this.throwOnError && statusCode >= 400) {
          this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body, contentType, statusCode, statusMessage, headers });
        } else {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body,
            context
          });
        }
      }
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      util.parseHeaders(trailers, this.trailers);
      res.push(null);
    }
    onError(err) {
      const { res, callback, body, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (res) {
        this.res = null;
        queueMicrotask(() => {
          util.destroy(res, err);
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  }
  module.exports = request;
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS((exports, module) => {
  var stream = function(opts, factory, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  };
  var { finished, PassThrough } = __require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();

  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.context = null;
      this.trailers = null;
      this.body = body;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError || false;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { factory, opaque, context, callback, responseHeaders } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.factory = null;
      let res;
      if (this.throwOnError && statusCode >= 400) {
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        res = new PassThrough;
        this.callback = null;
        this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body: res, contentType, statusCode, statusMessage, headers });
      } else {
        if (factory === null) {
          return;
        }
        res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        finished(res, { readable: false }, (err) => {
          const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
      }
      res.on("drain", resume);
      this.res = res;
      const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const { res } = this;
      return res ? res.write(chunk) : true;
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      if (!res) {
        return;
      }
      this.trailers = util.parseHeaders(trailers);
      res.end();
    }
    onError(err) {
      const { res, callback, opaque, body } = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  }
  module.exports = stream;
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS((exports, module) => {
  var pipeline = function(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  };
  var {
    Readable,
    Duplex,
    PassThrough
  } = __require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("assert");
  var kResume = Symbol("resume");

  class PipelineRequest extends Readable {
    constructor() {
      super({ autoDestroy: true });
      this[kResume] = null;
    }
    _read() {
      const { [kResume]: resume } = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      callback(err);
    }
  }

  class PipelineResponse extends Readable {
    constructor(resume) {
      super({ autoDestroy: true });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      callback(err);
    }
  }

  class PipelineHandler extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const { signal, method, opaque, onInfo, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError("invalid onInfo callback");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.handler = handler;
      this.abort = null;
      this.context = null;
      this.onInfo = onInfo || null;
      this.req = new PipelineRequest().on("error", util.nop);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const { body } = this;
          if (body && body.resume) {
            body.resume();
          }
        },
        write: (chunk, encoding, callback) => {
          const { req } = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const { body, req, res, ret, abort } = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError;
          }
          if (abort && err) {
            abort();
          }
          util.destroy(body, err);
          util.destroy(req, err);
          util.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const { req } = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      const { ret, res } = this;
      assert(!res, "pipeline cannot be retried");
      if (ret.destroyed) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      const { opaque, handler, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        this.res.on("error", util.nop);
        throw err;
      }
      if (!body || typeof body.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body.on("data", (chunk) => {
        const { ret, body: body2 } = this;
        if (!ret.push(chunk) && body2.pause) {
          body2.pause();
        }
      }).on("error", (err) => {
        const { ret } = this;
        util.destroy(ret, err);
      }).on("end", () => {
        const { ret } = this;
        ret.push(null);
      }).on("close", () => {
        const { ret } = this;
        if (!ret._readableState.ended) {
          util.destroy(ret, new RequestAbortedError);
        }
      });
      this.body = body;
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      res.push(null);
    }
    onError(err) {
      const { ret } = this;
      this.handler = null;
      util.destroy(ret, err);
    }
  }
  module.exports = pipeline;
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS((exports, module) => {
  var upgrade = function(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  };
  var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
  var { AsyncResource } = __require("async_hooks");
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("assert");

  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      this.context = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      assert.strictEqual(statusCode, 101);
      removeSignal(this);
      this.callback = null;
      const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  module.exports = upgrade;
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS((exports, module) => {
  var connect = function(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  };
  var { AsyncResource } = __require("async_hooks");
  var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();

  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      let headers = rawHeaders;
      if (headers != null) {
        headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      }
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  module.exports = connect;
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS((exports, module) => {
  exports.request = require_api_request();
  exports.stream = require_api_stream();
  exports.pipeline = require_api_pipeline();
  exports.upgrade = require_api_upgrade();
  exports.connect = require_api_connect();
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS((exports, module) => {
  var { UndiciError } = require_errors();

  class MockNotMatchedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, MockNotMatchedError);
      this.name = "MockNotMatchedError";
      this.message = message || "The request does not match any registered mock dispatches";
      this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }
  module.exports = {
    MockNotMatchedError
  };
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS((exports, module) => {
  module.exports = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected")
  };
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS((exports, module) => {
  var matchValue = function(match, value) {
    if (typeof match === "string") {
      return match === value;
    }
    if (match instanceof RegExp) {
      return match.test(value);
    }
    if (typeof match === "function") {
      return match(value) === true;
    }
    return false;
  };
  var lowerCaseEntries = function(headers) {
    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue];
    }));
  };
  var getHeaderByName = function(headers, key) {
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
          return headers[i + 1];
        }
      }
      return;
    } else if (typeof headers.get === "function") {
      return headers.get(key);
    } else {
      return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
    }
  };
  var buildHeadersFromArray = function(headers) {
    const clone = headers.slice();
    const entries = [];
    for (let index = 0;index < clone.length; index += 2) {
      entries.push([clone[index], clone[index + 1]]);
    }
    return Object.fromEntries(entries);
  };
  var matchHeaders = function(mockDispatch2, headers) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers)) {
        headers = buildHeadersFromArray(headers);
      }
      return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
    }
    if (typeof mockDispatch2.headers === "undefined") {
      return true;
    }
    if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
      return false;
    }
    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      const headerValue = getHeaderByName(headers, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue)) {
        return false;
      }
    }
    return true;
  };
  var safeUrl = function(path) {
    if (typeof path !== "string") {
      return path;
    }
    const pathSegments = path.split("?");
    if (pathSegments.length !== 2) {
      return path;
    }
    const qp = new URLSearchParams(pathSegments.pop());
    qp.sort();
    return [...pathSegments, qp.toString()].join("?");
  };
  var matchKey = function(mockDispatch2, { path, method, body, headers }) {
    const pathMatch = matchValue(mockDispatch2.path, path);
    const methodMatch = matchValue(mockDispatch2.method, method);
    const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
    const headersMatch = matchHeaders(mockDispatch2, headers);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  };
  var getResponseData = function(data) {
    if (Buffer.isBuffer(data)) {
      return data;
    } else if (typeof data === "object") {
      return JSON.stringify(data);
    } else {
      return data.toString();
    }
  };
  var getMockDispatch = function(mockDispatches, key) {
    const basePath = key.query ? buildURL(key.path, key.query) : key.path;
    const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
    let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
    }
    return matchedMockDispatches[0];
  };
  var addMockDispatch = function(mockDispatches, key, data) {
    const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
    const replyData = typeof data === "function" ? { callback: data } : { ...data };
    const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
    mockDispatches.push(newMockDispatch);
    return newMockDispatch;
  };
  var deleteMockDispatch = function(mockDispatches, key) {
    const index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed) {
        return false;
      }
      return matchKey(dispatch, key);
    });
    if (index !== -1) {
      mockDispatches.splice(index, 1);
    }
  };
  var buildKey = function(opts) {
    const { path, method, body, headers, query } = opts;
    return {
      path,
      method,
      body,
      headers,
      query
    };
  };
  var generateKeyValues = function(data) {
    return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
      ...keyValuePairs,
      Buffer.from(`${key}`),
      Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
    ], []);
  };
  var getStatusText = function(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  };
  async function getResponse(body) {
    const buffers = [];
    for await (const data of body) {
      buffers.push(data);
    }
    return Buffer.concat(buffers).toString("utf8");
  }
  var mockDispatch = function(opts, handler) {
    const key = buildKey(opts);
    const mockDispatch2 = getMockDispatch(this[kDispatches], key);
    mockDispatch2.timesInvoked++;
    if (mockDispatch2.data.callback) {
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    }
    const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
    const { timesInvoked, times } = mockDispatch2;
    mockDispatch2.consumed = !persist && timesInvoked >= times;
    mockDispatch2.pending = timesInvoked < times;
    if (error !== null) {
      deleteMockDispatch(this[kDispatches], key);
      handler.onError(error);
      return true;
    }
    if (typeof delay === "number" && delay > 0) {
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay);
    } else {
      handleReply(this[kDispatches]);
    }
    function handleReply(mockDispatches, _data = data) {
      const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
      const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
      if (isPromise(body)) {
        body.then((newData) => handleReply(mockDispatches, newData));
        return;
      }
      const responseData = getResponseData(body);
      const responseHeaders = generateKeyValues(headers);
      const responseTrailers = generateKeyValues(trailers);
      handler.abort = nop;
      handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
      handler.onData(Buffer.from(responseData));
      handler.onComplete(responseTrailers);
      deleteMockDispatch(mockDispatches, key);
    }
    function resume() {
    }
    return true;
  };
  var buildMockDispatch = function() {
    const agent = this[kMockAgent];
    const origin = this[kOrigin];
    const originalDispatch = this[kOriginalDispatch];
    return function dispatch(opts, handler) {
      if (agent.isMockActive) {
        try {
          mockDispatch.call(this, opts, handler);
        } catch (error) {
          if (error instanceof MockNotMatchedError) {
            const netConnect = agent[kGetNetConnect]();
            if (netConnect === false) {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            }
            if (checkNetConnect(netConnect, origin)) {
              originalDispatch.call(this, opts, handler);
            } else {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
            }
          } else {
            throw error;
          }
        }
      } else {
        originalDispatch.call(this, opts, handler);
      }
    };
  };
  var checkNetConnect = function(netConnect, origin) {
    const url = new URL(origin);
    if (netConnect === true) {
      return true;
    } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
      return true;
    }
    return false;
  };
  var buildMockOptions = function(opts) {
    if (opts) {
      const { agent, ...mockOptions } = opts;
      return mockOptions;
    }
  };
  var { MockNotMatchedError } = require_mock_errors();
  var {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = require_mock_symbols();
  var { buildURL, nop } = require_util();
  var { STATUS_CODES } = __require("http");
  var {
    types: {
      isPromise
    }
  } = __require("util");
  module.exports = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildMockOptions,
    getHeaderByName
  };
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS((exports, module) => {
  var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch
  } = require_mock_symbols();
  var { InvalidArgumentError } = require_errors();
  var { buildURL } = require_util();

  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      }
      this[kMockDispatch].delay = waitInMs;
      return this;
    }
    persist() {
      this[kMockDispatch].persist = true;
      return this;
    }
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      }
      this[kMockDispatch].times = repeatTimes;
      return this;
    }
  }

  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object") {
        throw new InvalidArgumentError("opts must be an object");
      }
      if (typeof opts.path === "undefined") {
        throw new InvalidArgumentError("opts.path must be defined");
      }
      if (typeof opts.method === "undefined") {
        opts.method = "GET";
      }
      if (typeof opts.path === "string") {
        if (opts.query) {
          opts.path = buildURL(opts.path, opts.query);
        } else {
          const parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      }
      if (typeof opts.method === "string") {
        opts.method = opts.method.toUpperCase();
      }
      this[kDispatchKey] = buildKey(opts);
      this[kDispatches] = mockDispatches;
      this[kDefaultHeaders] = {};
      this[kDefaultTrailers] = {};
      this[kContentLength] = false;
    }
    createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
      const responseData = getResponseData(data);
      const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
      const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
      const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data, headers, trailers };
    }
    validateReplyParameters(statusCode, data, responseOptions) {
      if (typeof statusCode === "undefined") {
        throw new InvalidArgumentError("statusCode must be defined");
      }
      if (typeof data === "undefined") {
        throw new InvalidArgumentError("data must be defined");
      }
      if (typeof responseOptions !== "object") {
        throw new InvalidArgumentError("responseOptions must be an object");
      }
    }
    reply(replyData) {
      if (typeof replyData === "function") {
        const wrappedDefaultsCallback = (opts) => {
          const resolvedData = replyData(opts);
          if (typeof resolvedData !== "object") {
            throw new InvalidArgumentError("reply options callback must return an object");
          }
          const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
          this.validateReplyParameters(statusCode2, data2, responseOptions2);
          return {
            ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
          };
        };
        const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
        return new MockScope(newMockDispatch2);
      }
      const [statusCode, data = "", responseOptions = {}] = [...arguments];
      this.validateReplyParameters(statusCode, data, responseOptions);
      const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
      return new MockScope(newMockDispatch);
    }
    replyWithError(error) {
      if (typeof error === "undefined") {
        throw new InvalidArgumentError("error must be defined");
      }
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
      return new MockScope(newMockDispatch);
    }
    defaultReplyHeaders(headers) {
      if (typeof headers === "undefined") {
        throw new InvalidArgumentError("headers must be defined");
      }
      this[kDefaultHeaders] = headers;
      return this;
    }
    defaultReplyTrailers(trailers) {
      if (typeof trailers === "undefined") {
        throw new InvalidArgumentError("trailers must be defined");
      }
      this[kDefaultTrailers] = trailers;
      return this;
    }
    replyContentLength() {
      this[kContentLength] = true;
      return this;
    }
  }
  exports.MockInterceptor = MockInterceptor;
  exports.MockScope = MockScope;
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS((exports, module) => {
  var { promisify } = __require("util");
  var Client2 = require_client();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockClient extends Client2 {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockClient;
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS((exports, module) => {
  var { promisify } = __require("util");
  var Pool = require_pool();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockPool extends Pool {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockPool;
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS((exports, module) => {
  var singulars = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  };
  var plurals = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  module.exports = class Pluralizer {
    constructor(singular, plural) {
      this.singular = singular;
      this.plural = plural;
    }
    pluralize(count) {
      const one = count === 1;
      const keys = one ? singulars : plurals;
      const noun = one ? this.singular : this.plural;
      return { ...keys, count, noun };
    }
  };
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS((exports, module) => {
  var { Transform } = __require("stream");
  var { Console } = __require("console");
  module.exports = class PendingInterceptorsFormatter {
    constructor({ disableColors } = {}) {
      this.transform = new Transform({
        transform(chunk, _enc, cb) {
          cb(null, chunk);
        }
      });
      this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path,
        "Status code": statusCode,
        Persistent: persist ? "\u2705" : "\u274C",
        Invocations: timesInvoked,
        Remaining: persist ? Infinity : times - timesInvoked
      }));
      this.logger.table(withPrettyHeaders);
      return this.transform.read().toString();
    }
  };
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS((exports, module) => {
  var { kClients } = require_symbols();
  var Agent = require_agent();
  var {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory
  } = require_mock_symbols();
  var MockClient = require_mock_client();
  var MockPool = require_mock_pool();
  var { matchValue, buildMockOptions } = require_mock_utils();
  var { InvalidArgumentError, UndiciError } = require_errors();
  var Dispatcher = require_dispatcher();
  var Pluralizer = require_pluralizer();
  var PendingInterceptorsFormatter = require_pending_interceptors_formatter();

  class FakeWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value;
    }
  }

  class MockAgent extends Dispatcher {
    constructor(opts) {
      super(opts);
      this[kNetConnect] = true;
      this[kIsMockActive] = true;
      if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      const agent = opts && opts.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent;
      this[kClients] = agent[kClients];
      this[kOptions] = buildMockOptions(opts);
    }
    get(origin) {
      let dispatcher = this[kMockAgentGet](origin);
      if (!dispatcher) {
        dispatcher = this[kFactory](origin);
        this[kMockAgentSet](origin, dispatcher);
      }
      return dispatcher;
    }
    dispatch(opts, handler) {
      this.get(opts.origin);
      return this[kAgent].dispatch(opts, handler);
    }
    async close() {
      await this[kAgent].close();
      this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = false;
    }
    activate() {
      this[kIsMockActive] = true;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
        if (Array.isArray(this[kNetConnect])) {
          this[kNetConnect].push(matcher);
        } else {
          this[kNetConnect] = [matcher];
        }
      } else if (typeof matcher === "undefined") {
        this[kNetConnect] = true;
      } else {
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
    }
    disableNetConnect() {
      this[kNetConnect] = false;
    }
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentSet](origin, dispatcher) {
      this[kClients].set(origin, new FakeWeakRef(dispatcher));
    }
    [kFactory](origin) {
      const mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      const ref = this[kClients].get(origin);
      if (ref) {
        return ref.deref();
      }
      if (typeof origin !== "string") {
        const dispatcher = this[kFactory]("http://localhost:9999");
        this[kMockAgentSet](origin, dispatcher);
        return dispatcher;
      }
      for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
        const nonExplicitDispatcher = nonExplicitRef.deref();
        if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          const dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
          dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
          return dispatcher;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      const mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter } = {}) {
      const pending = this.pendingInterceptors();
      if (pending.length === 0) {
        return;
      }
      const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
      throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
    }
  }
  module.exports = MockAgent;
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS((exports, module) => {
  var defaultProtocolPort = function(protocol) {
    return protocol === "https:" ? 443 : 80;
  };
  var buildProxyOptions = function(opts) {
    if (typeof opts === "string") {
      opts = { uri: opts };
    }
    if (!opts || !opts.uri) {
      throw new InvalidArgumentError("Proxy opts.uri is mandatory");
    }
    return {
      uri: opts.uri,
      protocol: opts.protocol || "https"
    };
  };
  var defaultFactory = function(origin, opts) {
    return new Pool(origin, opts);
  };
  var buildHeaders = function(headers) {
    if (Array.isArray(headers)) {
      const headersPair = {};
      for (let i = 0;i < headers.length; i += 2) {
        headersPair[headers[i]] = headers[i + 1];
      }
      return headersPair;
    }
    return headers;
  };
  var throwIfProxyAuthIsSent = function(headers) {
    const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
    if (existProxyAuth) {
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
    }
  };
  var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
  var { URL: URL2 } = __require("url");
  var Agent = require_agent();
  var Pool = require_pool();
  var DispatcherBase = require_dispatcher_base();
  var { InvalidArgumentError, RequestAbortedError } = require_errors();
  var buildConnector = require_connect();
  var kAgent = Symbol("proxy agent");
  var kClient = Symbol("proxy client");
  var kProxyHeaders = Symbol("proxy headers");
  var kRequestTls = Symbol("request tls settings");
  var kProxyTls = Symbol("proxy tls settings");
  var kConnectEndpoint = Symbol("connect endpoint function");

  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      super(opts);
      this[kProxy] = buildProxyOptions(opts);
      this[kAgent] = new Agent(opts);
      this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      const { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function") {
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      }
      this[kRequestTls] = opts.requestTls;
      this[kProxyTls] = opts.proxyTls;
      this[kProxyHeaders] = opts.headers || {};
      if (opts.auth && opts.token) {
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      } else if (opts.auth) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      } else if (opts.token) {
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      }
      const resolvedUrl = new URL2(opts.uri);
      const { origin, port, host } = resolvedUrl;
      const connect = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
      this[kClient] = clientFactory(resolvedUrl, { connect });
      this[kAgent] = new Agent({
        ...opts,
        connect: async (opts2, callback) => {
          let requestedHost = opts2.host;
          if (!opts2.port) {
            requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
          }
          try {
            const { socket, statusCode } = await this[kClient].connect({
              origin,
              port,
              path: requestedHost,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host
              }
            });
            if (statusCode !== 200) {
              socket.on("error", () => {
              }).destroy();
              callback(new RequestAbortedError("Proxy response !== 200 when HTTP Tunneling"));
            }
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls]) {
              servername = this[kRequestTls].servername;
            } else {
              servername = opts2.servername;
            }
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            callback(err);
          }
        }
      });
    }
    dispatch(opts, handler) {
      const { host } = new URL2(opts.origin);
      const headers = buildHeaders(opts.headers);
      throwIfProxyAuthIsSent(headers);
      return this[kAgent].dispatch({
        ...opts,
        headers: {
          ...headers,
          host
        }
      }, handler);
    }
    async[kClose]() {
      await this[kAgent].close();
      await this[kClient].close();
    }
    async[kDestroy]() {
      await this[kAgent].destroy();
      await this[kClient].destroy();
    }
  }
  module.exports = ProxyAgent;
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS((exports, module) => {
  var setGlobalDispatcher = function(agent) {
    if (!agent || typeof agent.dispatch !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent,
      writable: true,
      enumerable: false,
      configurable: false
    });
  };
  var getGlobalDispatcher = function() {
    return globalThis[globalDispatcher];
  };
  var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
  var { InvalidArgumentError } = require_errors();
  var Agent = require_agent();
  if (getGlobalDispatcher() === undefined) {
    setGlobalDispatcher(new Agent);
  }
  module.exports = {
    setGlobalDispatcher,
    getGlobalDispatcher
  };
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS((exports, module) => {
  module.exports = class DecoratorHandler {
    constructor(handler) {
      this.handler = handler;
    }
    onConnect(...args) {
      return this.handler.onConnect(...args);
    }
    onError(...args) {
      return this.handler.onError(...args);
    }
    onUpgrade(...args) {
      return this.handler.onUpgrade(...args);
    }
    onHeaders(...args) {
      return this.handler.onHeaders(...args);
    }
    onData(...args) {
      return this.handler.onData(...args);
    }
    onComplete(...args) {
      return this.handler.onComplete(...args);
    }
    onBodySent(...args) {
      return this.handler.onBodySent(...args);
    }
  };
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS((exports, module) => {
  var headerValueNormalize = function(potentialValue) {
    let i = potentialValue.length;
    while (/[\r\n\t ]/.test(potentialValue.charAt(--i)))
      ;
    return potentialValue.slice(0, i + 1).replace(/^[\r\n\t ]+/, "");
  };
  var fill = function(headers, object) {
    if (Array.isArray(object)) {
      for (const header of object) {
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        headers.append(header[0], header[1]);
      }
    } else if (typeof object === "object" && object !== null) {
      for (const [key, value] of Object.entries(object)) {
        headers.append(key, value);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  };
  var { kHeadersList } = require_symbols();
  var { kGuard } = require_symbols2();
  var { kEnumerableProperty } = require_util();
  var {
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue
  } = require_util2();
  var { webidl } = require_webidl();
  var assert = __require("assert");
  var kHeadersMap = Symbol("headers map");
  var kHeadersSortedMap = Symbol("headers map sorted");

  class HeadersList {
    cookies = null;
    constructor(init) {
      if (init instanceof HeadersList) {
        this[kHeadersMap] = new Map(init[kHeadersMap]);
        this[kHeadersSortedMap] = init[kHeadersSortedMap];
        this.cookies = init.cookies;
      } else {
        this[kHeadersMap] = new Map(init);
        this[kHeadersSortedMap] = null;
      }
    }
    contains(name) {
      name = name.toLowerCase();
      return this[kHeadersMap].has(name);
    }
    clear() {
      this[kHeadersMap].clear();
      this[kHeadersSortedMap] = null;
      this.cookies = null;
    }
    append(name, value) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = name.toLowerCase();
      const exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        this.cookies ??= [];
        this.cookies.push(value);
      }
    }
    set(name, value) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      return this[kHeadersMap].set(lowercaseName, { name, value });
    }
    delete(name) {
      this[kHeadersSortedMap] = null;
      name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      return this[kHeadersMap].delete(name);
    }
    get(name) {
      if (!this.contains(name)) {
        return null;
      }
      return this[kHeadersMap].get(name.toLowerCase())?.value ?? null;
    }
    *[Symbol.iterator]() {
      for (const [name, { value }] of this[kHeadersMap]) {
        yield [name, value];
      }
    }
    get entries() {
      const headers = {};
      if (this[kHeadersMap].size) {
        for (const { name, value } of this[kHeadersMap].values()) {
          headers[name] = value;
        }
      }
      return headers;
    }
  }

  class Headers {
    constructor(init = undefined) {
      this[kHeadersList] = new HeadersList;
      this[kGuard] = "none";
      if (init !== undefined) {
        init = webidl.converters.HeadersInit(init);
        fill(this, init);
      }
    }
    append(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
      name = webidl.converters.ByteString(name);
      value = webidl.converters.ByteString(value);
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (this[kGuard] === "request-no-cors") {
      }
      return this[kHeadersList].append(name, value);
    }
    delete(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (this[kGuard] === "request-no-cors") {
      }
      if (!this[kHeadersList].contains(name)) {
        return;
      }
      return this[kHeadersList].delete(name);
    }
    get(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.get",
          value: name,
          type: "header name"
        });
      }
      return this[kHeadersList].get(name);
    }
    has(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.has",
          value: name,
          type: "header name"
        });
      }
      return this[kHeadersList].contains(name);
    }
    set(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
      name = webidl.converters.ByteString(name);
      value = webidl.converters.ByteString(value);
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value,
          type: "header value"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (this[kGuard] === "request-no-cors") {
      }
      return this[kHeadersList].set(name, value);
    }
    getSetCookie() {
      webidl.brandCheck(this, Headers);
      const list = this[kHeadersList].cookies;
      if (list) {
        return [...list];
      }
      return [];
    }
    get [kHeadersSortedMap]() {
      if (this[kHeadersList][kHeadersSortedMap]) {
        return this[kHeadersList][kHeadersSortedMap];
      }
      const headers = [];
      const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
      const cookies = this[kHeadersList].cookies;
      for (const [name, value] of names) {
        if (name === "set-cookie") {
          for (const value2 of cookies) {
            headers.push([name, value2]);
          }
        } else {
          assert(value !== null);
          headers.push([name, value]);
        }
      }
      this[kHeadersList][kHeadersSortedMap] = headers;
      return headers;
    }
    keys() {
      webidl.brandCheck(this, Headers);
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
    }
    values() {
      webidl.brandCheck(this, Headers);
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "value");
    }
    entries() {
      webidl.brandCheck(this, Headers);
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key+value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
      if (typeof callbackFn !== "function") {
        throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
      }
      for (const [key, value] of this) {
        callbackFn.apply(thisArg, [value, key, this]);
      }
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      webidl.brandCheck(this, Headers);
      return this[kHeadersList];
    }
  }
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    keys: kEnumerableProperty,
    values: kEnumerableProperty,
    entries: kEnumerableProperty,
    forEach: kEnumerableProperty,
    [Symbol.iterator]: { enumerable: false },
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    }
  });
  webidl.converters.HeadersInit = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (V[Symbol.iterator]) {
        return webidl.converters["sequence<sequence<ByteString>>"](V);
      }
      return webidl.converters["record<ByteString, ByteString>"](V);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  module.exports = {
    fill,
    Headers,
    HeadersList
  };
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS((exports, module) => {
  var cloneResponse = function(response) {
    if (response.internalResponse) {
      return filterResponse(cloneResponse(response.internalResponse), response.type);
    }
    const newResponse = makeResponse({ ...response, body: null });
    if (response.body != null) {
      newResponse.body = cloneBody(response.body);
    }
    return newResponse;
  };
  var makeResponse = function(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList,
      urlList: init.urlList ? [...init.urlList] : []
    };
  };
  var makeNetworkError = function(reason) {
    const isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  };
  var makeFilteredResponse = function(response, state) {
    state = {
      internalResponse: response,
      ...state
    };
    return new Proxy(response, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        assert(!(p in state));
        target[p] = value;
        return true;
      }
    });
  };
  var filterResponse = function(response, type) {
    if (type === "basic") {
      return makeFilteredResponse(response, {
        type: "basic",
        headersList: response.headersList
      });
    } else if (type === "cors") {
      return makeFilteredResponse(response, {
        type: "cors",
        headersList: response.headersList
      });
    } else if (type === "opaque") {
      return makeFilteredResponse(response, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type === "opaqueredirect") {
      return makeFilteredResponse(response, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert(false);
    }
  };
  var makeAppropriateNetworkError = function(fetchParams, err = null) {
    assert(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
  };
  var initializeResponse = function(response, init, body) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if ("status" in init && init.status != null) {
      response[kState].status = init.status;
    }
    if ("statusText" in init && init.statusText != null) {
      response[kState].statusText = init.statusText;
    }
    if ("headers" in init && init.headers != null) {
      fill(response[kHeaders], init.headers);
    }
    if (body) {
      if (nullBodyStatus.includes(response.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: "Invalid response status code " + response.status
        });
      }
      response[kState].body = body.body;
      if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
        response[kState].headersList.append("content-type", body.type);
      }
    }
  };
  var { Headers, HeadersList, fill } = require_headers();
  var { extractBody, cloneBody, mixinBody } = require_body();
  var util = require_util();
  var { kEnumerableProperty } = util;
  var {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isBlobLike,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode
  } = require_util2();
  var {
    redirectStatusSet,
    nullBodyStatus,
    DOMException: DOMException2
  } = require_constants();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var { webidl } = require_webidl();
  var { FormData: FormData2 } = require_formdata();
  var { getGlobalOrigin } = require_global();
  var { URLSerializer } = require_dataURL();
  var { kHeadersList } = require_symbols();
  var assert = __require("assert");
  var { types } = __require("util");
  var ReadableStream = globalThis.ReadableStream || __require("stream/web").ReadableStream;
  var textEncoder = new TextEncoder("utf-8");

  class Response2 {
    static error() {
      const relevantRealm = { settingsObject: {} };
      const responseObject = new Response2;
      responseObject[kState] = makeNetworkError();
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      return responseObject;
    }
    static json(data, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));
      const body = extractBody(bytes);
      const relevantRealm = { settingsObject: {} };
      const responseObject = new Response2;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kGuard] = "response";
      responseObject[kHeaders][kRealm] = relevantRealm;
      initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
      return responseObject;
    }
    static redirect(url, status = 302) {
      const relevantRealm = { settingsObject: {} };
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, getGlobalOrigin());
      } catch (err) {
        throw Object.assign(new TypeError("Failed to parse URL from " + url), {
          cause: err
        });
      }
      if (!redirectStatusSet.has(status)) {
        throw new RangeError("Invalid status code " + status);
      }
      const responseObject = new Response2;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      responseObject[kState].status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      responseObject[kState].headersList.append("location", value);
      return responseObject;
    }
    constructor(body = null, init = {}) {
      if (body !== null) {
        body = webidl.converters.BodyInit(body);
      }
      init = webidl.converters.ResponseInit(init);
      this[kRealm] = { settingsObject: {} };
      this[kState] = makeResponse({});
      this[kHeaders] = new Headers;
      this[kHeaders][kGuard] = "response";
      this[kHeaders][kHeadersList] = this[kState].headersList;
      this[kHeaders][kRealm] = this[kRealm];
      let bodyWithType = null;
      if (body != null) {
        const [extractedBody, type] = extractBody(body);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    get type() {
      webidl.brandCheck(this, Response2);
      return this[kState].type;
    }
    get url() {
      webidl.brandCheck(this, Response2);
      const urlList = this[kState].urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    get redirected() {
      webidl.brandCheck(this, Response2);
      return this[kState].urlList.length > 1;
    }
    get status() {
      webidl.brandCheck(this, Response2);
      return this[kState].status;
    }
    get ok() {
      webidl.brandCheck(this, Response2);
      return this[kState].status >= 200 && this[kState].status <= 299;
    }
    get statusText() {
      webidl.brandCheck(this, Response2);
      return this[kState].statusText;
    }
    get headers() {
      webidl.brandCheck(this, Response2);
      return this[kHeaders];
    }
    get body() {
      webidl.brandCheck(this, Response2);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Response2);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    clone() {
      webidl.brandCheck(this, Response2);
      if (this.bodyUsed || this.body && this.body.locked) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(this[kState]);
      const clonedResponseObject = new Response2;
      clonedResponseObject[kState] = clonedResponse;
      clonedResponseObject[kRealm] = this[kRealm];
      clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
      clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
      clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      return clonedResponseObject;
    }
  }
  mixinBody(Response2);
  Object.defineProperties(Response2.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response2, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
  webidl.converters.FormData = webidl.interfaceConverter(FormData2);
  webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
  webidl.converters.XMLHttpRequestBodyInit = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (isBlobLike(V)) {
      return webidl.converters.Blob(V, { strict: false });
    }
    if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
      return webidl.converters.BufferSource(V);
    }
    if (util.isFormDataLike(V)) {
      return webidl.converters.FormData(V, { strict: false });
    }
    if (V instanceof URLSearchParams) {
      return webidl.converters.URLSearchParams(V);
    }
    return webidl.converters.DOMString(V);
  };
  webidl.converters.BodyInit = function(V) {
    if (V instanceof ReadableStream) {
      return webidl.converters.ReadableStream(V);
    }
    if (V?.[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  module.exports = {
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response: Response2,
    cloneResponse
  };
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS((exports, module) => {
  var makeRequest = function(init) {
    const request = {
      method: "GET",
      localURLsOnly: false,
      unsafeRequest: false,
      body: null,
      client: null,
      reservedClient: null,
      replacesClientId: "",
      window: "client",
      keepalive: false,
      serviceWorkers: "all",
      initiator: "",
      destination: "",
      priority: null,
      origin: "client",
      policyContainer: "client",
      referrer: "client",
      referrerPolicy: "",
      mode: "no-cors",
      useCORSPreflightFlag: false,
      credentials: "same-origin",
      useCredentials: false,
      cache: "default",
      redirect: "follow",
      integrity: "",
      cryptoGraphicsNonceMetadata: "",
      parserMetadata: "",
      reloadNavigation: false,
      historyNavigation: false,
      userActivation: false,
      taintedOrigin: false,
      redirectCount: 0,
      responseTainting: "basic",
      preventNoCacheCacheControlHeaderModification: false,
      done: false,
      timingAllowFailed: false,
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList
    };
    request.url = request.urlList[0];
    return request;
  };
  var cloneRequest = function(request) {
    const newRequest = makeRequest({ ...request, body: null });
    if (request.body != null) {
      newRequest.body = cloneBody(request.body);
    }
    return newRequest;
  };
  var { extractBody, mixinBody, cloneBody } = require_body();
  var { Headers, fill: fillHeaders, HeadersList } = require_headers();
  var { FinalizationRegistry } = require_dispatcher_weakref()();
  var util = require_util();
  var {
    isValidHTTPToken,
    sameOrigin,
    normalizeMethod,
    makePolicyContainer
  } = require_util2();
  var {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = require_constants();
  var { kEnumerableProperty } = util;
  var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
  var { webidl } = require_webidl();
  var { getGlobalOrigin } = require_global();
  var { URLSerializer } = require_dataURL();
  var { kHeadersList } = require_symbols();
  var assert = __require("assert");
  var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("events");
  var TransformStream = globalThis.TransformStream;
  var kInit = Symbol("init");
  var kAbortController = Symbol("abortController");
  var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
    signal.removeEventListener("abort", abort);
  });

  class Request {
    constructor(input, init = {}) {
      if (input === kInit) {
        return;
      }
      webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
      input = webidl.converters.RequestInfo(input);
      init = webidl.converters.RequestInit(init);
      this[kRealm] = {
        settingsObject: {
          baseUrl: getGlobalOrigin(),
          get origin() {
            return this.baseUrl?.origin;
          },
          policyContainer: makePolicyContainer()
        }
      };
      let request = null;
      let fallbackMode = null;
      const baseUrl = this[kRealm].settingsObject.baseUrl;
      let signal = null;
      if (typeof input === "string") {
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
        }
        request = makeRequest({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        assert(input instanceof Request);
        request = input[kState];
        signal = input[kSignal];
      }
      const origin = this[kRealm].settingsObject.origin;
      let window2 = "client";
      if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
        window2 = request.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window2}' must be null`);
      }
      if ("window" in init) {
        window2 = "no-window";
      }
      request = makeRequest({
        method: request.method,
        headersList: request.headersList,
        unsafeRequest: request.unsafeRequest,
        client: this[kRealm].settingsObject,
        window: window2,
        priority: request.priority,
        origin: request.origin,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
        keepalive: request.keepalive,
        reloadNavigation: request.reloadNavigation,
        historyNavigation: request.historyNavigation,
        urlList: [...request.urlList]
      });
      if (Object.keys(init).length > 0) {
        if (request.mode === "navigate") {
          request.mode = "same-origin";
        }
        request.reloadNavigation = false;
        request.historyNavigation = false;
        request.origin = "client";
        request.referrer = "client";
        request.referrerPolicy = "";
        request.url = request.urlList[request.urlList.length - 1];
        request.urlList = [request.url];
      }
      if (init.referrer !== undefined) {
        const referrer = init.referrer;
        if (referrer === "") {
          request.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
            request.referrer = "client";
          } else {
            request.referrer = parsedReferrer;
          }
        }
      }
      if (init.referrerPolicy !== undefined) {
        request.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== undefined) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request.mode = mode;
      }
      if (init.credentials !== undefined) {
        request.credentials = init.credentials;
      }
      if (init.cache !== undefined) {
        request.cache = init.cache;
      }
      if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
        throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
      }
      if (init.redirect !== undefined) {
        request.redirect = init.redirect;
      }
      if (init.integrity !== undefined && init.integrity != null) {
        request.integrity = String(init.integrity);
      }
      if (init.keepalive !== undefined) {
        request.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== undefined) {
        let method = init.method;
        if (!isValidHTTPToken(init.method)) {
          throw TypeError(`'${init.method}' is not a valid HTTP method.`);
        }
        if (forbiddenMethodsSet.has(method.toUpperCase())) {
          throw TypeError(`'${init.method}' HTTP method is unsupported.`);
        }
        method = normalizeMethod(init.method);
        request.method = method;
      }
      if (init.signal !== undefined) {
        signal = init.signal;
      }
      this[kState] = request;
      const ac = new AbortController;
      this[kSignal] = ac.signal;
      this[kSignal][kRealm] = this[kRealm];
      if (signal != null) {
        if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
          throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
        }
        if (signal.aborted) {
          ac.abort(signal.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort = function() {
            const ac2 = acRef.deref();
            if (ac2 !== undefined) {
              ac2.abort(this.reason);
            }
          };
          try {
            if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
              setMaxListeners(100, signal);
            } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
              setMaxListeners(100, signal);
            }
          } catch {
          }
          util.addAbortListener(signal, abort);
          requestFinalizer.register(ac, { signal, abort });
        }
      }
      this[kHeaders] = new Headers;
      this[kHeaders][kHeadersList] = request.headersList;
      this[kHeaders][kGuard] = "request";
      this[kHeaders][kRealm] = this[kRealm];
      if (mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request.method)) {
          throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
        }
        this[kHeaders][kGuard] = "request-no-cors";
      }
      if (Object.keys(init).length !== 0) {
        let headers = new Headers(this[kHeaders]);
        if (init.headers !== undefined) {
          headers = init.headers;
        }
        this[kHeaders][kHeadersList].clear();
        if (headers.constructor.name === "Headers") {
          for (const [key, val] of headers) {
            this[kHeaders].append(key, val);
          }
        } else {
          fillHeaders(this[kHeaders], headers);
        }
      }
      const inputBody = input instanceof Request ? input[kState].body : null;
      if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody(init.body, request.keepalive);
        initBody = extractedBody;
        if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
          this[kHeaders].append("content-type", contentType);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request.mode !== "same-origin" && request.mode !== "cors") {
          throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
        }
        request.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
          throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
        }
        if (!TransformStream) {
          TransformStream = __require("stream/web").TransformStream;
        }
        const identityTransform = new TransformStream;
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this[kState].body = finalBody;
    }
    get method() {
      webidl.brandCheck(this, Request);
      return this[kState].method;
    }
    get url() {
      webidl.brandCheck(this, Request);
      return URLSerializer(this[kState].url);
    }
    get headers() {
      webidl.brandCheck(this, Request);
      return this[kHeaders];
    }
    get destination() {
      webidl.brandCheck(this, Request);
      return this[kState].destination;
    }
    get referrer() {
      webidl.brandCheck(this, Request);
      if (this[kState].referrer === "no-referrer") {
        return "";
      }
      if (this[kState].referrer === "client") {
        return "about:client";
      }
      return this[kState].referrer.toString();
    }
    get referrerPolicy() {
      webidl.brandCheck(this, Request);
      return this[kState].referrerPolicy;
    }
    get mode() {
      webidl.brandCheck(this, Request);
      return this[kState].mode;
    }
    get credentials() {
      return this[kState].credentials;
    }
    get cache() {
      webidl.brandCheck(this, Request);
      return this[kState].cache;
    }
    get redirect() {
      webidl.brandCheck(this, Request);
      return this[kState].redirect;
    }
    get integrity() {
      webidl.brandCheck(this, Request);
      return this[kState].integrity;
    }
    get keepalive() {
      webidl.brandCheck(this, Request);
      return this[kState].keepalive;
    }
    get isReloadNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].reloadNavigation;
    }
    get isHistoryNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].historyNavigation;
    }
    get signal() {
      webidl.brandCheck(this, Request);
      return this[kSignal];
    }
    get body() {
      webidl.brandCheck(this, Request);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Request);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, Request);
      return "half";
    }
    clone() {
      webidl.brandCheck(this, Request);
      if (this.bodyUsed || this.body?.locked) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(this[kState]);
      const clonedRequestObject = new Request(kInit);
      clonedRequestObject[kState] = clonedRequest;
      clonedRequestObject[kRealm] = this[kRealm];
      clonedRequestObject[kHeaders] = new Headers;
      clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
      clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
      clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      const ac = new AbortController;
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        util.addAbortListener(this.signal, () => {
          ac.abort(this.signal.reason);
        });
      }
      clonedRequestObject[kSignal] = ac.signal;
      return clonedRequestObject;
    }
  }
  mixinBody(Request);
  Object.defineProperties(Request.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(Request);
  webidl.converters.RequestInfo = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (V instanceof Request) {
      return webidl.converters.Request(V);
    }
    return webidl.converters.USVString(V);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(webidl.converters.BodyInit)
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter((signal) => webidl.converters.AbortSignal(signal, { strict: false }))
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    }
  ]);
  module.exports = { Request, makeRequest };
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  var fetch2 = function(input, init = {}) {
    webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
    const p = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request(input, init);
    } catch (e) {
      p.reject(e);
      return p.promise;
    }
    const request = requestObject[kState];
    if (requestObject.signal.aborted) {
      abortFetch(p, request, null, requestObject.signal.reason);
      return p.promise;
    }
    const globalObject = request.client.globalObject;
    if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
      request.serviceWorkers = "none";
    }
    let responseObject = null;
    const relevantRealm = null;
    let locallyAborted = false;
    let controller = null;
    addAbortListener(requestObject.signal, () => {
      locallyAborted = true;
      assert(controller != null);
      controller.abort(requestObject.signal.reason);
      abortFetch(p, request, responseObject, requestObject.signal.reason);
    });
    const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
    const processResponse = (response) => {
      if (locallyAborted) {
        return Promise.resolve();
      }
      if (response.aborted) {
        abortFetch(p, request, responseObject, controller.serializedAbortReason);
        return Promise.resolve();
      }
      if (response.type === "error") {
        p.reject(Object.assign(new TypeError("fetch failed"), { cause: response.error }));
        return Promise.resolve();
      }
      responseObject = new Response2;
      responseObject[kState] = response;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kHeadersList] = response.headersList;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      p.resolve(responseObject);
    };
    controller = fetching({
      request,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: init.dispatcher ?? getGlobalDispatcher()
    });
    return p.promise;
  };
  var finalizeAndReportTiming = function(response, initiatorType = "other") {
    if (response.type === "error" && response.aborted) {
      return;
    }
    if (!response.urlList?.length) {
      return;
    }
    const originalURL = response.urlList[0];
    let timingInfo = response.timingInfo;
    let cacheState = response.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!timingInfo.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response.timingInfo = timingInfo;
    markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
  };
  var markResourceTiming = function(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
    if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
      performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
    }
  };
  var abortFetch = function(p, request, responseObject, error) {
    if (!error) {
      error = new DOMException2("The operation was aborted.", "AbortError");
    }
    p.reject(error);
    if (request.body != null && isReadable(request.body?.stream)) {
      request.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response = responseObject[kState];
    if (response.body != null && isReadable(response.body?.stream)) {
      response.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  };
  var fetching = function({
    request,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher
  }) {
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request.client != null) {
      taskDestination = request.client.globalObject;
      crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
    }
    const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currenTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher),
      request,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert(!request.body || request.body.stream);
    if (request.window === "client") {
      request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
    }
    if (request.origin === "client") {
      request.origin = request.client?.origin;
    }
    if (request.policyContainer === "client") {
      if (request.client != null) {
        request.policyContainer = clonePolicyContainer(request.client.policyContainer);
      } else {
        request.policyContainer = makePolicyContainer();
      }
    }
    if (!request.headersList.contains("accept")) {
      const value = "*/*";
      request.headersList.append("accept", value);
    }
    if (!request.headersList.contains("accept-language")) {
      request.headersList.append("accept-language", "*");
    }
    if (request.priority === null) {
    }
    if (subresourceSet.has(request.destination)) {
    }
    mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    });
    return fetchParams.controller;
  };
  async function mainFetch(fetchParams, recursive = false) {
    const request = fetchParams.request;
    let response = null;
    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
      response = makeNetworkError("local URLs only");
    }
    tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
    if (requestBadPort(request) === "blocked") {
      response = makeNetworkError("bad port");
    }
    if (request.referrerPolicy === "") {
      request.referrerPolicy = request.policyContainer.referrerPolicy;
    }
    if (request.referrer !== "no-referrer") {
      request.referrer = determineRequestsReferrer(request);
    }
    if (response === null) {
      response = await (async () => {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || currentURL.protocol === "data:" || (request.mode === "navigate" || request.mode === "websocket")) {
          request.responseTainting = "basic";
          return await schemeFetch(fetchParams);
        }
        if (request.mode === "same-origin") {
          return makeNetworkError('request mode cannot be "same-origin"');
        }
        if (request.mode === "no-cors") {
          if (request.redirect !== "follow") {
            return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
          }
          request.responseTainting = "opaque";
          return await schemeFetch(fetchParams);
        }
        if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
          return makeNetworkError("URL scheme must be a HTTP(S) scheme");
        }
        request.responseTainting = "cors";
        return await httpFetch(fetchParams);
      })();
    }
    if (recursive) {
      return response;
    }
    if (response.status !== 0 && !response.internalResponse) {
      if (request.responseTainting === "cors") {
      }
      if (request.responseTainting === "basic") {
        response = filterResponse(response, "basic");
      } else if (request.responseTainting === "cors") {
        response = filterResponse(response, "cors");
      } else if (request.responseTainting === "opaque") {
        response = filterResponse(response, "opaque");
      } else {
        assert(false);
      }
    }
    let internalResponse = response.status === 0 ? response : response.internalResponse;
    if (internalResponse.urlList.length === 0) {
      internalResponse.urlList.push(...request.urlList);
    }
    if (!request.timingAllowFailed) {
      response.timingAllowPassed = true;
    }
    if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
      response = internalResponse = makeNetworkError();
    }
    if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
      internalResponse.body = null;
      fetchParams.controller.dump = true;
    }
    if (request.integrity) {
      const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request.responseTainting === "opaque" || response.body == null) {
        processBodyError(response.error);
        return;
      }
      const processBody = (bytes) => {
        if (!bytesMatch(bytes, request.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response.body = safelyExtractBody(bytes)[0];
        fetchFinale(fetchParams, response);
      };
      await fullyReadBody(response.body, processBody, processBodyError);
    } else {
      fetchFinale(fetchParams, response);
    }
  }
  var schemeFetch = function(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    }
    const { request } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request);
    switch (scheme) {
      case "about:": {
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = __require("buffer").resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request);
        if (blobURLEntry.search.length !== 0) {
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        }
        const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
        if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
          return Promise.resolve(makeNetworkError("invalid method"));
        }
        const bodyWithType = safelyExtractBody(blobURLEntryObject);
        const body = bodyWithType[0];
        const length = isomorphicEncode(`${body.length}`);
        const type = bodyWithType[1] ?? "";
        const response = makeResponse({
          statusText: "OK",
          headersList: [
            ["content-length", { name: "Content-Length", value: length }],
            ["content-type", { name: "Content-Type", value: type }]
          ]
        });
        response.body = body;
        return Promise.resolve(response);
      }
      case "data:": {
        const currentURL = requestCurrentURL(request);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        }
        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:": {
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      }
      case "http:":
      case "https:": {
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
  };
  var finalizeResponse = function(fetchParams, response) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response));
    }
  };
  var fetchFinale = function(fetchParams, response) {
    if (response.type === "error") {
      response.urlList = [fetchParams.request.urlList[0]];
      response.timingInfo = createOpaqueTimingInfo({
        startTime: fetchParams.timingInfo.startTime
      });
    }
    const processResponseEndOfBody = () => {
      fetchParams.request.done = true;
      if (fetchParams.processResponseEndOfBody != null) {
        queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
      }
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => fetchParams.processResponse(response));
    }
    if (response.body == null) {
      processResponseEndOfBody();
    } else {
      const identityTransformAlgorithm = (chunk, controller) => {
        controller.enqueue(chunk);
      };
      const transformStream = new TransformStream({
        start() {
        },
        transform: identityTransformAlgorithm,
        flush: processResponseEndOfBody
      }, {
        size() {
          return 1;
        }
      }, {
        size() {
          return 1;
        }
      });
      response.body = { stream: response.body.stream.pipeThrough(transformStream) };
    }
    if (fetchParams.processResponseConsumeBody != null) {
      const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
      const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
      if (response.body == null) {
        queueMicrotask(() => processBody(null));
      } else {
        return fullyReadBody(response.body, processBody, processBodyError);
      }
      return Promise.resolve();
    }
  };
  async function httpFetch(fetchParams) {
    const request = fetchParams.request;
    let response = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (request.serviceWorkers === "all") {
    }
    if (response === null) {
      if (request.redirect === "follow") {
        request.serviceWorkers = "none";
      }
      actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
      if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request, response) === "failure") {
        request.timingAllowFailed = true;
      }
    }
    if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request.redirect !== "manual") {
        fetchParams.controller.connection.destroy();
      }
      if (request.redirect === "error") {
        response = makeNetworkError("unexpected redirect");
      } else if (request.redirect === "manual") {
        response = actualResponse;
      } else if (request.redirect === "follow") {
        response = await httpRedirectFetch(fetchParams, response);
      } else {
        assert(false);
      }
    }
    response.timingInfo = timingInfo;
    return response;
  }
  var httpRedirectFetch = function(fetchParams, response) {
    const request = fetchParams.request;
    const actualResponse = response.internalResponse ? response.internalResponse : response;
    let locationURL;
    try {
      locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);
      if (locationURL == null) {
        return response;
      }
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    }
    if (request.redirectCount === 20) {
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    }
    request.redirectCount += 1;
    if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    }
    if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
    }
    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
      return Promise.resolve(makeNetworkError());
    }
    if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
      request.method = "GET";
      request.body = null;
      for (const headerName of requestBodyHeader) {
        request.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request), locationURL)) {
      request.headersList.delete("authorization");
      request.headersList.delete("cookie");
      request.headersList.delete("host");
    }
    if (request.body != null) {
      assert(request.body.source != null);
      request.body = safelyExtractBody(request.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request, actualResponse);
    return mainFetch(fetchParams, true);
  };
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response = null;
    const httpCache = null;
    const revalidatingFlag = false;
    if (request.window === "no-window" && request.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request;
    } else {
      httpRequest = makeRequest(request);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue);
    }
    if (contentLength != null && httpRequest.keepalive) {
    }
    if (httpRequest.referrer instanceof URL) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent")) {
      httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
      httpRequest.headersList.append("cache-control", "max-age=0");
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma")) {
        httpRequest.headersList.append("pragma", "no-cache");
      }
      if (!httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "no-cache");
      }
    }
    if (httpRequest.headersList.contains("range")) {
      httpRequest.headersList.append("accept-encoding", "identity");
    }
    if (!httpRequest.headersList.contains("accept-encoding")) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate");
      }
    }
    httpRequest.headersList.delete("host");
    if (includeCredentials) {
    }
    if (httpCache == null) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
    }
    if (response == null) {
      if (httpRequest.mode === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
      }
      if (revalidatingFlag && forwardResponse.status === 304) {
      }
      if (response == null) {
        response = forwardResponse;
      }
    }
    response.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range")) {
      response.rangeRequested = true;
    }
    response.requestIncludesCredentials = includeCredentials;
    if (response.status === 407) {
      if (request.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
    }
    if (isAuthenticationFetch) {
    }
    return response;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err) {
        if (!this.destroyed) {
          this.destroyed = true;
          this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
        }
      }
    };
    const request = fetchParams.request;
    let response = null;
    const timingInfo = fetchParams.timingInfo;
    const httpCache = null;
    if (httpCache == null) {
      request.cache = "no-store";
    }
    const newConnection = forceNewConnection ? "yes" : "no";
    if (request.mode === "websocket") {
    } else {
    }
    let requestBody = null;
    if (request.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request.body != null) {
      const processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e);
        }
      };
      requestBody = async function* () {
        try {
          for await (const bytes of request.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams, err);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = () => {
      fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      fetchParams.controller.abort(reason);
    };
    if (!ReadableStream) {
      ReadableStream = __require("stream/web").ReadableStream;
    }
    const stream = new ReadableStream({
      async start(controller) {
        fetchParams.controller.controller = controller;
      },
      async pull(controller) {
        await pullAlgorithm(controller);
      },
      async cancel(reason) {
        await cancelAlgorithm(reason);
      }
    }, {
      highWaterMark: 0,
      size() {
        return 1;
      }
    });
    response.body = { stream };
    fetchParams.controller.on("terminated", onAborted);
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? undefined : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = undefined;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === undefined) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response);
          return;
        }
        timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
        if (isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (!fetchParams.controller.controller.desiredSize) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response.aborted = true;
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
        }
      } else {
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : undefined
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response;
    async function dispatch({ body }) {
      const url = requestCurrentURL(request);
      const agent = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject) => agent.dispatch({
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,
        headers: request.headersList.entries,
        maxRedirections: 0,
        upgrade: request.mode === "websocket" ? "websocket" : undefined
      }, {
        body: null,
        abort: null,
        onConnect(abort) {
          const { connection } = fetchParams.controller;
          if (connection.destroyed) {
            abort(new DOMException2("The operation was aborted.", "AbortError"));
          } else {
            fetchParams.controller.on("terminated", abort);
            this.abort = connection.abort = abort;
          }
        },
        onHeaders(status, headersList, resume, statusText) {
          if (status < 200) {
            return;
          }
          let codings = [];
          let location = "";
          const headers = new Headers;
          if (Array.isArray(headersList)) {
            for (let n = 0;n < headersList.length; n += 2) {
              const key = headersList[n + 0].toString("latin1");
              const val = headersList[n + 1].toString("latin1");
              if (key.toLowerCase() === "content-encoding") {
                codings = val.toLowerCase().split(",").map((x) => x.trim());
              } else if (key.toLowerCase() === "location") {
                location = val;
              }
              headers.append(key, val);
            }
          } else {
            const keys = Object.keys(headersList);
            for (const key of keys) {
              const val = headersList[key];
              if (key.toLowerCase() === "content-encoding") {
                codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
              } else if (key.toLowerCase() === "location") {
                location = val;
              }
              headers.append(key, val);
            }
          }
          this.body = new Readable({ read: resume });
          const decoders = [];
          const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
          if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
            for (const coding of codings) {
              if (coding === "x-gzip" || coding === "gzip") {
                decoders.push(zlib.createGunzip({
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }));
              } else if (coding === "deflate") {
                decoders.push(zlib.createInflate());
              } else if (coding === "br") {
                decoders.push(zlib.createBrotliDecompress());
              } else {
                decoders.length = 0;
                break;
              }
            }
          }
          resolve({
            status,
            statusText,
            headersList: headers[kHeadersList],
            body: decoders.length ? pipeline(this.body, ...decoders, () => {
            }) : this.body.on("error", () => {
            })
          });
          return true;
        },
        onData(chunk) {
          if (fetchParams.controller.dump) {
            return;
          }
          const bytes = chunk;
          timingInfo.encodedBodySize += bytes.byteLength;
          return this.body.push(bytes);
        },
        onComplete() {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          fetchParams.controller.ended = true;
          this.body.push(null);
        },
        onError(error) {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          this.body?.destroy(error);
          fetchParams.controller.terminate(error);
          reject(error);
        },
        onUpgrade(status, headersList, socket) {
          if (status !== 101) {
            return;
          }
          const headers = new Headers;
          for (let n = 0;n < headersList.length; n += 2) {
            const key = headersList[n + 0].toString("latin1");
            const val = headersList[n + 1].toString("latin1");
            headers.append(key, val);
          }
          resolve({
            status,
            statusText: STATUS_CODES[status],
            headersList: headers[kHeadersList],
            socket
          });
          return true;
        }
      }));
    }
  }
  var {
    Response: Response2,
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse
  } = require_response();
  var { Headers } = require_headers();
  var { Request, makeRequest } = require_request2();
  var zlib = __require("zlib");
  var {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    isBlobLike,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme
  } = require_util2();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var assert = __require("assert");
  var { safelyExtractBody } = require_body();
  var {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet,
    DOMException: DOMException2
  } = require_constants();
  var { kHeadersList } = require_symbols();
  var EE = __require("events");
  var { Readable, pipeline } = __require("stream");
  var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
  var { dataURLProcessor, serializeAMimeType } = require_dataURL();
  var { TransformStream } = __require("stream/web");
  var { getGlobalDispatcher } = require_global2();
  var { webidl } = require_webidl();
  var { STATUS_CODES } = __require("http");
  var GET_OR_HEAD = ["GET", "HEAD"];
  var resolveObjectURL;
  var ReadableStream = globalThis.ReadableStream;

  class Fetch extends EE {
    constructor(dispatcher) {
      super();
      this.dispatcher = dispatcher;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
      this.setMaxListeners(21);
    }
    terminate(reason) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      this.connection?.destroy(reason);
      this.emit("terminated", reason);
    }
    abort(error) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error) {
        error = new DOMException2("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error;
      this.connection?.destroy(error);
      this.emit("terminated", error);
    }
  }
  module.exports = {
    fetch: fetch2,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS((exports, module) => {
  module.exports = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  };
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var kState = Symbol("ProgressEvent state");

  class ProgressEvent extends Event {
    constructor(type, eventInitDict = {}) {
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
      super(type, eventInitDict);
      this[kState] = {
        lengthComputable: eventInitDict.lengthComputable,
        loaded: eventInitDict.loaded,
        total: eventInitDict.total
      };
    }
    get lengthComputable() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].lengthComputable;
    }
    get loaded() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].loaded;
    }
    get total() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].total;
    }
  }
  webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "loaded",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "total",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ]);
  module.exports = {
    ProgressEvent
  };
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS((exports, module) => {
  var getEncoding = function(label) {
    if (!label) {
      return "failure";
    }
    switch (label.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  };
  module.exports = {
    getEncoding
  };
});

// node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS((exports, module) => {
  var readOperation = function(fr, blob, type, encodingName) {
    if (fr[kState] === "loading") {
      throw new DOMException2("Invalid state", "InvalidStateError");
    }
    fr[kState] = "loading";
    fr[kResult] = null;
    fr[kError] = null;
    const stream = blob.stream();
    const reader = stream.getReader();
    const bytes = [];
    let chunkPromise = reader.read();
    let isFirstChunk = true;
    (async () => {
      while (!fr[kAborted]) {
        try {
          const { done, value } = await chunkPromise;
          if (isFirstChunk && !fr[kAborted]) {
            queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            });
          }
          isFirstChunk = false;
          if (!done && types.isUint8Array(value)) {
            bytes.push(value);
            if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
              fr[kLastProgressEventFired] = Date.now();
              queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              });
            }
            chunkPromise = reader.read();
          } else if (done) {
            queueMicrotask(() => {
              fr[kState] = "done";
              try {
                const result = packageData(bytes, type, blob.type, encodingName);
                if (fr[kAborted]) {
                  return;
                }
                fr[kResult] = result;
                fireAProgressEvent("load", fr);
              } catch (error) {
                fr[kError] = error;
                fireAProgressEvent("error", fr);
              }
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        } catch (error) {
          if (fr[kAborted]) {
            return;
          }
          queueMicrotask(() => {
            fr[kState] = "done";
            fr[kError] = error;
            fireAProgressEvent("error", fr);
            if (fr[kState] !== "loading") {
              fireAProgressEvent("loadend", fr);
            }
          });
          break;
        }
      }
    })();
  };
  var fireAProgressEvent = function(e, reader) {
    const event = new ProgressEvent(e, {
      bubbles: false,
      cancelable: false
    });
    reader.dispatchEvent(event);
  };
  var packageData = function(bytes, type, mimeType, encodingName) {
    switch (type) {
      case "DataURL": {
        let dataURL = "data:";
        const parsed = parseMIMEType(mimeType || "application/octet-stream");
        if (parsed !== "failure") {
          dataURL += serializeAMimeType(parsed);
        }
        dataURL += ";base64,";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          dataURL += btoa2(decoder.write(chunk));
        }
        dataURL += btoa2(decoder.end());
        return dataURL;
      }
      case "Text": {
        let encoding = "failure";
        if (encodingName) {
          encoding = getEncoding(encodingName);
        }
        if (encoding === "failure" && mimeType) {
          const type2 = parseMIMEType(mimeType);
          if (type2 !== "failure") {
            encoding = getEncoding(type2.parameters.get("charset"));
          }
        }
        if (encoding === "failure") {
          encoding = "UTF-8";
        }
        return decode(bytes, encoding);
      }
      case "ArrayBuffer": {
        const sequence = combineByteSequences(bytes);
        return sequence.buffer;
      }
      case "BinaryString": {
        let binaryString = "";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          binaryString += decoder.write(chunk);
        }
        binaryString += decoder.end();
        return binaryString;
      }
    }
  };
  var decode = function(ioQueue, encoding) {
    const bytes = combineByteSequences(ioQueue);
    const BOMEncoding = BOMSniffing(bytes);
    let slice = 0;
    if (BOMEncoding !== null) {
      encoding = BOMEncoding;
      slice = BOMEncoding === "UTF-8" ? 3 : 2;
    }
    const sliced = bytes.slice(slice);
    return new TextDecoder(encoding).decode(sliced);
  };
  var BOMSniffing = function(ioQueue) {
    const [a, b, c] = ioQueue;
    if (a === 239 && b === 187 && c === 191) {
      return "UTF-8";
    } else if (a === 254 && b === 255) {
      return "UTF-16BE";
    } else if (a === 255 && b === 254) {
      return "UTF-16LE";
    }
    return null;
  };
  var combineByteSequences = function(sequences) {
    const size = sequences.reduce((a, b) => {
      return a + b.byteLength;
    }, 0);
    let offset = 0;
    return sequences.reduce((a, b) => {
      a.set(b, offset);
      offset += b.byteLength;
      return a;
    }, new Uint8Array(size));
  };
  var {
    kState,
    kError,
    kResult,
    kAborted,
    kLastProgressEventFired
  } = require_symbols3();
  var { ProgressEvent } = require_progressevent();
  var { getEncoding } = require_encoding();
  var { DOMException: DOMException2 } = require_constants();
  var { serializeAMimeType, parseMIMEType } = require_dataURL();
  var { types } = __require("util");
  var { StringDecoder } = __require("string_decoder");
  var { btoa: btoa2 } = __require("buffer");
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  module.exports = {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  };
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS((exports, module) => {
  var {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  } = require_util4();
  var {
    kState,
    kError,
    kResult,
    kEvents,
    kAborted
  } = require_symbols3();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class FileReader extends EventTarget {
    constructor() {
      super();
      this[kState] = "empty";
      this[kResult] = null;
      this[kError] = null;
      this[kEvents] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    readAsArrayBuffer(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "ArrayBuffer");
    }
    readAsBinaryString(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "BinaryString");
    }
    readAsText(blob, encoding = undefined) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
      blob = webidl.converters.Blob(blob, { strict: false });
      if (encoding !== undefined) {
        encoding = webidl.converters.DOMString(encoding);
      }
      readOperation(this, blob, "Text", encoding);
    }
    readAsDataURL(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "DataURL");
    }
    abort() {
      if (this[kState] === "empty" || this[kState] === "done") {
        this[kResult] = null;
        return;
      }
      if (this[kState] === "loading") {
        this[kState] = "done";
        this[kResult] = null;
      }
      this[kAborted] = true;
      fireAProgressEvent("abort", this);
      if (this[kState] !== "loading") {
        fireAProgressEvent("loadend", this);
      }
    }
    get readyState() {
      webidl.brandCheck(this, FileReader);
      switch (this[kState]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    get result() {
      webidl.brandCheck(this, FileReader);
      return this[kResult];
    }
    get error() {
      webidl.brandCheck(this, FileReader);
      return this[kError];
    }
    get onloadend() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadend;
    }
    set onloadend(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadend) {
        this.removeEventListener("loadend", this[kEvents].loadend);
      }
      if (typeof fn === "function") {
        this[kEvents].loadend = fn;
        this.addEventListener("loadend", fn);
      } else {
        this[kEvents].loadend = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].error) {
        this.removeEventListener("error", this[kEvents].error);
      }
      if (typeof fn === "function") {
        this[kEvents].error = fn;
        this.addEventListener("error", fn);
      } else {
        this[kEvents].error = null;
      }
    }
    get onloadstart() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadstart;
    }
    set onloadstart(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadstart) {
        this.removeEventListener("loadstart", this[kEvents].loadstart);
      }
      if (typeof fn === "function") {
        this[kEvents].loadstart = fn;
        this.addEventListener("loadstart", fn);
      } else {
        this[kEvents].loadstart = null;
      }
    }
    get onprogress() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].progress;
    }
    set onprogress(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].progress) {
        this.removeEventListener("progress", this[kEvents].progress);
      }
      if (typeof fn === "function") {
        this[kEvents].progress = fn;
        this.addEventListener("progress", fn);
      } else {
        this[kEvents].progress = null;
      }
    }
    get onload() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].load;
    }
    set onload(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].load) {
        this.removeEventListener("load", this[kEvents].load);
      }
      if (typeof fn === "function") {
        this[kEvents].load = fn;
        this.addEventListener("load", fn);
      } else {
        this[kEvents].load = null;
      }
    }
    get onabort() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].abort;
    }
    set onabort(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].abort) {
        this.removeEventListener("abort", this[kEvents].abort);
      }
      if (typeof fn === "function") {
        this[kEvents].abort = fn;
        this.addEventListener("abort", fn);
      } else {
        this[kEvents].abort = null;
      }
    }
  }
  FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
  FileReader.LOADING = FileReader.prototype.LOADING = 1;
  FileReader.DONE = FileReader.prototype.DONE = 2;
  Object.defineProperties(FileReader.prototype, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors,
    readAsArrayBuffer: kEnumerableProperty,
    readAsBinaryString: kEnumerableProperty,
    readAsText: kEnumerableProperty,
    readAsDataURL: kEnumerableProperty,
    abort: kEnumerableProperty,
    readyState: kEnumerableProperty,
    result: kEnumerableProperty,
    error: kEnumerableProperty,
    onloadstart: kEnumerableProperty,
    onprogress: kEnumerableProperty,
    onload: kEnumerableProperty,
    onabort: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onloadend: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(FileReader, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors
  });
  module.exports = {
    FileReader
  };
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS((exports, module) => {
  module.exports = {
    kConstruct: Symbol("constructable")
  };
});

// node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS((exports, module) => {
  var urlEquals = function(A, B, excludeFragment = false) {
    const serializedA = URLSerializer(A, excludeFragment);
    const serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  };
  var fieldValues = function(header) {
    assert(header !== null);
    const values = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (!value.length) {
        continue;
      } else if (!isValidHeaderName(value)) {
        continue;
      }
      values.push(value);
    }
    return values;
  };
  var assert = __require("assert");
  var { URLSerializer } = require_dataURL();
  var { isValidHeaderName } = require_util2();
  module.exports = {
    urlEquals,
    fieldValues
  };
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { urlEquals, fieldValues: getFieldValues } = require_util5();
  var { kEnumerableProperty, isDisturbed } = require_util();
  var { kHeadersList } = require_symbols();
  var { webidl } = require_webidl();
  var { Response: Response2, cloneResponse } = require_response();
  var { Request } = require_request2();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var { fetching } = require_fetch();
  var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
  var assert = __require("assert");
  var { getGlobalDispatcher } = require_global2();

  class Cache {
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      const p = await this.matchAll(request, options);
      if (p.length === 0) {
        return;
      }
      return p[0];
    }
    async matchAll(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const responses = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          responses.push(requestResponse[1]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          responses.push(requestResponse[1]);
        }
      }
      const responseList = [];
      for (const response of responses) {
        const responseObject = new Response2(response.body?.source ?? null);
        const body = responseObject[kState].body;
        responseObject[kState] = response;
        responseObject[kState].body = body;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseList.push(responseObject);
      }
      return Object.freeze(responseList);
    }
    async add(request) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
      request = webidl.converters.RequestInfo(request);
      const requests = [request];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
      requests = webidl.converters["sequence<RequestInfo>"](requests);
      const responsePromises = [];
      const requestList = [];
      for (const request of requests) {
        if (typeof request === "string") {
          continue;
        }
        const r = request[kState];
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request of requests) {
        const r = new Request(request)[kState];
        if (!urlIsHttpHttpsScheme(r.url)) {
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme."
          });
        }
        r.initiator = "fetch";
        r.destination = "subresource";
        requestList.push(r);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          dispatcher: getGlobalDispatcher(),
          processResponse(response) {
            if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response) {
            if (response.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p = Promise.all(responsePromises);
      const responses = await p;
      const operations = [];
      let index = 0;
      for (const response of responses) {
        const operation = {
          type: "put",
          request: requestList[index],
          response
        };
        operations.push(operation);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(undefined);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request, response) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
      request = webidl.converters.RequestInfo(request);
      response = webidl.converters.Response(response);
      let innerRequest = null;
      if (request instanceof Request) {
        innerRequest = request[kState];
      } else {
        innerRequest = new Request(request)[kState];
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = response[kState];
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: "Cache.put",
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream = innerResponse.body.stream;
        const reader = stream.getReader();
        readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
      } else {
        bodyReadPromise.resolve(undefined);
      }
      const operations = [];
      const operation = {
        type: "put",
        request: innerRequest,
        response: clonedResponse
      };
      operations.push(operation);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request, options = {}) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request instanceof Request) {
        r = request[kState];
        if (r.method !== "GET" && !options.ignoreMethod) {
          return false;
        }
      } else {
        assert(typeof request === "string");
        r = new Request(request)[kState];
      }
      const operations = [];
      const operation = {
        type: "delete",
        request: r,
        options
      };
      operations.push(operation);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!requestResponses?.length);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async keys(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const promise = createDeferredPromise();
      const requests = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request2 of requests) {
          const requestObject = new Request("https://a");
          requestObject[kState] = request2;
          requestObject[kHeaders][kHeadersList] = request2.headersList;
          requestObject[kHeaders][kGuard] = "immutable";
          requestObject[kRealm] = request2.client;
          requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      });
      return promise.promise;
    }
    #batchCacheOperations(operations) {
      const cache = this.#relevantRequestResponseList;
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (this.#queryCache(operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = this.#queryCache(operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = this.#queryCache(operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        this.#relevantRequestResponseList.length = 0;
        this.#relevantRequestResponseList = backupCache;
        throw e;
      }
    }
    #queryCache(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? this.#relevantRequestResponseList;
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    }
    #requestMatchesCachedItem(requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  var cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(Response2);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
  module.exports = {
    Cache
  };
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { Cache } = require_cache();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class CacheStorage {
    #caches = new Map;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.MultiCacheQueryOptions(options);
      if (options.cacheName != null) {
        if (this.#caches.has(options.cacheName)) {
          const cacheList = this.#caches.get(options.cacheName);
          const cache = new Cache(kConstruct, cacheList);
          return await cache.match(request, options);
        }
      } else {
        for (const cacheList of this.#caches.values()) {
          const cache = new Cache(kConstruct, cacheList);
          const response = await cache.match(request, options);
          if (response !== undefined) {
            return response;
          }
        }
      }
    }
    async has(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
      cacheName = webidl.converters.DOMString(cacheName);
      return this.#caches.has(cacheName);
    }
    async open(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
      cacheName = webidl.converters.DOMString(cacheName);
      if (this.#caches.has(cacheName)) {
        const cache2 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache2);
      }
      const cache = [];
      this.#caches.set(cacheName, cache);
      return new Cache(kConstruct, cache);
    }
    async delete(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
      cacheName = webidl.converters.DOMString(cacheName);
      return this.#caches.delete(cacheName);
    }
    async keys() {
      webidl.brandCheck(this, CacheStorage);
      const keys = this.#caches.keys();
      return [...keys];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  module.exports = {
    CacheStorage
  };
});

// node_modules/undici/lib/cookies/constants.js
var require_constants3 = __commonJS((exports, module) => {
  var maxAttributeValueSize = 1024;
  var maxNameValuePairSize = 4096;
  module.exports = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
});

// node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS((exports, module) => {
  var isCTLExcludingHtab = function(value) {
    if (value.length === 0) {
      return false;
    }
    for (const char of value) {
      const code = char.charCodeAt(0);
      if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
        return false;
      }
    }
  };
  var validateCookieName = function(name) {
    for (const char of name) {
      const code = char.charCodeAt(0);
      if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
        throw new Error("Invalid cookie name");
      }
    }
  };
  var validateCookieValue = function(value) {
    for (const char of value) {
      const code = char.charCodeAt(0);
      if (code < 33 || code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
        throw new Error("Invalid header value");
      }
    }
  };
  var validateCookiePath = function(path) {
    for (const char of path) {
      const code = char.charCodeAt(0);
      if (code < 33 || char === ";") {
        throw new Error("Invalid cookie path");
      }
    }
  };
  var validateCookieDomain = function(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  };
  var toIMFDate = function(date) {
    if (typeof date === "number") {
      date = new Date(date);
    }
    const days = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    const months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    const dayName = days[date.getUTCDay()];
    const day = date.getUTCDate().toString().padStart(2, "0");
    const month = months[date.getUTCMonth()];
    const year = date.getUTCFullYear();
    const hour = date.getUTCHours().toString().padStart(2, "0");
    const minute = date.getUTCMinutes().toString().padStart(2, "0");
    const second = date.getUTCSeconds().toString().padStart(2, "0");
    return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
  };
  var validateCookieMaxAge = function(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  };
  var stringify = function(cookie) {
    if (cookie.name.length === 0) {
      return null;
    }
    validateCookieName(cookie.name);
    validateCookieValue(cookie.value);
    const out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-")) {
      cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host-")) {
      cookie.secure = true;
      cookie.domain = null;
      cookie.path = "/";
    }
    if (cookie.secure) {
      out.push("Secure");
    }
    if (cookie.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number") {
      validateCookieMaxAge(cookie.maxAge);
      out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
      validateCookieDomain(cookie.domain);
      out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.path) {
      validateCookiePath(cookie.path);
      out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    }
    if (cookie.sameSite) {
      out.push(`SameSite=${cookie.sameSite}`);
    }
    for (const part of cookie.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  };
  var getHeadersList = function(headers) {
    if (headers[kHeadersList]) {
      return headers[kHeadersList];
    }
    if (!kHeadersListNode) {
      kHeadersListNode = Object.getOwnPropertySymbols(headers).find((symbol) => symbol.description === "headers list");
      assert(kHeadersListNode, "Headers cannot be parsed");
    }
    const headersList = headers[kHeadersListNode];
    assert(headersList);
    return headersList;
  };
  var assert = __require("assert");
  var { kHeadersList } = require_symbols();
  var kHeadersListNode;
  module.exports = {
    isCTLExcludingHtab,
    stringify,
    getHeadersList
  };
});

// node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS((exports, module) => {
  var parseSetCookie = function(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value,
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  };
  var parseUnparsedAttributes = function(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ??= [];
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  };
  var { maxNameValuePairSize, maxAttributeValueSize } = require_constants3();
  var { isCTLExcludingHtab } = require_util6();
  var { collectASequenceOfCodePointsFast } = require_dataURL();
  var assert = __require("assert");
  module.exports = {
    parseSetCookie,
    parseUnparsedAttributes
  };
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS((exports, module) => {
  var getCookies = function(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
    webidl.brandCheck(headers, Headers, { strict: false });
    const cookie = headers.get("cookie");
    const out = {};
    if (!cookie) {
      return out;
    }
    for (const piece of cookie.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  };
  var deleteCookie = function(headers, name, attributes) {
    webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
    webidl.brandCheck(headers, Headers, { strict: false });
    name = webidl.converters.DOMString(name);
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie(headers, {
      name,
      value: "",
      expires: new Date(0),
      ...attributes
    });
  };
  var getSetCookies = function(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
    webidl.brandCheck(headers, Headers, { strict: false });
    const cookies = getHeadersList(headers).cookies;
    if (!cookies) {
      return [];
    }
    return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
  };
  var setCookie = function(headers, cookie) {
    webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
    webidl.brandCheck(headers, Headers, { strict: false });
    cookie = webidl.converters.Cookie(cookie);
    const str = stringify(cookie);
    if (str) {
      headers.append("Set-Cookie", stringify(cookie));
    }
  };
  var { parseSetCookie } = require_parse();
  var { stringify, getHeadersList } = require_util6();
  var { webidl } = require_webidl();
  var { Headers } = require_headers();
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: []
    }
  ]);
  module.exports = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie
  };
});

// node_modules/undici/lib/websocket/constants.js
var require_constants4 = __commonJS((exports, module) => {
  var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  var states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  var opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  var maxUnsigned16Bit = 2 ** 16 - 1;
  var parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  var emptyBuffer = Buffer.allocUnsafe(0);
  module.exports = {
    uid,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer
  };
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS((exports, module) => {
  module.exports = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  };
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();
  var { MessagePort } = __require("worker_threads");

  class MessageEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get data() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.data;
    }
    get origin() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.lastEventId;
    }
    get source() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.source;
    }
    get ports() {
      webidl.brandCheck(this, MessageEvent);
      if (!Object.isFrozen(this.#eventInit.ports)) {
        Object.freeze(this.#eventInit.ports);
      }
      return this.#eventInit.ports;
    }
    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
      return new MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
  }

  class CloseEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get wasClean() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.wasClean;
    }
    get code() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.code;
    }
    get reason() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.reason;
    }
  }

  class ErrorEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict) {
      webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
      super(type, eventInitDict);
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      this.#eventInit = eventInitDict;
    }
    get message() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.message;
    }
    get filename() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.filename;
    }
    get lineno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.lineno;
    }
    get colno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.colno;
    }
    get error() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(webidl.converters.MessagePort);
  var eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "source",
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      get defaultValue() {
        return [];
      }
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  module.exports = {
    MessageEvent,
    CloseEvent,
    ErrorEvent
  };
});

// node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS((exports, module) => {
  var isEstablished = function(ws) {
    return ws[kReadyState] === states.OPEN;
  };
  var isClosing = function(ws) {
    return ws[kReadyState] === states.CLOSING;
  };
  var isClosed = function(ws) {
    return ws[kReadyState] === states.CLOSED;
  };
  var fireEvent = function(e, target, eventConstructor = Event, eventInitDict) {
    const event = new eventConstructor(e, eventInitDict);
    target.dispatchEvent(event);
  };
  var websocketMessageReceived = function(ws, type, data) {
    if (ws[kReadyState] !== states.OPEN) {
      return;
    }
    let dataForEvent;
    if (type === opcodes.TEXT) {
      try {
        dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
      } catch {
        failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
        return;
      }
    } else if (type === opcodes.BINARY) {
      if (ws[kBinaryType] === "blob") {
        dataForEvent = new Blob([data]);
      } else {
        dataForEvent = new Uint8Array(data).buffer;
      }
    }
    fireEvent("message", ws, MessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  };
  var isValidSubprotocol = function(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (const char of protocol) {
      const code = char.charCodeAt(0);
      if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || code === 9) {
        return false;
      }
    }
    return true;
  };
  var isValidStatusCode = function(code) {
    if (code >= 1000 && code < 1015) {
      return code !== 1004 && code !== 1005 && code !== 1006;
    }
    return code >= 3000 && code <= 4999;
  };
  var failWebsocketConnection = function(ws, reason) {
    const { [kController]: controller, [kResponse]: response } = ws;
    controller.abort();
    if (response?.socket && !response.socket.destroyed) {
      response.socket.destroy();
    }
    if (reason) {
      fireEvent("error", ws, ErrorEvent, {
        error: new Error(reason)
      });
    }
  };
  var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
  var { states, opcodes } = require_constants4();
  var { MessageEvent, ErrorEvent } = require_events();
  module.exports = {
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    failWebsocketConnection,
    websocketMessageReceived
  };
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS((exports, module) => {
  var establishWebSocketConnection = function(url, protocols, ws, onEstablish, options) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request = makeRequest({
      urlList: [requestURL],
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      const headersList = new Headers(options.headers)[kHeadersList];
      request.headersList = headersList;
    }
    const keyValue = crypto.randomBytes(16).toString("base64");
    request.headersList.append("sec-websocket-key", keyValue);
    request.headersList.append("sec-websocket-version", "13");
    for (const protocol of protocols) {
      request.headersList.append("sec-websocket-protocol", protocol);
    }
    const permessageDeflate = "";
    const controller = fetching({
      request,
      useParallelQueue: true,
      dispatcher: options.dispatcher ?? getGlobalDispatcher(),
      processResponse(response) {
        if (response.type === "error" || response.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
        const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
        if (secExtension !== null && secExtension !== permessageDeflate) {
          failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
          return;
        }
        const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
          return;
        }
        response.socket.on("data", onSocketData);
        response.socket.on("close", onSocketClose);
        response.socket.on("error", onSocketError);
        if (channels.open.hasSubscribers) {
          channels.open.publish({
            address: response.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        }
        onEstablish(response);
      }
    });
    return controller;
  };
  var onSocketData = function(chunk) {
    if (!this.ws[kByteParser].write(chunk)) {
      this.pause();
    }
  };
  var onSocketClose = function() {
    const { ws } = this;
    const wasClean = ws[kSentClose] && ws[kReceivedClose];
    let code = 1005;
    let reason = "";
    const result = ws[kByteParser].closingInfo;
    if (result) {
      code = result.code ?? 1005;
      reason = result.reason;
    } else if (!ws[kSentClose]) {
      code = 1006;
    }
    ws[kReadyState] = states.CLOSED;
    fireEvent("close", ws, CloseEvent, {
      wasClean,
      code,
      reason
    });
    if (channels.close.hasSubscribers) {
      channels.close.publish({
        websocket: ws,
        code,
        reason
      });
    }
  };
  var onSocketError = function(error) {
    const { ws } = this;
    ws[kReadyState] = states.CLOSING;
    if (channels.socketError.hasSubscribers) {
      channels.socketError.publish(error);
    }
    this.destroy();
  };
  var diagnosticsChannel = __require("diagnostics_channel");
  var { uid, states } = require_constants4();
  var {
    kReadyState,
    kSentClose,
    kByteParser,
    kReceivedClose
  } = require_symbols5();
  var { fireEvent, failWebsocketConnection } = require_util7();
  var { CloseEvent } = require_events();
  var { makeRequest } = require_request2();
  var { fetching } = require_fetch();
  var { Headers } = require_headers();
  var { getGlobalDispatcher } = require_global2();
  var { kHeadersList } = require_symbols();
  var channels = {};
  channels.open = diagnosticsChannel.channel("undici:websocket:open");
  channels.close = diagnosticsChannel.channel("undici:websocket:close");
  channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
  var crypto;
  try {
    crypto = __require("crypto");
  } catch {
  }
  module.exports = {
    establishWebSocketConnection
  };
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS((exports, module) => {
  var { maxUnsigned16Bit } = require_constants4();
  var crypto;
  try {
    crypto = __require("crypto");
  } catch {
  }

  class WebsocketFrameSend {
    constructor(data) {
      this.frameData = data;
      this.maskKey = crypto.randomBytes(4);
    }
    createFrame(opcode) {
      const bodyLength = this.frameData?.byteLength ?? 0;
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer = Buffer.allocUnsafe(bodyLength + offset);
      buffer[0] = buffer[1] = 0;
      buffer[0] |= 128;
      buffer[0] = (buffer[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      buffer[offset - 4] = this.maskKey[0];
      buffer[offset - 3] = this.maskKey[1];
      buffer[offset - 2] = this.maskKey[2];
      buffer[offset - 1] = this.maskKey[3];
      buffer[1] = payloadLength;
      if (payloadLength === 126) {
        buffer.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        buffer[2] = buffer[3] = 0;
        buffer.writeUIntBE(bodyLength, 4, 6);
      }
      buffer[1] |= 128;
      for (let i = 0;i < bodyLength; i++) {
        buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
      }
      return buffer;
    }
  }
  module.exports = {
    WebsocketFrameSend
  };
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var diagnosticsChannel = __require("diagnostics_channel");
  var { parserStates, opcodes, states, emptyBuffer } = require_constants4();
  var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
  var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
  var { WebsocketFrameSend } = require_frame();
  var channels = {};
  channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
  channels.pong = diagnosticsChannel.channel("undici:websocket:pong");

  class ByteParser extends Writable {
    #buffers = [];
    #byteOffset = 0;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    constructor(ws) {
      super();
      this.ws = ws;
    }
    _write(chunk, _, callback) {
      this.#buffers.push(chunk);
      this.#byteOffset += chunk.length;
      this.run(callback);
    }
    run(callback) {
      while (true) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.fin = (buffer[0] & 128) !== 0;
          this.#info.opcode = buffer[0] & 15;
          this.#info.originalOpcode ??= this.#info.opcode;
          this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
          if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          const payloadLength = buffer[1] & 127;
          if (payloadLength <= 125) {
            this.#info.payloadLength = payloadLength;
            this.#state = parserStates.READ_DATA;
          } else if (payloadLength === 126) {
            this.#state = parserStates.PAYLOADLENGTH_16;
          } else if (payloadLength === 127) {
            this.#state = parserStates.PAYLOADLENGTH_64;
          }
          if (this.#info.fragmented && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
            return;
          } else if (this.#info.opcode === opcodes.CLOSE) {
            if (payloadLength === 1) {
              failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
              return;
            }
            const body = this.consume(payloadLength);
            this.#info.closeInfo = this.parseCloseBody(false, body);
            if (!this.ws[kSentClose]) {
              const body2 = Buffer.allocUnsafe(2);
              body2.writeUInt16BE(this.#info.closeInfo.code, 0);
              const closeFrame = new WebsocketFrameSend(body2);
              this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err) => {
                if (!err) {
                  this.ws[kSentClose] = true;
                }
              });
            }
            this.ws[kReadyState] = states.CLOSING;
            this.ws[kReceivedClose] = true;
            this.end();
            return;
          } else if (this.#info.opcode === opcodes.PING) {
            const body = this.consume(payloadLength);
            if (!this.ws[kReceivedClose]) {
              const frame = new WebsocketFrameSend(body);
              this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
              if (channels.ping.hasSubscribers) {
                channels.ping.publish({
                  payload: body
                });
              }
            }
            this.#state = parserStates.INFO;
            if (this.#byteOffset > 0) {
              continue;
            } else {
              callback();
              return;
            }
          } else if (this.#info.opcode === opcodes.PONG) {
            const body = this.consume(payloadLength);
            if (channels.pong.hasSubscribers) {
              channels.pong.publish({
                payload: body
              });
            }
            if (this.#byteOffset > 0) {
              continue;
            } else {
              callback();
              return;
            }
          }
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0);
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower;
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength) {
            return callback();
          } else if (this.#byteOffset >= this.#info.payloadLength) {
            const body = this.consume(this.#info.payloadLength);
            this.#fragments.push(body);
            if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
              const fullMessage = Buffer.concat(this.#fragments);
              websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
              this.#info = {};
              this.#fragments.length = 0;
            }
            this.#state = parserStates.INFO;
          }
        }
        if (this.#byteOffset > 0) {
          continue;
        } else {
          callback();
          break;
        }
      }
    }
    consume(n) {
      if (n > this.#byteOffset) {
        return null;
      } else if (n === 0) {
        return emptyBuffer;
      }
      if (this.#buffers[0].length === n) {
        this.#byteOffset -= this.#buffers[0].length;
        return this.#buffers.shift();
      }
      const buffer = Buffer.allocUnsafe(n);
      let offset = 0;
      while (offset !== n) {
        const next = this.#buffers[0];
        const { length } = next;
        if (length + offset === n) {
          buffer.set(this.#buffers.shift(), offset);
          break;
        } else if (length + offset > n) {
          buffer.set(next.subarray(0, n - offset), offset);
          this.#buffers[0] = next.subarray(n - offset);
          break;
        } else {
          buffer.set(this.#buffers.shift(), offset);
          offset += next.length;
        }
      }
      this.#byteOffset -= n;
      return buffer;
    }
    parseCloseBody(onlyCode, data) {
      let code;
      if (data.length >= 2) {
        code = data.readUInt16BE(0);
      }
      if (onlyCode) {
        if (!isValidStatusCode(code)) {
          return null;
        }
        return { code };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      if (code !== undefined && !isValidStatusCode(code)) {
        return null;
      }
      try {
        reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
      } catch {
        return null;
      }
      return { code, reason };
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  module.exports = {
    ByteParser
  };
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { DOMException: DOMException2 } = require_constants();
  var { URLSerializer } = require_dataURL();
  var { getGlobalOrigin } = require_global();
  var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants4();
  var {
    kWebSocketURL,
    kReadyState,
    kController,
    kBinaryType,
    kResponse,
    kSentClose,
    kByteParser
  } = require_symbols5();
  var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
  var { establishWebSocketConnection } = require_connection();
  var { WebsocketFrameSend } = require_frame();
  var { ByteParser } = require_receiver();
  var { kEnumerableProperty, isBlobLike } = require_util();
  var { getGlobalDispatcher } = require_global2();
  var { types } = __require("util");
  var experimentalWarned = false;

  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    constructor(url, protocols = []) {
      super();
      webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
          code: "UNDICI-WS"
        });
      }
      const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
      url = webidl.converters.USVString(url);
      protocols = options.protocols;
      const baseURL = getGlobalOrigin();
      let urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException2(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:") {
        urlRecord.protocol = "ws:";
      } else if (urlRecord.protocol === "https:") {
        urlRecord.protocol = "wss:";
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException2(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
      }
      if (urlRecord.hash || urlRecord.href.endsWith("#")) {
        throw new DOMException2("Got fragment", "SyntaxError");
      }
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this[kWebSocketURL] = new URL(urlRecord.href);
      this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response) => this.#onConnectionEstablished(response), options);
      this[kReadyState] = WebSocket.CONNECTING;
      this[kBinaryType] = "blob";
    }
    close(code = undefined, reason = undefined) {
      webidl.brandCheck(this, WebSocket);
      if (code !== undefined) {
        code = webidl.converters["unsigned short"](code, { clamp: true });
      }
      if (reason !== undefined) {
        reason = webidl.converters.USVString(reason);
      }
      if (code !== undefined) {
        if (code !== 1000 && (code < 3000 || code > 4999)) {
          throw new DOMException2("invalid code", "InvalidAccessError");
        }
      }
      let reasonByteLength = 0;
      if (reason !== undefined) {
        reasonByteLength = Buffer.byteLength(reason);
        if (reasonByteLength > 123) {
          throw new DOMException2(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
        }
      }
      if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {
      } else if (!isEstablished(this)) {
        failWebsocketConnection(this, "Connection was closed before it was established.");
        this[kReadyState] = WebSocket.CLOSING;
      } else if (!isClosing(this)) {
        const frame = new WebsocketFrameSend;
        if (code !== undefined && reason === undefined) {
          frame.frameData = Buffer.allocUnsafe(2);
          frame.frameData.writeUInt16BE(code, 0);
        } else if (code !== undefined && reason !== undefined) {
          frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
          frame.frameData.writeUInt16BE(code, 0);
          frame.frameData.write(reason, 2, "utf-8");
        } else {
          frame.frameData = emptyBuffer;
        }
        const socket = this[kResponse].socket;
        socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
          if (!err) {
            this[kSentClose] = true;
          }
        });
        this[kReadyState] = states.CLOSING;
      } else {
        this[kReadyState] = WebSocket.CLOSING;
      }
    }
    send(data) {
      webidl.brandCheck(this, WebSocket);
      webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
      data = webidl.converters.WebSocketSendData(data);
      if (this[kReadyState] === WebSocket.CONNECTING) {
        throw new DOMException2("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(this) || isClosing(this)) {
        return;
      }
      const socket = this[kResponse].socket;
      if (typeof data === "string") {
        const value = Buffer.from(data);
        const frame = new WebsocketFrameSend(value);
        const buffer = frame.createFrame(opcodes.TEXT);
        this.#bufferedAmount += value.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (types.isArrayBuffer(data)) {
        const value = Buffer.from(data);
        const frame = new WebsocketFrameSend(value);
        const buffer = frame.createFrame(opcodes.BINARY);
        this.#bufferedAmount += value.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (ArrayBuffer.isView(data)) {
        const ab = Buffer.from(data, data.byteOffset, data.byteLength);
        const frame = new WebsocketFrameSend(ab);
        const buffer = frame.createFrame(opcodes.BINARY);
        this.#bufferedAmount += ab.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= ab.byteLength;
        });
      } else if (isBlobLike(data)) {
        const frame = new WebsocketFrameSend;
        data.arrayBuffer().then((ab) => {
          const value = Buffer.from(ab);
          frame.frameData = value;
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        });
      }
    }
    get readyState() {
      webidl.brandCheck(this, WebSocket);
      return this[kReadyState];
    }
    get bufferedAmount() {
      webidl.brandCheck(this, WebSocket);
      return this.#bufferedAmount;
    }
    get url() {
      webidl.brandCheck(this, WebSocket);
      return URLSerializer(this[kWebSocketURL]);
    }
    get extensions() {
      webidl.brandCheck(this, WebSocket);
      return this.#extensions;
    }
    get protocol() {
      webidl.brandCheck(this, WebSocket);
      return this.#protocol;
    }
    get onopen() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      if (typeof fn === "function") {
        this.#events.open = fn;
        this.addEventListener("open", fn);
      } else {
        this.#events.open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      if (typeof fn === "function") {
        this.#events.error = fn;
        this.addEventListener("error", fn);
      } else {
        this.#events.error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.close) {
        this.removeEventListener("close", this.#events.close);
      }
      if (typeof fn === "function") {
        this.#events.close = fn;
        this.addEventListener("close", fn);
      } else {
        this.#events.close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      if (typeof fn === "function") {
        this.#events.message = fn;
        this.addEventListener("message", fn);
      } else {
        this.#events.message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, WebSocket);
      return this[kBinaryType];
    }
    set binaryType(type) {
      webidl.brandCheck(this, WebSocket);
      if (type !== "blob" && type !== "arraybuffer") {
        this[kBinaryType] = "blob";
      } else {
        this[kBinaryType] = type;
      }
    }
    #onConnectionEstablished(response) {
      this[kResponse] = response;
      const parser = new ByteParser(this);
      parser.on("drain", function onParserDrain() {
        this.ws[kResponse].socket.resume();
      });
      response.socket.ws = this;
      this[kByteParser] = parser;
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        this.#extensions = extensions;
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        this.#protocol = protocol;
      }
      fireEvent("open", this);
    }
  }
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
  webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
    if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      get defaultValue() {
        return [];
      }
    },
    {
      key: "dispatcher",
      converter: (V) => V,
      get defaultValue() {
        return getGlobalDispatcher();
      }
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
        return webidl.converters.BufferSource(V);
      }
    }
    return webidl.converters.USVString(V);
  };
  module.exports = {
    WebSocket
  };
});

// node_modules/undici/index.js
var require_undici = __commonJS((exports, module) => {
  var makeDispatcher = function(fn) {
    return (url, opts, handler) => {
      if (typeof opts === "function") {
        handler = opts;
        opts = null;
      }
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
        throw new InvalidArgumentError("invalid url");
      }
      if (opts != null && typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string") {
          throw new InvalidArgumentError("invalid opts.path");
        }
        let path = opts.path;
        if (!opts.path.startsWith("/")) {
          path = `/${path}`;
        }
        url = new URL(util.parseOrigin(url).origin + path);
      } else {
        if (!opts) {
          opts = typeof url === "object" ? url : {};
        }
        url = util.parseURL(url);
      }
      const { agent, dispatcher = getGlobalDispatcher() } = opts;
      if (agent) {
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      }
      return fn.call(dispatcher, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler);
    };
  };
  var Client2 = require_client();
  var Dispatcher = require_dispatcher();
  var errors = require_errors();
  var Pool = require_pool();
  var BalancedPool = require_balanced_pool();
  var Agent = require_agent();
  var util = require_util();
  var { InvalidArgumentError } = errors;
  var api = require_api();
  var buildConnector = require_connect();
  var MockClient = require_mock_client();
  var MockAgent = require_mock_agent();
  var MockPool = require_mock_pool();
  var mockErrors = require_mock_errors();
  var ProxyAgent = require_proxy_agent();
  var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
  var DecoratorHandler = require_DecoratorHandler();
  var RedirectHandler = require_RedirectHandler();
  var createRedirectInterceptor = require_redirectInterceptor();
  var hasCrypto;
  try {
    __require("crypto");
    hasCrypto = true;
  } catch {
    hasCrypto = false;
  }
  Object.assign(Dispatcher.prototype, api);
  exports.Dispatcher = Dispatcher;
  exports.Client = Client2;
  exports.Pool = Pool;
  exports.BalancedPool = BalancedPool;
  exports.Agent = Agent;
  exports.ProxyAgent = ProxyAgent;
  exports.DecoratorHandler = DecoratorHandler;
  exports.RedirectHandler = RedirectHandler;
  exports.createRedirectInterceptor = createRedirectInterceptor;
  exports.buildConnector = buildConnector;
  exports.errors = errors;
  exports.setGlobalDispatcher = setGlobalDispatcher;
  exports.getGlobalDispatcher = getGlobalDispatcher;
  if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
    let fetchImpl = null;
    exports.fetch = async function fetch(resource) {
      if (!fetchImpl) {
        fetchImpl = require_fetch().fetch;
      }
      try {
        return await fetchImpl(...arguments);
      } catch (err) {
        if (typeof err === "object") {
          Error.captureStackTrace(err, this);
        }
        throw err;
      }
    };
    exports.Headers = require_headers().Headers;
    exports.Response = require_response().Response;
    exports.Request = require_request2().Request;
    exports.FormData = require_formdata().FormData;
    exports.File = require_file().File;
    exports.FileReader = require_filereader().FileReader;
    const { setGlobalOrigin, getGlobalOrigin } = require_global();
    exports.setGlobalOrigin = setGlobalOrigin;
    exports.getGlobalOrigin = getGlobalOrigin;
    const { CacheStorage } = require_cachestorage();
    const { kConstruct } = require_symbols4();
    exports.caches = new CacheStorage(kConstruct);
  }
  if (util.nodeMajor >= 16) {
    const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
    exports.deleteCookie = deleteCookie;
    exports.getCookies = getCookies;
    exports.getSetCookies = getSetCookies;
    exports.setCookie = setCookie;
    const { parseMIMEType, serializeAMimeType } = require_dataURL();
    exports.parseMIMEType = parseMIMEType;
    exports.serializeAMimeType = serializeAMimeType;
  }
  if (util.nodeMajor >= 18 && hasCrypto) {
    const { WebSocket } = require_websocket();
    exports.WebSocket = WebSocket;
  }
  exports.request = makeDispatcher(api.request);
  exports.stream = makeDispatcher(api.stream);
  exports.pipeline = makeDispatcher(api.pipeline);
  exports.connect = makeDispatcher(api.connect);
  exports.upgrade = makeDispatcher(api.upgrade);
  exports.MockClient = MockClient;
  exports.MockPool = MockPool;
  exports.MockAgent = MockAgent;
  exports.mockErrors = mockErrors;
});

// node_modules/discord-api-types/gateway/common.js
var require_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/gateway/v10.js
var require_v10 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GatewayDispatchEvents = exports.GatewayIntentBits = exports.GatewayCloseCodes = exports.GatewayOpcodes = exports.GatewayVersion = undefined;
  __exportStar(require_common(), exports);
  exports.GatewayVersion = "10";
  var GatewayOpcodes;
  (function(GatewayOpcodes2) {
    GatewayOpcodes2[GatewayOpcodes2["Dispatch"] = 0] = "Dispatch";
    GatewayOpcodes2[GatewayOpcodes2["Heartbeat"] = 1] = "Heartbeat";
    GatewayOpcodes2[GatewayOpcodes2["Identify"] = 2] = "Identify";
    GatewayOpcodes2[GatewayOpcodes2["PresenceUpdate"] = 3] = "PresenceUpdate";
    GatewayOpcodes2[GatewayOpcodes2["VoiceStateUpdate"] = 4] = "VoiceStateUpdate";
    GatewayOpcodes2[GatewayOpcodes2["Resume"] = 6] = "Resume";
    GatewayOpcodes2[GatewayOpcodes2["Reconnect"] = 7] = "Reconnect";
    GatewayOpcodes2[GatewayOpcodes2["RequestGuildMembers"] = 8] = "RequestGuildMembers";
    GatewayOpcodes2[GatewayOpcodes2["InvalidSession"] = 9] = "InvalidSession";
    GatewayOpcodes2[GatewayOpcodes2["Hello"] = 10] = "Hello";
    GatewayOpcodes2[GatewayOpcodes2["HeartbeatAck"] = 11] = "HeartbeatAck";
  })(GatewayOpcodes = exports.GatewayOpcodes || (exports.GatewayOpcodes = {}));
  var GatewayCloseCodes;
  (function(GatewayCloseCodes2) {
    GatewayCloseCodes2[GatewayCloseCodes2["UnknownError"] = 4000] = "UnknownError";
    GatewayCloseCodes2[GatewayCloseCodes2["UnknownOpcode"] = 4001] = "UnknownOpcode";
    GatewayCloseCodes2[GatewayCloseCodes2["DecodeError"] = 4002] = "DecodeError";
    GatewayCloseCodes2[GatewayCloseCodes2["NotAuthenticated"] = 4003] = "NotAuthenticated";
    GatewayCloseCodes2[GatewayCloseCodes2["AuthenticationFailed"] = 4004] = "AuthenticationFailed";
    GatewayCloseCodes2[GatewayCloseCodes2["AlreadyAuthenticated"] = 4005] = "AlreadyAuthenticated";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidSeq"] = 4007] = "InvalidSeq";
    GatewayCloseCodes2[GatewayCloseCodes2["RateLimited"] = 4008] = "RateLimited";
    GatewayCloseCodes2[GatewayCloseCodes2["SessionTimedOut"] = 4009] = "SessionTimedOut";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidShard"] = 4010] = "InvalidShard";
    GatewayCloseCodes2[GatewayCloseCodes2["ShardingRequired"] = 4011] = "ShardingRequired";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidAPIVersion"] = 4012] = "InvalidAPIVersion";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidIntents"] = 4013] = "InvalidIntents";
    GatewayCloseCodes2[GatewayCloseCodes2["DisallowedIntents"] = 4014] = "DisallowedIntents";
  })(GatewayCloseCodes = exports.GatewayCloseCodes || (exports.GatewayCloseCodes = {}));
  var GatewayIntentBits;
  (function(GatewayIntentBits2) {
    GatewayIntentBits2[GatewayIntentBits2["Guilds"] = 1] = "Guilds";
    GatewayIntentBits2[GatewayIntentBits2["GuildMembers"] = 2] = "GuildMembers";
    GatewayIntentBits2[GatewayIntentBits2["GuildModeration"] = 4] = "GuildModeration";
    GatewayIntentBits2[GatewayIntentBits2["GuildBans"] = 4] = "GuildBans";
    GatewayIntentBits2[GatewayIntentBits2["GuildEmojisAndStickers"] = 8] = "GuildEmojisAndStickers";
    GatewayIntentBits2[GatewayIntentBits2["GuildIntegrations"] = 16] = "GuildIntegrations";
    GatewayIntentBits2[GatewayIntentBits2["GuildWebhooks"] = 32] = "GuildWebhooks";
    GatewayIntentBits2[GatewayIntentBits2["GuildInvites"] = 64] = "GuildInvites";
    GatewayIntentBits2[GatewayIntentBits2["GuildVoiceStates"] = 128] = "GuildVoiceStates";
    GatewayIntentBits2[GatewayIntentBits2["GuildPresences"] = 256] = "GuildPresences";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessages"] = 512] = "GuildMessages";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessageReactions"] = 1024] = "GuildMessageReactions";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessageTyping"] = 2048] = "GuildMessageTyping";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessages"] = 4096] = "DirectMessages";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessageReactions"] = 8192] = "DirectMessageReactions";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessageTyping"] = 16384] = "DirectMessageTyping";
    GatewayIntentBits2[GatewayIntentBits2["MessageContent"] = 32768] = "MessageContent";
    GatewayIntentBits2[GatewayIntentBits2["GuildScheduledEvents"] = 65536] = "GuildScheduledEvents";
    GatewayIntentBits2[GatewayIntentBits2["AutoModerationConfiguration"] = 1048576] = "AutoModerationConfiguration";
    GatewayIntentBits2[GatewayIntentBits2["AutoModerationExecution"] = 2097152] = "AutoModerationExecution";
  })(GatewayIntentBits = exports.GatewayIntentBits || (exports.GatewayIntentBits = {}));
  var GatewayDispatchEvents;
  (function(GatewayDispatchEvents2) {
    GatewayDispatchEvents2["ApplicationCommandPermissionsUpdate"] = "APPLICATION_COMMAND_PERMISSIONS_UPDATE";
    GatewayDispatchEvents2["ChannelCreate"] = "CHANNEL_CREATE";
    GatewayDispatchEvents2["ChannelDelete"] = "CHANNEL_DELETE";
    GatewayDispatchEvents2["ChannelPinsUpdate"] = "CHANNEL_PINS_UPDATE";
    GatewayDispatchEvents2["ChannelUpdate"] = "CHANNEL_UPDATE";
    GatewayDispatchEvents2["GuildBanAdd"] = "GUILD_BAN_ADD";
    GatewayDispatchEvents2["GuildBanRemove"] = "GUILD_BAN_REMOVE";
    GatewayDispatchEvents2["GuildCreate"] = "GUILD_CREATE";
    GatewayDispatchEvents2["GuildDelete"] = "GUILD_DELETE";
    GatewayDispatchEvents2["GuildEmojisUpdate"] = "GUILD_EMOJIS_UPDATE";
    GatewayDispatchEvents2["GuildIntegrationsUpdate"] = "GUILD_INTEGRATIONS_UPDATE";
    GatewayDispatchEvents2["GuildMemberAdd"] = "GUILD_MEMBER_ADD";
    GatewayDispatchEvents2["GuildMemberRemove"] = "GUILD_MEMBER_REMOVE";
    GatewayDispatchEvents2["GuildMembersChunk"] = "GUILD_MEMBERS_CHUNK";
    GatewayDispatchEvents2["GuildMemberUpdate"] = "GUILD_MEMBER_UPDATE";
    GatewayDispatchEvents2["GuildRoleCreate"] = "GUILD_ROLE_CREATE";
    GatewayDispatchEvents2["GuildRoleDelete"] = "GUILD_ROLE_DELETE";
    GatewayDispatchEvents2["GuildRoleUpdate"] = "GUILD_ROLE_UPDATE";
    GatewayDispatchEvents2["GuildStickersUpdate"] = "GUILD_STICKERS_UPDATE";
    GatewayDispatchEvents2["GuildUpdate"] = "GUILD_UPDATE";
    GatewayDispatchEvents2["IntegrationCreate"] = "INTEGRATION_CREATE";
    GatewayDispatchEvents2["IntegrationDelete"] = "INTEGRATION_DELETE";
    GatewayDispatchEvents2["IntegrationUpdate"] = "INTEGRATION_UPDATE";
    GatewayDispatchEvents2["InteractionCreate"] = "INTERACTION_CREATE";
    GatewayDispatchEvents2["InviteCreate"] = "INVITE_CREATE";
    GatewayDispatchEvents2["InviteDelete"] = "INVITE_DELETE";
    GatewayDispatchEvents2["MessageCreate"] = "MESSAGE_CREATE";
    GatewayDispatchEvents2["MessageDelete"] = "MESSAGE_DELETE";
    GatewayDispatchEvents2["MessageDeleteBulk"] = "MESSAGE_DELETE_BULK";
    GatewayDispatchEvents2["MessageReactionAdd"] = "MESSAGE_REACTION_ADD";
    GatewayDispatchEvents2["MessageReactionRemove"] = "MESSAGE_REACTION_REMOVE";
    GatewayDispatchEvents2["MessageReactionRemoveAll"] = "MESSAGE_REACTION_REMOVE_ALL";
    GatewayDispatchEvents2["MessageReactionRemoveEmoji"] = "MESSAGE_REACTION_REMOVE_EMOJI";
    GatewayDispatchEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
    GatewayDispatchEvents2["PresenceUpdate"] = "PRESENCE_UPDATE";
    GatewayDispatchEvents2["StageInstanceCreate"] = "STAGE_INSTANCE_CREATE";
    GatewayDispatchEvents2["StageInstanceDelete"] = "STAGE_INSTANCE_DELETE";
    GatewayDispatchEvents2["StageInstanceUpdate"] = "STAGE_INSTANCE_UPDATE";
    GatewayDispatchEvents2["Ready"] = "READY";
    GatewayDispatchEvents2["Resumed"] = "RESUMED";
    GatewayDispatchEvents2["ThreadCreate"] = "THREAD_CREATE";
    GatewayDispatchEvents2["ThreadDelete"] = "THREAD_DELETE";
    GatewayDispatchEvents2["ThreadListSync"] = "THREAD_LIST_SYNC";
    GatewayDispatchEvents2["ThreadMembersUpdate"] = "THREAD_MEMBERS_UPDATE";
    GatewayDispatchEvents2["ThreadMemberUpdate"] = "THREAD_MEMBER_UPDATE";
    GatewayDispatchEvents2["ThreadUpdate"] = "THREAD_UPDATE";
    GatewayDispatchEvents2["TypingStart"] = "TYPING_START";
    GatewayDispatchEvents2["UserUpdate"] = "USER_UPDATE";
    GatewayDispatchEvents2["VoiceServerUpdate"] = "VOICE_SERVER_UPDATE";
    GatewayDispatchEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
    GatewayDispatchEvents2["WebhooksUpdate"] = "WEBHOOKS_UPDATE";
    GatewayDispatchEvents2["GuildScheduledEventCreate"] = "GUILD_SCHEDULED_EVENT_CREATE";
    GatewayDispatchEvents2["GuildScheduledEventUpdate"] = "GUILD_SCHEDULED_EVENT_UPDATE";
    GatewayDispatchEvents2["GuildScheduledEventDelete"] = "GUILD_SCHEDULED_EVENT_DELETE";
    GatewayDispatchEvents2["GuildScheduledEventUserAdd"] = "GUILD_SCHEDULED_EVENT_USER_ADD";
    GatewayDispatchEvents2["GuildScheduledEventUserRemove"] = "GUILD_SCHEDULED_EVENT_USER_REMOVE";
    GatewayDispatchEvents2["AutoModerationRuleCreate"] = "AUTO_MODERATION_RULE_CREATE";
    GatewayDispatchEvents2["AutoModerationRuleUpdate"] = "AUTO_MODERATION_RULE_UPDATE";
    GatewayDispatchEvents2["AutoModerationRuleDelete"] = "AUTO_MODERATION_RULE_DELETE";
    GatewayDispatchEvents2["AutoModerationActionExecution"] = "AUTO_MODERATION_ACTION_EXECUTION";
    GatewayDispatchEvents2["GuildAuditLogEntryCreate"] = "GUILD_AUDIT_LOG_ENTRY_CREATE";
    GatewayDispatchEvents2["EntitlementCreate"] = "ENTITLEMENT_CREATE";
    GatewayDispatchEvents2["EntitlementUpdate"] = "ENTITLEMENT_UPDATE";
    GatewayDispatchEvents2["EntitlementDelete"] = "ENTITLEMENT_DELETE";
  })(GatewayDispatchEvents = exports.GatewayDispatchEvents || (exports.GatewayDispatchEvents = {}));
});

// node_modules/discord-api-types/globals.js
var require_globals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FormattingPatterns = undefined;
  exports.FormattingPatterns = {
    User: /<@(?<id>\d{17,20})>/,
    UserWithNickname: /<@!(?<id>\d{17,20})>/,
    UserWithOptionalNickname: /<@!?(?<id>\d{17,20})>/,
    Channel: /<#(?<id>\d{17,20})>/,
    Role: /<@&(?<id>\d{17,20})>/,
    SlashCommand: /<\/(?<fullName>(?<name>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32})(?: (?<subcommandOrGroup>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?(?: (?<subcommand>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?):(?<id>\d{17,20})>/u,
    Emoji: /<(?<animated>a)?:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    AnimatedEmoji: /<(?<animated>a):(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    StaticEmoji: /<:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    Timestamp: /<t:(?<timestamp>-?\d{1,13})(:(?<style>[DFRTdft]))?>/,
    DefaultStyledTimestamp: /<t:(?<timestamp>-?\d{1,13})>/,
    StyledTimestamp: /<t:(?<timestamp>-?\d{1,13}):(?<style>[DFRTdft])>/
  };
  Object.freeze(exports.FormattingPatterns);
});

// node_modules/discord-api-types/payloads/common.js
var require_common2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PermissionFlagsBits = undefined;
  exports.PermissionFlagsBits = {
    CreateInstantInvite: 1n << 0n,
    KickMembers: 1n << 1n,
    BanMembers: 1n << 2n,
    Administrator: 1n << 3n,
    ManageChannels: 1n << 4n,
    ManageGuild: 1n << 5n,
    AddReactions: 1n << 6n,
    ViewAuditLog: 1n << 7n,
    PrioritySpeaker: 1n << 8n,
    Stream: 1n << 9n,
    ViewChannel: 1n << 10n,
    SendMessages: 1n << 11n,
    SendTTSMessages: 1n << 12n,
    ManageMessages: 1n << 13n,
    EmbedLinks: 1n << 14n,
    AttachFiles: 1n << 15n,
    ReadMessageHistory: 1n << 16n,
    MentionEveryone: 1n << 17n,
    UseExternalEmojis: 1n << 18n,
    ViewGuildInsights: 1n << 19n,
    Connect: 1n << 20n,
    Speak: 1n << 21n,
    MuteMembers: 1n << 22n,
    DeafenMembers: 1n << 23n,
    MoveMembers: 1n << 24n,
    UseVAD: 1n << 25n,
    ChangeNickname: 1n << 26n,
    ManageNicknames: 1n << 27n,
    ManageRoles: 1n << 28n,
    ManageWebhooks: 1n << 29n,
    ManageEmojisAndStickers: 1n << 30n,
    ManageGuildExpressions: 1n << 30n,
    UseApplicationCommands: 1n << 31n,
    RequestToSpeak: 1n << 32n,
    ManageEvents: 1n << 33n,
    ManageThreads: 1n << 34n,
    CreatePublicThreads: 1n << 35n,
    CreatePrivateThreads: 1n << 36n,
    UseExternalStickers: 1n << 37n,
    SendMessagesInThreads: 1n << 38n,
    UseEmbeddedActivities: 1n << 39n,
    ModerateMembers: 1n << 40n,
    ViewCreatorMonetizationAnalytics: 1n << 41n,
    UseSoundboard: 1n << 42n,
    UseExternalSounds: 1n << 45n,
    SendVoiceMessages: 1n << 46n
  };
  Object.freeze(exports.PermissionFlagsBits);
});

// node_modules/discord-api-types/payloads/v10/application.js
var require_application = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationRoleConnectionMetadataType = exports.ApplicationFlags = undefined;
  var ApplicationFlags;
  (function(ApplicationFlags2) {
    ApplicationFlags2[ApplicationFlags2["EmbeddedReleased"] = 2] = "EmbeddedReleased";
    ApplicationFlags2[ApplicationFlags2["ManagedEmoji"] = 4] = "ManagedEmoji";
    ApplicationFlags2[ApplicationFlags2["EmbeddedIAP"] = 8] = "EmbeddedIAP";
    ApplicationFlags2[ApplicationFlags2["GroupDMCreate"] = 16] = "GroupDMCreate";
    ApplicationFlags2[ApplicationFlags2["ApplicationAutoModerationRuleCreateBadge"] = 64] = "ApplicationAutoModerationRuleCreateBadge";
    ApplicationFlags2[ApplicationFlags2["RPCHasConnected"] = 2048] = "RPCHasConnected";
    ApplicationFlags2[ApplicationFlags2["GatewayPresence"] = 4096] = "GatewayPresence";
    ApplicationFlags2[ApplicationFlags2["GatewayPresenceLimited"] = 8192] = "GatewayPresenceLimited";
    ApplicationFlags2[ApplicationFlags2["GatewayGuildMembers"] = 16384] = "GatewayGuildMembers";
    ApplicationFlags2[ApplicationFlags2["GatewayGuildMembersLimited"] = 32768] = "GatewayGuildMembersLimited";
    ApplicationFlags2[ApplicationFlags2["VerificationPendingGuildLimit"] = 65536] = "VerificationPendingGuildLimit";
    ApplicationFlags2[ApplicationFlags2["Embedded"] = 131072] = "Embedded";
    ApplicationFlags2[ApplicationFlags2["GatewayMessageContent"] = 262144] = "GatewayMessageContent";
    ApplicationFlags2[ApplicationFlags2["GatewayMessageContentLimited"] = 524288] = "GatewayMessageContentLimited";
    ApplicationFlags2[ApplicationFlags2["EmbeddedFirstParty"] = 1048576] = "EmbeddedFirstParty";
    ApplicationFlags2[ApplicationFlags2["ApplicationCommandBadge"] = 8388608] = "ApplicationCommandBadge";
  })(ApplicationFlags = exports.ApplicationFlags || (exports.ApplicationFlags = {}));
  var ApplicationRoleConnectionMetadataType;
  (function(ApplicationRoleConnectionMetadataType2) {
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerLessThanOrEqual"] = 1] = "IntegerLessThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerGreaterThanOrEqual"] = 2] = "IntegerGreaterThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerEqual"] = 3] = "IntegerEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerNotEqual"] = 4] = "IntegerNotEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeLessThanOrEqual"] = 5] = "DatetimeLessThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeGreaterThanOrEqual"] = 6] = "DatetimeGreaterThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanEqual"] = 7] = "BooleanEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanNotEqual"] = 8] = "BooleanNotEqual";
  })(ApplicationRoleConnectionMetadataType = exports.ApplicationRoleConnectionMetadataType || (exports.ApplicationRoleConnectionMetadataType = {}));
});

// node_modules/discord-api-types/payloads/v10/auditLog.js
var require_auditLog = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AuditLogOptionsType = exports.AuditLogEvent = undefined;
  var AuditLogEvent;
  (function(AuditLogEvent2) {
    AuditLogEvent2[AuditLogEvent2["GuildUpdate"] = 1] = "GuildUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelCreate"] = 10] = "ChannelCreate";
    AuditLogEvent2[AuditLogEvent2["ChannelUpdate"] = 11] = "ChannelUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelDelete"] = 12] = "ChannelDelete";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteCreate"] = 13] = "ChannelOverwriteCreate";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteUpdate"] = 14] = "ChannelOverwriteUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteDelete"] = 15] = "ChannelOverwriteDelete";
    AuditLogEvent2[AuditLogEvent2["MemberKick"] = 20] = "MemberKick";
    AuditLogEvent2[AuditLogEvent2["MemberPrune"] = 21] = "MemberPrune";
    AuditLogEvent2[AuditLogEvent2["MemberBanAdd"] = 22] = "MemberBanAdd";
    AuditLogEvent2[AuditLogEvent2["MemberBanRemove"] = 23] = "MemberBanRemove";
    AuditLogEvent2[AuditLogEvent2["MemberUpdate"] = 24] = "MemberUpdate";
    AuditLogEvent2[AuditLogEvent2["MemberRoleUpdate"] = 25] = "MemberRoleUpdate";
    AuditLogEvent2[AuditLogEvent2["MemberMove"] = 26] = "MemberMove";
    AuditLogEvent2[AuditLogEvent2["MemberDisconnect"] = 27] = "MemberDisconnect";
    AuditLogEvent2[AuditLogEvent2["BotAdd"] = 28] = "BotAdd";
    AuditLogEvent2[AuditLogEvent2["RoleCreate"] = 30] = "RoleCreate";
    AuditLogEvent2[AuditLogEvent2["RoleUpdate"] = 31] = "RoleUpdate";
    AuditLogEvent2[AuditLogEvent2["RoleDelete"] = 32] = "RoleDelete";
    AuditLogEvent2[AuditLogEvent2["InviteCreate"] = 40] = "InviteCreate";
    AuditLogEvent2[AuditLogEvent2["InviteUpdate"] = 41] = "InviteUpdate";
    AuditLogEvent2[AuditLogEvent2["InviteDelete"] = 42] = "InviteDelete";
    AuditLogEvent2[AuditLogEvent2["WebhookCreate"] = 50] = "WebhookCreate";
    AuditLogEvent2[AuditLogEvent2["WebhookUpdate"] = 51] = "WebhookUpdate";
    AuditLogEvent2[AuditLogEvent2["WebhookDelete"] = 52] = "WebhookDelete";
    AuditLogEvent2[AuditLogEvent2["EmojiCreate"] = 60] = "EmojiCreate";
    AuditLogEvent2[AuditLogEvent2["EmojiUpdate"] = 61] = "EmojiUpdate";
    AuditLogEvent2[AuditLogEvent2["EmojiDelete"] = 62] = "EmojiDelete";
    AuditLogEvent2[AuditLogEvent2["MessageDelete"] = 72] = "MessageDelete";
    AuditLogEvent2[AuditLogEvent2["MessageBulkDelete"] = 73] = "MessageBulkDelete";
    AuditLogEvent2[AuditLogEvent2["MessagePin"] = 74] = "MessagePin";
    AuditLogEvent2[AuditLogEvent2["MessageUnpin"] = 75] = "MessageUnpin";
    AuditLogEvent2[AuditLogEvent2["IntegrationCreate"] = 80] = "IntegrationCreate";
    AuditLogEvent2[AuditLogEvent2["IntegrationUpdate"] = 81] = "IntegrationUpdate";
    AuditLogEvent2[AuditLogEvent2["IntegrationDelete"] = 82] = "IntegrationDelete";
    AuditLogEvent2[AuditLogEvent2["StageInstanceCreate"] = 83] = "StageInstanceCreate";
    AuditLogEvent2[AuditLogEvent2["StageInstanceUpdate"] = 84] = "StageInstanceUpdate";
    AuditLogEvent2[AuditLogEvent2["StageInstanceDelete"] = 85] = "StageInstanceDelete";
    AuditLogEvent2[AuditLogEvent2["StickerCreate"] = 90] = "StickerCreate";
    AuditLogEvent2[AuditLogEvent2["StickerUpdate"] = 91] = "StickerUpdate";
    AuditLogEvent2[AuditLogEvent2["StickerDelete"] = 92] = "StickerDelete";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventCreate"] = 100] = "GuildScheduledEventCreate";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventUpdate"] = 101] = "GuildScheduledEventUpdate";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventDelete"] = 102] = "GuildScheduledEventDelete";
    AuditLogEvent2[AuditLogEvent2["ThreadCreate"] = 110] = "ThreadCreate";
    AuditLogEvent2[AuditLogEvent2["ThreadUpdate"] = 111] = "ThreadUpdate";
    AuditLogEvent2[AuditLogEvent2["ThreadDelete"] = 112] = "ThreadDelete";
    AuditLogEvent2[AuditLogEvent2["ApplicationCommandPermissionUpdate"] = 121] = "ApplicationCommandPermissionUpdate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleCreate"] = 140] = "AutoModerationRuleCreate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleUpdate"] = 141] = "AutoModerationRuleUpdate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleDelete"] = 142] = "AutoModerationRuleDelete";
    AuditLogEvent2[AuditLogEvent2["AutoModerationBlockMessage"] = 143] = "AutoModerationBlockMessage";
    AuditLogEvent2[AuditLogEvent2["AutoModerationFlagToChannel"] = 144] = "AutoModerationFlagToChannel";
    AuditLogEvent2[AuditLogEvent2["AutoModerationUserCommunicationDisabled"] = 145] = "AutoModerationUserCommunicationDisabled";
    AuditLogEvent2[AuditLogEvent2["CreatorMonetizationRequestCreated"] = 150] = "CreatorMonetizationRequestCreated";
    AuditLogEvent2[AuditLogEvent2["CreatorMonetizationTermsAccepted"] = 151] = "CreatorMonetizationTermsAccepted";
  })(AuditLogEvent = exports.AuditLogEvent || (exports.AuditLogEvent = {}));
  var AuditLogOptionsType;
  (function(AuditLogOptionsType2) {
    AuditLogOptionsType2["Role"] = "0";
    AuditLogOptionsType2["Member"] = "1";
  })(AuditLogOptionsType = exports.AuditLogOptionsType || (exports.AuditLogOptionsType = {}));
});

// node_modules/discord-api-types/payloads/v10/autoModeration.js
var require_autoModeration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AutoModerationActionType = exports.AutoModerationRuleEventType = exports.AutoModerationRuleKeywordPresetType = exports.AutoModerationRuleTriggerType = undefined;
  var AutoModerationRuleTriggerType;
  (function(AutoModerationRuleTriggerType2) {
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Keyword"] = 1] = "Keyword";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Spam"] = 3] = "Spam";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["KeywordPreset"] = 4] = "KeywordPreset";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MentionSpam"] = 5] = "MentionSpam";
  })(AutoModerationRuleTriggerType = exports.AutoModerationRuleTriggerType || (exports.AutoModerationRuleTriggerType = {}));
  var AutoModerationRuleKeywordPresetType;
  (function(AutoModerationRuleKeywordPresetType2) {
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Profanity"] = 1] = "Profanity";
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["SexualContent"] = 2] = "SexualContent";
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Slurs"] = 3] = "Slurs";
  })(AutoModerationRuleKeywordPresetType = exports.AutoModerationRuleKeywordPresetType || (exports.AutoModerationRuleKeywordPresetType = {}));
  var AutoModerationRuleEventType;
  (function(AutoModerationRuleEventType2) {
    AutoModerationRuleEventType2[AutoModerationRuleEventType2["MessageSend"] = 1] = "MessageSend";
  })(AutoModerationRuleEventType = exports.AutoModerationRuleEventType || (exports.AutoModerationRuleEventType = {}));
  var AutoModerationActionType;
  (function(AutoModerationActionType2) {
    AutoModerationActionType2[AutoModerationActionType2["BlockMessage"] = 1] = "BlockMessage";
    AutoModerationActionType2[AutoModerationActionType2["SendAlertMessage"] = 2] = "SendAlertMessage";
    AutoModerationActionType2[AutoModerationActionType2["Timeout"] = 3] = "Timeout";
  })(AutoModerationActionType = exports.AutoModerationActionType || (exports.AutoModerationActionType = {}));
});

// node_modules/discord-api-types/payloads/v10/channel.js
var require_channel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChannelFlags = exports.SelectMenuDefaultValueType = exports.TextInputStyle = exports.ButtonStyle = exports.ComponentType = exports.AllowedMentionsTypes = exports.AttachmentFlags = exports.EmbedType = exports.ThreadMemberFlags = exports.ThreadAutoArchiveDuration = exports.OverwriteType = exports.MessageFlags = exports.MessageActivityType = exports.MessageType = exports.VideoQualityMode = exports.ChannelType = exports.ForumLayoutType = exports.SortOrderType = undefined;
  var SortOrderType;
  (function(SortOrderType2) {
    SortOrderType2[SortOrderType2["LatestActivity"] = 0] = "LatestActivity";
    SortOrderType2[SortOrderType2["CreationDate"] = 1] = "CreationDate";
  })(SortOrderType = exports.SortOrderType || (exports.SortOrderType = {}));
  var ForumLayoutType;
  (function(ForumLayoutType2) {
    ForumLayoutType2[ForumLayoutType2["NotSet"] = 0] = "NotSet";
    ForumLayoutType2[ForumLayoutType2["ListView"] = 1] = "ListView";
    ForumLayoutType2[ForumLayoutType2["GalleryView"] = 2] = "GalleryView";
  })(ForumLayoutType = exports.ForumLayoutType || (exports.ForumLayoutType = {}));
  var ChannelType;
  (function(ChannelType2) {
    ChannelType2[ChannelType2["GuildText"] = 0] = "GuildText";
    ChannelType2[ChannelType2["DM"] = 1] = "DM";
    ChannelType2[ChannelType2["GuildVoice"] = 2] = "GuildVoice";
    ChannelType2[ChannelType2["GroupDM"] = 3] = "GroupDM";
    ChannelType2[ChannelType2["GuildCategory"] = 4] = "GuildCategory";
    ChannelType2[ChannelType2["GuildAnnouncement"] = 5] = "GuildAnnouncement";
    ChannelType2[ChannelType2["AnnouncementThread"] = 10] = "AnnouncementThread";
    ChannelType2[ChannelType2["PublicThread"] = 11] = "PublicThread";
    ChannelType2[ChannelType2["PrivateThread"] = 12] = "PrivateThread";
    ChannelType2[ChannelType2["GuildStageVoice"] = 13] = "GuildStageVoice";
    ChannelType2[ChannelType2["GuildDirectory"] = 14] = "GuildDirectory";
    ChannelType2[ChannelType2["GuildForum"] = 15] = "GuildForum";
    ChannelType2[ChannelType2["GuildMedia"] = 16] = "GuildMedia";
    ChannelType2[ChannelType2["GuildNews"] = 5] = "GuildNews";
    ChannelType2[ChannelType2["GuildNewsThread"] = 10] = "GuildNewsThread";
    ChannelType2[ChannelType2["GuildPublicThread"] = 11] = "GuildPublicThread";
    ChannelType2[ChannelType2["GuildPrivateThread"] = 12] = "GuildPrivateThread";
  })(ChannelType = exports.ChannelType || (exports.ChannelType = {}));
  var VideoQualityMode;
  (function(VideoQualityMode2) {
    VideoQualityMode2[VideoQualityMode2["Auto"] = 1] = "Auto";
    VideoQualityMode2[VideoQualityMode2["Full"] = 2] = "Full";
  })(VideoQualityMode = exports.VideoQualityMode || (exports.VideoQualityMode = {}));
  var MessageType;
  (function(MessageType2) {
    MessageType2[MessageType2["Default"] = 0] = "Default";
    MessageType2[MessageType2["RecipientAdd"] = 1] = "RecipientAdd";
    MessageType2[MessageType2["RecipientRemove"] = 2] = "RecipientRemove";
    MessageType2[MessageType2["Call"] = 3] = "Call";
    MessageType2[MessageType2["ChannelNameChange"] = 4] = "ChannelNameChange";
    MessageType2[MessageType2["ChannelIconChange"] = 5] = "ChannelIconChange";
    MessageType2[MessageType2["ChannelPinnedMessage"] = 6] = "ChannelPinnedMessage";
    MessageType2[MessageType2["UserJoin"] = 7] = "UserJoin";
    MessageType2[MessageType2["GuildBoost"] = 8] = "GuildBoost";
    MessageType2[MessageType2["GuildBoostTier1"] = 9] = "GuildBoostTier1";
    MessageType2[MessageType2["GuildBoostTier2"] = 10] = "GuildBoostTier2";
    MessageType2[MessageType2["GuildBoostTier3"] = 11] = "GuildBoostTier3";
    MessageType2[MessageType2["ChannelFollowAdd"] = 12] = "ChannelFollowAdd";
    MessageType2[MessageType2["GuildDiscoveryDisqualified"] = 14] = "GuildDiscoveryDisqualified";
    MessageType2[MessageType2["GuildDiscoveryRequalified"] = 15] = "GuildDiscoveryRequalified";
    MessageType2[MessageType2["GuildDiscoveryGracePeriodInitialWarning"] = 16] = "GuildDiscoveryGracePeriodInitialWarning";
    MessageType2[MessageType2["GuildDiscoveryGracePeriodFinalWarning"] = 17] = "GuildDiscoveryGracePeriodFinalWarning";
    MessageType2[MessageType2["ThreadCreated"] = 18] = "ThreadCreated";
    MessageType2[MessageType2["Reply"] = 19] = "Reply";
    MessageType2[MessageType2["ChatInputCommand"] = 20] = "ChatInputCommand";
    MessageType2[MessageType2["ThreadStarterMessage"] = 21] = "ThreadStarterMessage";
    MessageType2[MessageType2["GuildInviteReminder"] = 22] = "GuildInviteReminder";
    MessageType2[MessageType2["ContextMenuCommand"] = 23] = "ContextMenuCommand";
    MessageType2[MessageType2["AutoModerationAction"] = 24] = "AutoModerationAction";
    MessageType2[MessageType2["RoleSubscriptionPurchase"] = 25] = "RoleSubscriptionPurchase";
    MessageType2[MessageType2["InteractionPremiumUpsell"] = 26] = "InteractionPremiumUpsell";
    MessageType2[MessageType2["StageStart"] = 27] = "StageStart";
    MessageType2[MessageType2["StageEnd"] = 28] = "StageEnd";
    MessageType2[MessageType2["StageSpeaker"] = 29] = "StageSpeaker";
    MessageType2[MessageType2["StageRaiseHand"] = 30] = "StageRaiseHand";
    MessageType2[MessageType2["StageTopic"] = 31] = "StageTopic";
    MessageType2[MessageType2["GuildApplicationPremiumSubscription"] = 32] = "GuildApplicationPremiumSubscription";
  })(MessageType = exports.MessageType || (exports.MessageType = {}));
  var MessageActivityType;
  (function(MessageActivityType2) {
    MessageActivityType2[MessageActivityType2["Join"] = 1] = "Join";
    MessageActivityType2[MessageActivityType2["Spectate"] = 2] = "Spectate";
    MessageActivityType2[MessageActivityType2["Listen"] = 3] = "Listen";
    MessageActivityType2[MessageActivityType2["JoinRequest"] = 5] = "JoinRequest";
  })(MessageActivityType = exports.MessageActivityType || (exports.MessageActivityType = {}));
  var MessageFlags;
  (function(MessageFlags2) {
    MessageFlags2[MessageFlags2["Crossposted"] = 1] = "Crossposted";
    MessageFlags2[MessageFlags2["IsCrosspost"] = 2] = "IsCrosspost";
    MessageFlags2[MessageFlags2["SuppressEmbeds"] = 4] = "SuppressEmbeds";
    MessageFlags2[MessageFlags2["SourceMessageDeleted"] = 8] = "SourceMessageDeleted";
    MessageFlags2[MessageFlags2["Urgent"] = 16] = "Urgent";
    MessageFlags2[MessageFlags2["HasThread"] = 32] = "HasThread";
    MessageFlags2[MessageFlags2["Ephemeral"] = 64] = "Ephemeral";
    MessageFlags2[MessageFlags2["Loading"] = 128] = "Loading";
    MessageFlags2[MessageFlags2["FailedToMentionSomeRolesInThread"] = 256] = "FailedToMentionSomeRolesInThread";
    MessageFlags2[MessageFlags2["ShouldShowLinkNotDiscordWarning"] = 1024] = "ShouldShowLinkNotDiscordWarning";
    MessageFlags2[MessageFlags2["SuppressNotifications"] = 4096] = "SuppressNotifications";
    MessageFlags2[MessageFlags2["IsVoiceMessage"] = 8192] = "IsVoiceMessage";
  })(MessageFlags = exports.MessageFlags || (exports.MessageFlags = {}));
  var OverwriteType;
  (function(OverwriteType2) {
    OverwriteType2[OverwriteType2["Role"] = 0] = "Role";
    OverwriteType2[OverwriteType2["Member"] = 1] = "Member";
  })(OverwriteType = exports.OverwriteType || (exports.OverwriteType = {}));
  var ThreadAutoArchiveDuration;
  (function(ThreadAutoArchiveDuration2) {
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneHour"] = 60] = "OneHour";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneDay"] = 1440] = "OneDay";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["ThreeDays"] = 4320] = "ThreeDays";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneWeek"] = 10080] = "OneWeek";
  })(ThreadAutoArchiveDuration = exports.ThreadAutoArchiveDuration || (exports.ThreadAutoArchiveDuration = {}));
  var ThreadMemberFlags;
  (function(ThreadMemberFlags2) {
    ThreadMemberFlags2[ThreadMemberFlags2["HasInteracted"] = 1] = "HasInteracted";
    ThreadMemberFlags2[ThreadMemberFlags2["AllMessages"] = 2] = "AllMessages";
    ThreadMemberFlags2[ThreadMemberFlags2["OnlyMentions"] = 4] = "OnlyMentions";
    ThreadMemberFlags2[ThreadMemberFlags2["NoMessages"] = 8] = "NoMessages";
  })(ThreadMemberFlags = exports.ThreadMemberFlags || (exports.ThreadMemberFlags = {}));
  var EmbedType;
  (function(EmbedType2) {
    EmbedType2["Rich"] = "rich";
    EmbedType2["Image"] = "image";
    EmbedType2["Video"] = "video";
    EmbedType2["GIFV"] = "gifv";
    EmbedType2["Article"] = "article";
    EmbedType2["Link"] = "link";
    EmbedType2["AutoModerationMessage"] = "auto_moderation_message";
  })(EmbedType = exports.EmbedType || (exports.EmbedType = {}));
  var AttachmentFlags;
  (function(AttachmentFlags2) {
    AttachmentFlags2[AttachmentFlags2["IsRemix"] = 4] = "IsRemix";
  })(AttachmentFlags = exports.AttachmentFlags || (exports.AttachmentFlags = {}));
  var AllowedMentionsTypes;
  (function(AllowedMentionsTypes2) {
    AllowedMentionsTypes2["Everyone"] = "everyone";
    AllowedMentionsTypes2["Role"] = "roles";
    AllowedMentionsTypes2["User"] = "users";
  })(AllowedMentionsTypes = exports.AllowedMentionsTypes || (exports.AllowedMentionsTypes = {}));
  var ComponentType;
  (function(ComponentType2) {
    ComponentType2[ComponentType2["ActionRow"] = 1] = "ActionRow";
    ComponentType2[ComponentType2["Button"] = 2] = "Button";
    ComponentType2[ComponentType2["StringSelect"] = 3] = "StringSelect";
    ComponentType2[ComponentType2["TextInput"] = 4] = "TextInput";
    ComponentType2[ComponentType2["UserSelect"] = 5] = "UserSelect";
    ComponentType2[ComponentType2["RoleSelect"] = 6] = "RoleSelect";
    ComponentType2[ComponentType2["MentionableSelect"] = 7] = "MentionableSelect";
    ComponentType2[ComponentType2["ChannelSelect"] = 8] = "ChannelSelect";
    ComponentType2[ComponentType2["SelectMenu"] = 3] = "SelectMenu";
  })(ComponentType = exports.ComponentType || (exports.ComponentType = {}));
  var ButtonStyle;
  (function(ButtonStyle2) {
    ButtonStyle2[ButtonStyle2["Primary"] = 1] = "Primary";
    ButtonStyle2[ButtonStyle2["Secondary"] = 2] = "Secondary";
    ButtonStyle2[ButtonStyle2["Success"] = 3] = "Success";
    ButtonStyle2[ButtonStyle2["Danger"] = 4] = "Danger";
    ButtonStyle2[ButtonStyle2["Link"] = 5] = "Link";
  })(ButtonStyle = exports.ButtonStyle || (exports.ButtonStyle = {}));
  var TextInputStyle;
  (function(TextInputStyle2) {
    TextInputStyle2[TextInputStyle2["Short"] = 1] = "Short";
    TextInputStyle2[TextInputStyle2["Paragraph"] = 2] = "Paragraph";
  })(TextInputStyle = exports.TextInputStyle || (exports.TextInputStyle = {}));
  var SelectMenuDefaultValueType;
  (function(SelectMenuDefaultValueType2) {
    SelectMenuDefaultValueType2["Channel"] = "channel";
    SelectMenuDefaultValueType2["Role"] = "role";
    SelectMenuDefaultValueType2["User"] = "user";
  })(SelectMenuDefaultValueType = exports.SelectMenuDefaultValueType || (exports.SelectMenuDefaultValueType = {}));
  var ChannelFlags;
  (function(ChannelFlags2) {
    ChannelFlags2[ChannelFlags2["GuildFeedRemoved"] = 1] = "GuildFeedRemoved";
    ChannelFlags2[ChannelFlags2["Pinned"] = 2] = "Pinned";
    ChannelFlags2[ChannelFlags2["ActiveChannelsRemoved"] = 4] = "ActiveChannelsRemoved";
    ChannelFlags2[ChannelFlags2["RequireTag"] = 16] = "RequireTag";
    ChannelFlags2[ChannelFlags2["IsSpam"] = 32] = "IsSpam";
    ChannelFlags2[ChannelFlags2["IsGuildResourceChannel"] = 128] = "IsGuildResourceChannel";
    ChannelFlags2[ChannelFlags2["ClydeAI"] = 256] = "ClydeAI";
    ChannelFlags2[ChannelFlags2["IsScheduledForDeletion"] = 512] = "IsScheduledForDeletion";
    ChannelFlags2[ChannelFlags2["HideMediaDownloadOptions"] = 32768] = "HideMediaDownloadOptions";
  })(ChannelFlags = exports.ChannelFlags || (exports.ChannelFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/emoji.js
var require_emoji = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/gateway.js
var require_gateway = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ActivityFlags = exports.ActivityType = exports.ActivityPlatform = exports.PresenceUpdateStatus = undefined;
  var PresenceUpdateStatus;
  (function(PresenceUpdateStatus2) {
    PresenceUpdateStatus2["Online"] = "online";
    PresenceUpdateStatus2["DoNotDisturb"] = "dnd";
    PresenceUpdateStatus2["Idle"] = "idle";
    PresenceUpdateStatus2["Invisible"] = "invisible";
    PresenceUpdateStatus2["Offline"] = "offline";
  })(PresenceUpdateStatus = exports.PresenceUpdateStatus || (exports.PresenceUpdateStatus = {}));
  var ActivityPlatform;
  (function(ActivityPlatform2) {
    ActivityPlatform2["Desktop"] = "desktop";
    ActivityPlatform2["Xbox"] = "xbox";
    ActivityPlatform2["Samsung"] = "samsung";
    ActivityPlatform2["IOS"] = "ios";
    ActivityPlatform2["Android"] = "android";
    ActivityPlatform2["Embedded"] = "embedded";
    ActivityPlatform2["PS4"] = "ps4";
    ActivityPlatform2["PS5"] = "ps5";
  })(ActivityPlatform = exports.ActivityPlatform || (exports.ActivityPlatform = {}));
  var ActivityType;
  (function(ActivityType2) {
    ActivityType2[ActivityType2["Playing"] = 0] = "Playing";
    ActivityType2[ActivityType2["Streaming"] = 1] = "Streaming";
    ActivityType2[ActivityType2["Listening"] = 2] = "Listening";
    ActivityType2[ActivityType2["Watching"] = 3] = "Watching";
    ActivityType2[ActivityType2["Custom"] = 4] = "Custom";
    ActivityType2[ActivityType2["Competing"] = 5] = "Competing";
  })(ActivityType = exports.ActivityType || (exports.ActivityType = {}));
  var ActivityFlags;
  (function(ActivityFlags2) {
    ActivityFlags2[ActivityFlags2["Instance"] = 1] = "Instance";
    ActivityFlags2[ActivityFlags2["Join"] = 2] = "Join";
    ActivityFlags2[ActivityFlags2["Spectate"] = 4] = "Spectate";
    ActivityFlags2[ActivityFlags2["JoinRequest"] = 8] = "JoinRequest";
    ActivityFlags2[ActivityFlags2["Sync"] = 16] = "Sync";
    ActivityFlags2[ActivityFlags2["Play"] = 32] = "Play";
    ActivityFlags2[ActivityFlags2["PartyPrivacyFriends"] = 64] = "PartyPrivacyFriends";
    ActivityFlags2[ActivityFlags2["PartyPrivacyVoiceChannel"] = 128] = "PartyPrivacyVoiceChannel";
    ActivityFlags2[ActivityFlags2["Embedded"] = 256] = "Embedded";
  })(ActivityFlags = exports.ActivityFlags || (exports.ActivityFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/guild.js
var require_guild = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GuildOnboardingPromptType = exports.GuildOnboardingMode = exports.MembershipScreeningFieldType = exports.GuildWidgetStyle = exports.IntegrationExpireBehavior = exports.GuildMemberFlags = exports.GuildFeature = exports.GuildSystemChannelFlags = exports.GuildHubType = exports.GuildPremiumTier = exports.GuildVerificationLevel = exports.GuildNSFWLevel = exports.GuildMFALevel = exports.GuildExplicitContentFilter = exports.GuildDefaultMessageNotifications = undefined;
  var GuildDefaultMessageNotifications;
  (function(GuildDefaultMessageNotifications2) {
    GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["AllMessages"] = 0] = "AllMessages";
    GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["OnlyMentions"] = 1] = "OnlyMentions";
  })(GuildDefaultMessageNotifications = exports.GuildDefaultMessageNotifications || (exports.GuildDefaultMessageNotifications = {}));
  var GuildExplicitContentFilter;
  (function(GuildExplicitContentFilter2) {
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["Disabled"] = 0] = "Disabled";
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["MembersWithoutRoles"] = 1] = "MembersWithoutRoles";
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["AllMembers"] = 2] = "AllMembers";
  })(GuildExplicitContentFilter = exports.GuildExplicitContentFilter || (exports.GuildExplicitContentFilter = {}));
  var GuildMFALevel;
  (function(GuildMFALevel2) {
    GuildMFALevel2[GuildMFALevel2["None"] = 0] = "None";
    GuildMFALevel2[GuildMFALevel2["Elevated"] = 1] = "Elevated";
  })(GuildMFALevel = exports.GuildMFALevel || (exports.GuildMFALevel = {}));
  var GuildNSFWLevel;
  (function(GuildNSFWLevel2) {
    GuildNSFWLevel2[GuildNSFWLevel2["Default"] = 0] = "Default";
    GuildNSFWLevel2[GuildNSFWLevel2["Explicit"] = 1] = "Explicit";
    GuildNSFWLevel2[GuildNSFWLevel2["Safe"] = 2] = "Safe";
    GuildNSFWLevel2[GuildNSFWLevel2["AgeRestricted"] = 3] = "AgeRestricted";
  })(GuildNSFWLevel = exports.GuildNSFWLevel || (exports.GuildNSFWLevel = {}));
  var GuildVerificationLevel;
  (function(GuildVerificationLevel2) {
    GuildVerificationLevel2[GuildVerificationLevel2["None"] = 0] = "None";
    GuildVerificationLevel2[GuildVerificationLevel2["Low"] = 1] = "Low";
    GuildVerificationLevel2[GuildVerificationLevel2["Medium"] = 2] = "Medium";
    GuildVerificationLevel2[GuildVerificationLevel2["High"] = 3] = "High";
    GuildVerificationLevel2[GuildVerificationLevel2["VeryHigh"] = 4] = "VeryHigh";
  })(GuildVerificationLevel = exports.GuildVerificationLevel || (exports.GuildVerificationLevel = {}));
  var GuildPremiumTier;
  (function(GuildPremiumTier2) {
    GuildPremiumTier2[GuildPremiumTier2["None"] = 0] = "None";
    GuildPremiumTier2[GuildPremiumTier2["Tier1"] = 1] = "Tier1";
    GuildPremiumTier2[GuildPremiumTier2["Tier2"] = 2] = "Tier2";
    GuildPremiumTier2[GuildPremiumTier2["Tier3"] = 3] = "Tier3";
  })(GuildPremiumTier = exports.GuildPremiumTier || (exports.GuildPremiumTier = {}));
  var GuildHubType;
  (function(GuildHubType2) {
    GuildHubType2[GuildHubType2["Default"] = 0] = "Default";
    GuildHubType2[GuildHubType2["HighSchool"] = 1] = "HighSchool";
    GuildHubType2[GuildHubType2["College"] = 2] = "College";
  })(GuildHubType = exports.GuildHubType || (exports.GuildHubType = {}));
  var GuildSystemChannelFlags;
  (function(GuildSystemChannelFlags2) {
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotifications"] = 1] = "SuppressJoinNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressPremiumSubscriptions"] = 2] = "SuppressPremiumSubscriptions";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressGuildReminderNotifications"] = 4] = "SuppressGuildReminderNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotificationReplies"] = 8] = "SuppressJoinNotificationReplies";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotifications"] = 16] = "SuppressRoleSubscriptionPurchaseNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotificationReplies"] = 32] = "SuppressRoleSubscriptionPurchaseNotificationReplies";
  })(GuildSystemChannelFlags = exports.GuildSystemChannelFlags || (exports.GuildSystemChannelFlags = {}));
  var GuildFeature;
  (function(GuildFeature2) {
    GuildFeature2["AnimatedBanner"] = "ANIMATED_BANNER";
    GuildFeature2["AnimatedIcon"] = "ANIMATED_ICON";
    GuildFeature2["ApplicationCommandPermissionsV2"] = "APPLICATION_COMMAND_PERMISSIONS_V2";
    GuildFeature2["AutoModeration"] = "AUTO_MODERATION";
    GuildFeature2["Banner"] = "BANNER";
    GuildFeature2["Community"] = "COMMUNITY";
    GuildFeature2["CreatorMonetizableProvisional"] = "CREATOR_MONETIZABLE_PROVISIONAL";
    GuildFeature2["CreatorStorePage"] = "CREATOR_STORE_PAGE";
    GuildFeature2["DeveloperSupportServer"] = "DEVELOPER_SUPPORT_SERVER";
    GuildFeature2["Discoverable"] = "DISCOVERABLE";
    GuildFeature2["Featurable"] = "FEATURABLE";
    GuildFeature2["HasDirectoryEntry"] = "HAS_DIRECTORY_ENTRY";
    GuildFeature2["Hub"] = "HUB";
    GuildFeature2["InvitesDisabled"] = "INVITES_DISABLED";
    GuildFeature2["InviteSplash"] = "INVITE_SPLASH";
    GuildFeature2["LinkedToHub"] = "LINKED_TO_HUB";
    GuildFeature2["MemberVerificationGateEnabled"] = "MEMBER_VERIFICATION_GATE_ENABLED";
    GuildFeature2["MonetizationEnabled"] = "MONETIZATION_ENABLED";
    GuildFeature2["MoreStickers"] = "MORE_STICKERS";
    GuildFeature2["News"] = "NEWS";
    GuildFeature2["Partnered"] = "PARTNERED";
    GuildFeature2["PreviewEnabled"] = "PREVIEW_ENABLED";
    GuildFeature2["PrivateThreads"] = "PRIVATE_THREADS";
    GuildFeature2["RaidAlertsDisabled"] = "RAID_ALERTS_DISABLED";
    GuildFeature2["RelayEnabled"] = "RELAY_ENABLED";
    GuildFeature2["RoleIcons"] = "ROLE_ICONS";
    GuildFeature2["RoleSubscriptionsAvailableForPurchase"] = "ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE";
    GuildFeature2["RoleSubscriptionsEnabled"] = "ROLE_SUBSCRIPTIONS_ENABLED";
    GuildFeature2["TicketedEventsEnabled"] = "TICKETED_EVENTS_ENABLED";
    GuildFeature2["VanityURL"] = "VANITY_URL";
    GuildFeature2["Verified"] = "VERIFIED";
    GuildFeature2["VIPRegions"] = "VIP_REGIONS";
    GuildFeature2["WelcomeScreenEnabled"] = "WELCOME_SCREEN_ENABLED";
  })(GuildFeature = exports.GuildFeature || (exports.GuildFeature = {}));
  var GuildMemberFlags;
  (function(GuildMemberFlags2) {
    GuildMemberFlags2[GuildMemberFlags2["DidRejoin"] = 1] = "DidRejoin";
    GuildMemberFlags2[GuildMemberFlags2["CompletedOnboarding"] = 2] = "CompletedOnboarding";
    GuildMemberFlags2[GuildMemberFlags2["BypassesVerification"] = 4] = "BypassesVerification";
    GuildMemberFlags2[GuildMemberFlags2["StartedOnboarding"] = 8] = "StartedOnboarding";
    GuildMemberFlags2[GuildMemberFlags2["StartedHomeActions"] = 32] = "StartedHomeActions";
    GuildMemberFlags2[GuildMemberFlags2["CompletedHomeActions"] = 64] = "CompletedHomeActions";
    GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedUsernameOrGuildNickname"] = 128] = "AutomodQuarantinedUsernameOrGuildNickname";
    GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedBio"] = 256] = "AutomodQuarantinedBio";
  })(GuildMemberFlags = exports.GuildMemberFlags || (exports.GuildMemberFlags = {}));
  var IntegrationExpireBehavior;
  (function(IntegrationExpireBehavior2) {
    IntegrationExpireBehavior2[IntegrationExpireBehavior2["RemoveRole"] = 0] = "RemoveRole";
    IntegrationExpireBehavior2[IntegrationExpireBehavior2["Kick"] = 1] = "Kick";
  })(IntegrationExpireBehavior = exports.IntegrationExpireBehavior || (exports.IntegrationExpireBehavior = {}));
  var GuildWidgetStyle;
  (function(GuildWidgetStyle2) {
    GuildWidgetStyle2["Shield"] = "shield";
    GuildWidgetStyle2["Banner1"] = "banner1";
    GuildWidgetStyle2["Banner2"] = "banner2";
    GuildWidgetStyle2["Banner3"] = "banner3";
    GuildWidgetStyle2["Banner4"] = "banner4";
  })(GuildWidgetStyle = exports.GuildWidgetStyle || (exports.GuildWidgetStyle = {}));
  var MembershipScreeningFieldType;
  (function(MembershipScreeningFieldType2) {
    MembershipScreeningFieldType2["Terms"] = "TERMS";
  })(MembershipScreeningFieldType = exports.MembershipScreeningFieldType || (exports.MembershipScreeningFieldType = {}));
  var GuildOnboardingMode;
  (function(GuildOnboardingMode2) {
    GuildOnboardingMode2[GuildOnboardingMode2["OnboardingDefault"] = 0] = "OnboardingDefault";
    GuildOnboardingMode2[GuildOnboardingMode2["OnboardingAdvanced"] = 1] = "OnboardingAdvanced";
  })(GuildOnboardingMode = exports.GuildOnboardingMode || (exports.GuildOnboardingMode = {}));
  var GuildOnboardingPromptType;
  (function(GuildOnboardingPromptType2) {
    GuildOnboardingPromptType2[GuildOnboardingPromptType2["MultipleChoice"] = 0] = "MultipleChoice";
    GuildOnboardingPromptType2[GuildOnboardingPromptType2["Dropdown"] = 1] = "Dropdown";
  })(GuildOnboardingPromptType = exports.GuildOnboardingPromptType || (exports.GuildOnboardingPromptType = {}));
});

// node_modules/discord-api-types/payloads/v10/guildScheduledEvent.js
var require_guildScheduledEvent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GuildScheduledEventPrivacyLevel = exports.GuildScheduledEventStatus = exports.GuildScheduledEventEntityType = undefined;
  var GuildScheduledEventEntityType;
  (function(GuildScheduledEventEntityType2) {
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["StageInstance"] = 1] = "StageInstance";
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["Voice"] = 2] = "Voice";
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["External"] = 3] = "External";
  })(GuildScheduledEventEntityType = exports.GuildScheduledEventEntityType || (exports.GuildScheduledEventEntityType = {}));
  var GuildScheduledEventStatus;
  (function(GuildScheduledEventStatus2) {
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Scheduled"] = 1] = "Scheduled";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Active"] = 2] = "Active";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Completed"] = 3] = "Completed";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Canceled"] = 4] = "Canceled";
  })(GuildScheduledEventStatus = exports.GuildScheduledEventStatus || (exports.GuildScheduledEventStatus = {}));
  var GuildScheduledEventPrivacyLevel;
  (function(GuildScheduledEventPrivacyLevel2) {
    GuildScheduledEventPrivacyLevel2[GuildScheduledEventPrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
  })(GuildScheduledEventPrivacyLevel = exports.GuildScheduledEventPrivacyLevel || (exports.GuildScheduledEventPrivacyLevel = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/attachment.js
var require_attachment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/base.js
var require_base = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/boolean.js
var require_boolean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/channel.js
var require_channel2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/integer.js
var require_integer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/mentionable.js
var require_mentionable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/number.js
var require_number = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/role.js
var require_role = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/shared.js
var require_shared = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationCommandOptionType = undefined;
  var ApplicationCommandOptionType;
  (function(ApplicationCommandOptionType2) {
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Subcommand"] = 1] = "Subcommand";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["SubcommandGroup"] = 2] = "SubcommandGroup";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["String"] = 3] = "String";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Integer"] = 4] = "Integer";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Boolean"] = 5] = "Boolean";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["User"] = 6] = "User";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Channel"] = 7] = "Channel";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Role"] = 8] = "Role";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Mentionable"] = 9] = "Mentionable";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Number"] = 10] = "Number";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Attachment"] = 11] = "Attachment";
  })(ApplicationCommandOptionType = exports.ApplicationCommandOptionType || (exports.ApplicationCommandOptionType = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/string.js
var require_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommand.js
var require_subcommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommandGroup.js
var require_subcommandGroup = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/user.js
var require_user = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/chatInput.js
var require_chatInput = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_attachment(), exports);
  __exportStar(require_base(), exports);
  __exportStar(require_boolean(), exports);
  __exportStar(require_channel2(), exports);
  __exportStar(require_integer(), exports);
  __exportStar(require_mentionable(), exports);
  __exportStar(require_number(), exports);
  __exportStar(require_role(), exports);
  __exportStar(require_shared(), exports);
  __exportStar(require_string(), exports);
  __exportStar(require_subcommand(), exports);
  __exportStar(require_subcommandGroup(), exports);
  __exportStar(require_user(), exports);
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/contextMenu.js
var require_contextMenu = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/permissions.js
var require_permissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.APIApplicationCommandPermissionsConstant = exports.ApplicationCommandPermissionType = undefined;
  var ApplicationCommandPermissionType;
  (function(ApplicationCommandPermissionType2) {
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Role"] = 1] = "Role";
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["User"] = 2] = "User";
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Channel"] = 3] = "Channel";
  })(ApplicationCommandPermissionType = exports.ApplicationCommandPermissionType || (exports.ApplicationCommandPermissionType = {}));
  exports.APIApplicationCommandPermissionsConstant = {
    Everyone: (guildId) => String(guildId),
    AllChannels: (guildId) => String(BigInt(guildId) - 1n)
  };
});

// node_modules/discord-api-types/payloads/v10/_interactions/applicationCommands.js
var require_applicationCommands = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationCommandType = undefined;
  __exportStar(require_chatInput(), exports);
  __exportStar(require_contextMenu(), exports);
  __exportStar(require_permissions(), exports);
  var ApplicationCommandType;
  (function(ApplicationCommandType2) {
    ApplicationCommandType2[ApplicationCommandType2["ChatInput"] = 1] = "ChatInput";
    ApplicationCommandType2[ApplicationCommandType2["User"] = 2] = "User";
    ApplicationCommandType2[ApplicationCommandType2["Message"] = 3] = "Message";
  })(ApplicationCommandType = exports.ApplicationCommandType || (exports.ApplicationCommandType = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/autocomplete.js
var require_autocomplete = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/base.js
var require_base2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/messageComponents.js
var require_messageComponents = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/modalSubmit.js
var require_modalSubmit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/ping.js
var require_ping = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/responses.js
var require_responses = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InteractionResponseType = exports.InteractionType = undefined;
  var InteractionType;
  (function(InteractionType2) {
    InteractionType2[InteractionType2["Ping"] = 1] = "Ping";
    InteractionType2[InteractionType2["ApplicationCommand"] = 2] = "ApplicationCommand";
    InteractionType2[InteractionType2["MessageComponent"] = 3] = "MessageComponent";
    InteractionType2[InteractionType2["ApplicationCommandAutocomplete"] = 4] = "ApplicationCommandAutocomplete";
    InteractionType2[InteractionType2["ModalSubmit"] = 5] = "ModalSubmit";
  })(InteractionType = exports.InteractionType || (exports.InteractionType = {}));
  var InteractionResponseType;
  (function(InteractionResponseType2) {
    InteractionResponseType2[InteractionResponseType2["Pong"] = 1] = "Pong";
    InteractionResponseType2[InteractionResponseType2["ChannelMessageWithSource"] = 4] = "ChannelMessageWithSource";
    InteractionResponseType2[InteractionResponseType2["DeferredChannelMessageWithSource"] = 5] = "DeferredChannelMessageWithSource";
    InteractionResponseType2[InteractionResponseType2["DeferredMessageUpdate"] = 6] = "DeferredMessageUpdate";
    InteractionResponseType2[InteractionResponseType2["UpdateMessage"] = 7] = "UpdateMessage";
    InteractionResponseType2[InteractionResponseType2["ApplicationCommandAutocompleteResult"] = 8] = "ApplicationCommandAutocompleteResult";
    InteractionResponseType2[InteractionResponseType2["Modal"] = 9] = "Modal";
    InteractionResponseType2[InteractionResponseType2["PremiumRequired"] = 10] = "PremiumRequired";
  })(InteractionResponseType = exports.InteractionResponseType || (exports.InteractionResponseType = {}));
});

// node_modules/discord-api-types/payloads/v10/interactions.js
var require_interactions = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_applicationCommands(), exports);
  __exportStar(require_autocomplete(), exports);
  __exportStar(require_base2(), exports);
  __exportStar(require_messageComponents(), exports);
  __exportStar(require_modalSubmit(), exports);
  __exportStar(require_ping(), exports);
  __exportStar(require_responses(), exports);
});

// node_modules/discord-api-types/payloads/v10/invite.js
var require_invite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InviteTargetType = undefined;
  var InviteTargetType;
  (function(InviteTargetType2) {
    InviteTargetType2[InviteTargetType2["Stream"] = 1] = "Stream";
    InviteTargetType2[InviteTargetType2["EmbeddedApplication"] = 2] = "EmbeddedApplication";
  })(InviteTargetType = exports.InviteTargetType || (exports.InviteTargetType = {}));
});

// node_modules/discord-api-types/payloads/v10/oauth2.js
var require_oauth2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuth2Scopes = undefined;
  var OAuth2Scopes;
  (function(OAuth2Scopes2) {
    OAuth2Scopes2["Bot"] = "bot";
    OAuth2Scopes2["Connections"] = "connections";
    OAuth2Scopes2["DMChannelsRead"] = "dm_channels.read";
    OAuth2Scopes2["Email"] = "email";
    OAuth2Scopes2["Identify"] = "identify";
    OAuth2Scopes2["Guilds"] = "guilds";
    OAuth2Scopes2["GuildsJoin"] = "guilds.join";
    OAuth2Scopes2["GuildsMembersRead"] = "guilds.members.read";
    OAuth2Scopes2["GroupDMJoins"] = "gdm.join";
    OAuth2Scopes2["MessagesRead"] = "messages.read";
    OAuth2Scopes2["RoleConnectionsWrite"] = "role_connections.write";
    OAuth2Scopes2["RPC"] = "rpc";
    OAuth2Scopes2["RPCNotificationsRead"] = "rpc.notifications.read";
    OAuth2Scopes2["WebhookIncoming"] = "webhook.incoming";
    OAuth2Scopes2["Voice"] = "voice";
    OAuth2Scopes2["ApplicationsBuildsUpload"] = "applications.builds.upload";
    OAuth2Scopes2["ApplicationsBuildsRead"] = "applications.builds.read";
    OAuth2Scopes2["ApplicationsStoreUpdate"] = "applications.store.update";
    OAuth2Scopes2["ApplicationsEntitlements"] = "applications.entitlements";
    OAuth2Scopes2["RelationshipsRead"] = "relationships.read";
    OAuth2Scopes2["ActivitiesRead"] = "activities.read";
    OAuth2Scopes2["ActivitiesWrite"] = "activities.write";
    OAuth2Scopes2["ApplicationsCommands"] = "applications.commands";
    OAuth2Scopes2["ApplicationsCommandsUpdate"] = "applications.commands.update";
    OAuth2Scopes2["ApplicationCommandsPermissionsUpdate"] = "applications.commands.permissions.update";
  })(OAuth2Scopes = exports.OAuth2Scopes || (exports.OAuth2Scopes = {}));
});

// node_modules/discord-api-types/payloads/v10/permissions.js
var require_permissions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RoleFlags = undefined;
  var RoleFlags;
  (function(RoleFlags2) {
    RoleFlags2[RoleFlags2["InPrompt"] = 1] = "InPrompt";
  })(RoleFlags = exports.RoleFlags || (exports.RoleFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/stageInstance.js
var require_stageInstance = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StageInstancePrivacyLevel = undefined;
  var StageInstancePrivacyLevel;
  (function(StageInstancePrivacyLevel2) {
    StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["Public"] = 1] = "Public";
    StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
  })(StageInstancePrivacyLevel = exports.StageInstancePrivacyLevel || (exports.StageInstancePrivacyLevel = {}));
});

// node_modules/discord-api-types/payloads/v10/sticker.js
var require_sticker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StickerFormatType = exports.StickerType = undefined;
  var StickerType;
  (function(StickerType2) {
    StickerType2[StickerType2["Standard"] = 1] = "Standard";
    StickerType2[StickerType2["Guild"] = 2] = "Guild";
  })(StickerType = exports.StickerType || (exports.StickerType = {}));
  var StickerFormatType;
  (function(StickerFormatType2) {
    StickerFormatType2[StickerFormatType2["PNG"] = 1] = "PNG";
    StickerFormatType2[StickerFormatType2["APNG"] = 2] = "APNG";
    StickerFormatType2[StickerFormatType2["Lottie"] = 3] = "Lottie";
    StickerFormatType2[StickerFormatType2["GIF"] = 4] = "GIF";
  })(StickerFormatType = exports.StickerFormatType || (exports.StickerFormatType = {}));
});

// node_modules/discord-api-types/payloads/v10/teams.js
var require_teams = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TeamMemberRole = exports.TeamMemberMembershipState = undefined;
  var TeamMemberMembershipState;
  (function(TeamMemberMembershipState2) {
    TeamMemberMembershipState2[TeamMemberMembershipState2["Invited"] = 1] = "Invited";
    TeamMemberMembershipState2[TeamMemberMembershipState2["Accepted"] = 2] = "Accepted";
  })(TeamMemberMembershipState = exports.TeamMemberMembershipState || (exports.TeamMemberMembershipState = {}));
  var TeamMemberRole;
  (function(TeamMemberRole2) {
    TeamMemberRole2["Admin"] = "admin";
    TeamMemberRole2["Developer"] = "developer";
    TeamMemberRole2["ReadOnly"] = "read_only";
  })(TeamMemberRole = exports.TeamMemberRole || (exports.TeamMemberRole = {}));
});

// node_modules/discord-api-types/payloads/v10/template.js
var require_template = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/user.js
var require_user2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionVisibility = exports.ConnectionService = exports.UserPremiumType = exports.UserFlags = undefined;
  var UserFlags;
  (function(UserFlags2) {
    UserFlags2[UserFlags2["Staff"] = 1] = "Staff";
    UserFlags2[UserFlags2["Partner"] = 2] = "Partner";
    UserFlags2[UserFlags2["Hypesquad"] = 4] = "Hypesquad";
    UserFlags2[UserFlags2["BugHunterLevel1"] = 8] = "BugHunterLevel1";
    UserFlags2[UserFlags2["MFASMS"] = 16] = "MFASMS";
    UserFlags2[UserFlags2["PremiumPromoDismissed"] = 32] = "PremiumPromoDismissed";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse1"] = 64] = "HypeSquadOnlineHouse1";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse2"] = 128] = "HypeSquadOnlineHouse2";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse3"] = 256] = "HypeSquadOnlineHouse3";
    UserFlags2[UserFlags2["PremiumEarlySupporter"] = 512] = "PremiumEarlySupporter";
    UserFlags2[UserFlags2["TeamPseudoUser"] = 1024] = "TeamPseudoUser";
    UserFlags2[UserFlags2["HasUnreadUrgentMessages"] = 8192] = "HasUnreadUrgentMessages";
    UserFlags2[UserFlags2["BugHunterLevel2"] = 16384] = "BugHunterLevel2";
    UserFlags2[UserFlags2["VerifiedBot"] = 65536] = "VerifiedBot";
    UserFlags2[UserFlags2["VerifiedDeveloper"] = 131072] = "VerifiedDeveloper";
    UserFlags2[UserFlags2["CertifiedModerator"] = 262144] = "CertifiedModerator";
    UserFlags2[UserFlags2["BotHTTPInteractions"] = 524288] = "BotHTTPInteractions";
    UserFlags2[UserFlags2["Spammer"] = 1048576] = "Spammer";
    UserFlags2[UserFlags2["DisablePremium"] = 2097152] = "DisablePremium";
    UserFlags2[UserFlags2["ActiveDeveloper"] = 4194304] = "ActiveDeveloper";
    UserFlags2[UserFlags2["Quarantined"] = 17592186044416] = "Quarantined";
    UserFlags2[UserFlags2["Collaborator"] = 1125899906842624] = "Collaborator";
    UserFlags2[UserFlags2["RestrictedCollaborator"] = 2251799813685248] = "RestrictedCollaborator";
  })(UserFlags = exports.UserFlags || (exports.UserFlags = {}));
  var UserPremiumType;
  (function(UserPremiumType2) {
    UserPremiumType2[UserPremiumType2["None"] = 0] = "None";
    UserPremiumType2[UserPremiumType2["NitroClassic"] = 1] = "NitroClassic";
    UserPremiumType2[UserPremiumType2["Nitro"] = 2] = "Nitro";
    UserPremiumType2[UserPremiumType2["NitroBasic"] = 3] = "NitroBasic";
  })(UserPremiumType = exports.UserPremiumType || (exports.UserPremiumType = {}));
  var ConnectionService;
  (function(ConnectionService2) {
    ConnectionService2["BattleNet"] = "battlenet";
    ConnectionService2["eBay"] = "ebay";
    ConnectionService2["EpicGames"] = "epicgames";
    ConnectionService2["Facebook"] = "facebook";
    ConnectionService2["GitHub"] = "github";
    ConnectionService2["Instagram"] = "instagram";
    ConnectionService2["LeagueOfLegends"] = "leagueoflegends";
    ConnectionService2["PayPal"] = "paypal";
    ConnectionService2["PlayStationNetwork"] = "playstation";
    ConnectionService2["Reddit"] = "reddit";
    ConnectionService2["RiotGames"] = "riotgames";
    ConnectionService2["Spotify"] = "spotify";
    ConnectionService2["Skype"] = "skype";
    ConnectionService2["Steam"] = "steam";
    ConnectionService2["TikTok"] = "tiktok";
    ConnectionService2["Twitch"] = "twitch";
    ConnectionService2["X"] = "twitter";
    ConnectionService2["Twitter"] = "twitter";
    ConnectionService2["Xbox"] = "xbox";
    ConnectionService2["YouTube"] = "youtube";
  })(ConnectionService = exports.ConnectionService || (exports.ConnectionService = {}));
  var ConnectionVisibility;
  (function(ConnectionVisibility2) {
    ConnectionVisibility2[ConnectionVisibility2["None"] = 0] = "None";
    ConnectionVisibility2[ConnectionVisibility2["Everyone"] = 1] = "Everyone";
  })(ConnectionVisibility = exports.ConnectionVisibility || (exports.ConnectionVisibility = {}));
});

// node_modules/discord-api-types/payloads/v10/voice.js
var require_voice = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/webhook.js
var require_webhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebhookType = undefined;
  var WebhookType;
  (function(WebhookType2) {
    WebhookType2[WebhookType2["Incoming"] = 1] = "Incoming";
    WebhookType2[WebhookType2["ChannelFollower"] = 2] = "ChannelFollower";
    WebhookType2[WebhookType2["Application"] = 3] = "Application";
  })(WebhookType = exports.WebhookType || (exports.WebhookType = {}));
});

// node_modules/discord-api-types/payloads/v10/monetization.js
var require_monetization = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SKUType = exports.SKUFlags = exports.EntitlementType = undefined;
  var EntitlementType;
  (function(EntitlementType2) {
    EntitlementType2[EntitlementType2["ApplicationSubscription"] = 8] = "ApplicationSubscription";
  })(EntitlementType = exports.EntitlementType || (exports.EntitlementType = {}));
  var SKUFlags;
  (function(SKUFlags2) {
    SKUFlags2[SKUFlags2["Available"] = 4] = "Available";
    SKUFlags2[SKUFlags2["GuildSubscription"] = 128] = "GuildSubscription";
    SKUFlags2[SKUFlags2["UserSubscription"] = 256] = "UserSubscription";
  })(SKUFlags = exports.SKUFlags || (exports.SKUFlags = {}));
  var SKUType;
  (function(SKUType2) {
    SKUType2[SKUType2["Subscription"] = 5] = "Subscription";
    SKUType2[SKUType2["SubscriptionGroup"] = 6] = "SubscriptionGroup";
  })(SKUType = exports.SKUType || (exports.SKUType = {}));
});

// node_modules/discord-api-types/payloads/v10/index.js
var require_v102 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_common2(), exports);
  __exportStar(require_application(), exports);
  __exportStar(require_auditLog(), exports);
  __exportStar(require_autoModeration(), exports);
  __exportStar(require_channel(), exports);
  __exportStar(require_emoji(), exports);
  __exportStar(require_gateway(), exports);
  __exportStar(require_guild(), exports);
  __exportStar(require_guildScheduledEvent(), exports);
  __exportStar(require_interactions(), exports);
  __exportStar(require_invite(), exports);
  __exportStar(require_oauth2(), exports);
  __exportStar(require_permissions2(), exports);
  __exportStar(require_stageInstance(), exports);
  __exportStar(require_sticker(), exports);
  __exportStar(require_teams(), exports);
  __exportStar(require_template(), exports);
  __exportStar(require_user2(), exports);
  __exportStar(require_voice(), exports);
  __exportStar(require_webhook(), exports);
  __exportStar(require_monetization(), exports);
});

// node_modules/discord-api-types/rest/common.js
var require_common3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Locale = exports.RESTJSONErrorCodes = undefined;
  var RESTJSONErrorCodes;
  (function(RESTJSONErrorCodes2) {
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GeneralError"] = 0] = "GeneralError";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAccount"] = 10001] = "UnknownAccount";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplication"] = 10002] = "UnknownApplication";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownChannel"] = 10003] = "UnknownChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuild"] = 10004] = "UnknownGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownIntegration"] = 10005] = "UnknownIntegration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInvite"] = 10006] = "UnknownInvite";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMember"] = 10007] = "UnknownMember";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMessage"] = 10008] = "UnknownMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPermissionOverwrite"] = 10009] = "UnknownPermissionOverwrite";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownProvider"] = 10010] = "UnknownProvider";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRole"] = 10011] = "UnknownRole";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownToken"] = 10012] = "UnknownToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownUser"] = 10013] = "UnknownUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEmoji"] = 10014] = "UnknownEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhook"] = 10015] = "UnknownWebhook";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhookService"] = 10016] = "UnknownWebhookService";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSession"] = 10020] = "UnknownSession";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBan"] = 10026] = "UnknownBan";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSKU"] = 10027] = "UnknownSKU";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreListing"] = 10028] = "UnknownStoreListing";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEntitlement"] = 10029] = "UnknownEntitlement";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBuild"] = 10030] = "UnknownBuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownLobby"] = 10031] = "UnknownLobby";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBranch"] = 10032] = "UnknownBranch";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreDirectoryLayout"] = 10033] = "UnknownStoreDirectoryLayout";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRedistributable"] = 10036] = "UnknownRedistributable";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGiftCode"] = 10038] = "UnknownGiftCode";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStream"] = 10049] = "UnknownStream";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPremiumServerSubscribeCooldown"] = 10050] = "UnknownPremiumServerSubscribeCooldown";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildTemplate"] = 10057] = "UnknownGuildTemplate";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownDiscoverableServerCategory"] = 10059] = "UnknownDiscoverableServerCategory";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSticker"] = 10060] = "UnknownSticker";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInteraction"] = 10062] = "UnknownInteraction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommand"] = 10063] = "UnknownApplicationCommand";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownVoiceState"] = 10065] = "UnknownVoiceState";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommandPermissions"] = 10066] = "UnknownApplicationCommandPermissions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStageInstance"] = 10067] = "UnknownStageInstance";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildMemberVerificationForm"] = 10068] = "UnknownGuildMemberVerificationForm";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildWelcomeScreen"] = 10069] = "UnknownGuildWelcomeScreen";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEvent"] = 10070] = "UnknownGuildScheduledEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEventUser"] = 10071] = "UnknownGuildScheduledEventUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownTag"] = 10087] = "UnknownTag";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["BotsCannotUseThisEndpoint"] = 20001] = "BotsCannotUseThisEndpoint";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyBotsCanUseThisEndpoint"] = 20002] = "OnlyBotsCanUseThisEndpoint";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ExplicitContentCannotBeSentToTheDesiredRecipient"] = 20009] = "ExplicitContentCannotBeSentToTheDesiredRecipient";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NotAuthorizedToPerformThisActionOnThisApplication"] = 20012] = "NotAuthorizedToPerformThisActionOnThisApplication";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ActionCannotBePerformedDueToSlowmodeRateLimit"] = 20016] = "ActionCannotBePerformedDueToSlowmodeRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheMazeIsntMeantForYou"] = 20017] = "TheMazeIsntMeantForYou";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyTheOwnerOfThisAccountCanPerformThisAction"] = 20018] = "OnlyTheOwnerOfThisAccountCanPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnnouncementEditLimitExceeded"] = 20022] = "AnnouncementEditLimitExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnderMinimumAge"] = 20024] = "UnderMinimumAge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelSendRateLimit"] = 20028] = "ChannelSendRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerSendRateLimit"] = 20029] = "ServerSendRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords"] = 20031] = "StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildPremiumSubscriptionLevelTooLow"] = 20035] = "GuildPremiumSubscriptionLevelTooLow";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildsReached"] = 30001] = "MaximumNumberOfGuildsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfFriendsReached"] = 30002] = "MaximumNumberOfFriendsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinsReachedForTheChannel"] = 30003] = "MaximumNumberOfPinsReachedForTheChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfRecipientsReached"] = 30004] = "MaximumNumberOfRecipientsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildRolesReached"] = 30005] = "MaximumNumberOfGuildRolesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksReached"] = 30007] = "MaximumNumberOfWebhooksReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEmojisReached"] = 30008] = "MaximumNumberOfEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfReactionsReached"] = 30010] = "MaximumNumberOfReactionsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGroupDMsReached"] = 30011] = "MaximumNumberOfGroupDMsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildChannelsReached"] = 30013] = "MaximumNumberOfGuildChannelsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAttachmentsInAMessageReached"] = 30015] = "MaximumNumberOfAttachmentsInAMessageReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfInvitesReached"] = 30016] = "MaximumNumberOfInvitesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAnimatedEmojisReached"] = 30018] = "MaximumNumberOfAnimatedEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerMembersReached"] = 30019] = "MaximumNumberOfServerMembersReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerCategoriesReached"] = 30030] = "MaximumNumberOfServerCategoriesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildAlreadyHasTemplate"] = 30031] = "GuildAlreadyHasTemplate";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfApplicationCommandsReached"] = 30032] = "MaximumNumberOfApplicationCommandsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumThreadParticipantsReached"] = 30033] = "MaximumThreadParticipantsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumDailyApplicationCommandCreatesReached"] = 30034] = "MaximumDailyApplicationCommandCreatesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfNonGuildMemberBansHasBeenExceeded"] = 30035] = "MaximumNumberOfNonGuildMemberBansHasBeenExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfBanFetchesHasBeenReached"] = 30037] = "MaximumNumberOfBanFetchesHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfUncompletedGuildScheduledEventsReached"] = 30038] = "MaximumNumberOfUncompletedGuildScheduledEventsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfStickersReached"] = 30039] = "MaximumNumberOfStickersReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPruneRequestsHasBeenReached"] = 30040] = "MaximumNumberOfPruneRequestsHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached"] = 30042] = "MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEditsToMessagesOlderThanOneHourReached"] = 30046] = "MaximumNumberOfEditsToMessagesOlderThanOneHourReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinnedThreadsInForumHasBeenReached"] = 30047] = "MaximumNumberOfPinnedThreadsInForumHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfTagsInForumHasBeenReached"] = 30048] = "MaximumNumberOfTagsInForumHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["BitrateIsTooHighForChannelOfThisType"] = 30052] = "BitrateIsTooHighForChannelOfThisType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPremiumEmojisReached"] = 30056] = "MaximumNumberOfPremiumEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksPerGuildReached"] = 30058] = "MaximumNumberOfWebhooksPerGuildReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfChannelPermissionOverwritesReached"] = 30060] = "MaximumNumberOfChannelPermissionOverwritesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheChannelsForThisGuildAreTooLarge"] = 30061] = "TheChannelsForThisGuildAreTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["Unauthorized"] = 40001] = "Unauthorized";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VerifyYourAccount"] = 40002] = "VerifyYourAccount";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OpeningDirectMessagesTooFast"] = 40003] = "OpeningDirectMessagesTooFast";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["SendMessagesHasBeenTemporarilyDisabled"] = 40004] = "SendMessagesHasBeenTemporarilyDisabled";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestEntityTooLarge"] = 40005] = "RequestEntityTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FeatureTemporarilyDisabledServerSide"] = 40006] = "FeatureTemporarilyDisabledServerSide";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserBannedFromThisGuild"] = 40007] = "UserBannedFromThisGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ConnectionHasBeenRevoked"] = 40012] = "ConnectionHasBeenRevoked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TargetUserIsNotConnectedToVoice"] = 40032] = "TargetUserIsNotConnectedToVoice";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisMessageWasAlreadyCrossposted"] = 40033] = "ThisMessageWasAlreadyCrossposted";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationCommandWithThatNameAlreadyExists"] = 40041] = "ApplicationCommandWithThatNameAlreadyExists";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationInteractionFailedToSend"] = 40043] = "ApplicationInteractionFailedToSend";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAMessageInAForumChannel"] = 40058] = "CannotSendAMessageInAForumChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InteractionHasAlreadyBeenAcknowledged"] = 40060] = "InteractionHasAlreadyBeenAcknowledged";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagNamesMustBeUnique"] = 40061] = "TagNamesMustBeUnique";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServiceResourceIsBeingRateLimited"] = 40062] = "ServiceResourceIsBeingRateLimited";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThereAreNoTagsAvailableThatCanBeSetByNonModerators"] = 40066] = "ThereAreNoTagsAvailableThatCanBeSetByNonModerators";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagRequiredToCreateAForumPostInThisChannel"] = 40067] = "TagRequiredToCreateAForumPostInThisChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingAccess"] = 50001] = "MissingAccess";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAccountType"] = 50002] = "InvalidAccountType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnDMChannel"] = 50003] = "CannotExecuteActionOnDMChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildWidgetDisabled"] = 50004] = "GuildWidgetDisabled";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditMessageAuthoredByAnotherUser"] = 50005] = "CannotEditMessageAuthoredByAnotherUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAnEmptyMessage"] = 50006] = "CannotSendAnEmptyMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesToThisUser"] = 50007] = "CannotSendMessagesToThisUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesInNonTextChannel"] = 50008] = "CannotSendMessagesInNonTextChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelVerificationLevelTooHighForYouToGainAccess"] = 50009] = "ChannelVerificationLevelTooHighForYouToGainAccess";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationDoesNotHaveBot"] = 50010] = "OAuth2ApplicationDoesNotHaveBot";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationLimitReached"] = 50011] = "OAuth2ApplicationLimitReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2State"] = 50012] = "InvalidOAuth2State";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingPermissions"] = 50013] = "MissingPermissions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidToken"] = 50014] = "InvalidToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoteWasTooLong"] = 50015] = "NoteWasTooLong";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedTooFewOrTooManyMessagesToDelete"] = 50016] = "ProvidedTooFewOrTooManyMessagesToDelete";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMFALevel"] = 50017] = "InvalidMFALevel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageCanOnlyBePinnedInTheChannelItWasSentIn"] = 50019] = "MessageCanOnlyBePinnedInTheChannelItWasSentIn";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteCodeInvalidOrTaken"] = 50020] = "InviteCodeInvalidOrTaken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnSystemMessage"] = 50021] = "CannotExecuteActionOnSystemMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnThisChannelType"] = 50024] = "CannotExecuteActionOnThisChannelType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2AccessToken"] = 50025] = "InvalidOAuth2AccessToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingRequiredOAuth2Scope"] = 50026] = "MissingRequiredOAuth2Scope";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidWebhookToken"] = 50027] = "InvalidWebhookToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRole"] = 50028] = "InvalidRole";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRecipients"] = 50033] = "InvalidRecipients";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OneOfTheMessagesProvidedWasTooOldForBulkDelete"] = 50034] = "OneOfTheMessagesProvidedWasTooOldForBulkDelete";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFormBodyOrContentType"] = 50035] = "InvalidFormBodyOrContentType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteAcceptedToGuildWithoutTheBotBeingIn"] = 50036] = "InviteAcceptedToGuildWithoutTheBotBeingIn";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActivityAction"] = 50039] = "InvalidActivityAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAPIVersion"] = 50041] = "InvalidAPIVersion";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FileUploadedExceedsMaximumSize"] = 50045] = "FileUploadedExceedsMaximumSize";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFileUploaded"] = 50046] = "InvalidFileUploaded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSelfRedeemThisGift"] = 50054] = "CannotSelfRedeemThisGift";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidGuild"] = 50055] = "InvalidGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRequestOrigin"] = 50067] = "InvalidRequestOrigin";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMessageType"] = 50068] = "InvalidMessageType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["PaymentSourceRequiredToRedeemGift"] = 50070] = "PaymentSourceRequiredToRedeemGift";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotModifyASystemWebhook"] = 50073] = "CannotModifyASystemWebhook";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteChannelRequiredForCommunityGuilds"] = 50074] = "CannotDeleteChannelRequiredForCommunityGuilds";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditStickersWithinMessage"] = 50080] = "CannotEditStickersWithinMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidStickerSent"] = 50081] = "InvalidStickerSent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActionOnArchivedThread"] = 50083] = "InvalidActionOnArchivedThread";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidThreadNotificationSettings"] = 50084] = "InvalidThreadNotificationSettings";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ParameterEarlierThanCreation"] = 50085] = "ParameterEarlierThanCreation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CommunityServerChannelsMustBeTextChannels"] = 50086] = "CommunityServerChannelsMustBeTextChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor"] = 50091] = "TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNotAvailableInYourLocation"] = 50095] = "ServerNotAvailableInYourLocation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMonetizationEnabledToPerformThisAction"] = 50097] = "ServerNeedsMonetizationEnabledToPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMoreBoostsToPerformThisAction"] = 50101] = "ServerNeedsMoreBoostsToPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestBodyContainsInvalidJSON"] = 50109] = "RequestBodyContainsInvalidJSON";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnerCannotBePendingMember"] = 50131] = "OwnerCannotBePendingMember";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnershipCannotBeMovedToABotUser"] = 50132] = "OwnershipCannotBeMovedToABotUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToResizeAssetBelowTheMinimumSize"] = 50138] = "FailedToResizeAssetBelowTheMinimumSize";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji"] = 50144] = "CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotConvertBetweenPremiumEmojiAndNormalEmoji"] = 50145] = "CannotConvertBetweenPremiumEmojiAndNormalEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedFileNotFound"] = 50146] = "UploadedFileNotFound";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesDoNotSupportAdditionalContent"] = 50159] = "VoiceMessagesDoNotSupportAdditionalContent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveASingleAudioAttachment"] = 50160] = "VoiceMessagesMustHaveASingleAudioAttachment";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveSupportingMetadata"] = 50161] = "VoiceMessagesMustHaveSupportingMetadata";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesCannotBeEdited"] = 50162] = "VoiceMessagesCannotBeEdited";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteGuildSubscriptionIntegration"] = 50163] = "CannotDeleteGuildSubscriptionIntegration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouCannotSendVoiceMessagesInThisChannel"] = 50173] = "YouCannotSendVoiceMessagesInThisChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheUserAccountMustFirstBeVerified"] = 50178] = "TheUserAccountMustFirstBeVerified";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouDoNotHavePermissionToSendThisSticker"] = 50600] = "YouDoNotHavePermissionToSendThisSticker";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TwoFactorAuthenticationIsRequired"] = 60003] = "TwoFactorAuthenticationIsRequired";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoUsersWithDiscordTagExist"] = 80004] = "NoUsersWithDiscordTagExist";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ReactionWasBlocked"] = 90001] = "ReactionWasBlocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationNotYetAvailable"] = 110001] = "ApplicationNotYetAvailable";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["APIResourceOverloaded"] = 130000] = "APIResourceOverloaded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheStageIsAlreadyOpen"] = 150006] = "TheStageIsAlreadyOpen";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotReplyWithoutPermissionToReadMessageHistory"] = 160002] = "CannotReplyWithoutPermissionToReadMessageHistory";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadAlreadyCreatedForMessage"] = 160004] = "ThreadAlreadyCreatedForMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadLocked"] = 160005] = "ThreadLocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveThreads"] = 160006] = "MaximumActiveThreads";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveAnnouncementThreads"] = 160007] = "MaximumActiveAnnouncementThreads";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidJSONForUploadedLottieFile"] = 170001] = "InvalidJSONForUploadedLottieFile";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedLottiesCannotContainRasterizedImages"] = 170002] = "UploadedLottiesCannotContainRasterizedImages";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerMaximumFramerateExceeded"] = 170003] = "StickerMaximumFramerateExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFrameCountExceedsMaximumOf1000Frames"] = 170004] = "StickerFrameCountExceedsMaximumOf1000Frames";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["LottieAnimationMaximumDimensionsExceeded"] = 170005] = "LottieAnimationMaximumDimensionsExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFramerateIsTooSmallOrTooLarge"] = 170006] = "StickerFramerateIsTooSmallOrTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerAnimationDurationExceedsMaximumOf5Seconds"] = 170007] = "StickerAnimationDurationExceedsMaximumOf5Seconds";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateAFinishedEvent"] = 180000] = "CannotUpdateAFinishedEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToCreateStageNeededForStageEvent"] = 180002] = "FailedToCreateStageNeededForStageEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageWasBlockedByAutomaticModeration"] = 200000] = "MessageWasBlockedByAutomaticModeration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TitleWasBlockedByAutomaticModeration"] = 200001] = "TitleWasBlockedByAutomaticModeration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId"] = 220001] = "WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId"] = 220002] = "WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksCanOnlyCreateThreadsInForumChannels"] = 220003] = "WebhooksCanOnlyCreateThreadsInForumChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhookServicesCannotBeUsedInForumChannels"] = 220004] = "WebhookServicesCannotBeUsedInForumChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageBlockedByHarmfulLinksFilter"] = 240000] = "MessageBlockedByHarmfulLinksFilter";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEnableOnboardingRequirementsAreNotMet"] = 350000] = "CannotEnableOnboardingRequirementsAreNotMet";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateOnboardingWhileBelowRequirements"] = 350001] = "CannotUpdateOnboardingWhileBelowRequirements";
  })(RESTJSONErrorCodes = exports.RESTJSONErrorCodes || (exports.RESTJSONErrorCodes = {}));
  var Locale;
  (function(Locale2) {
    Locale2["Indonesian"] = "id";
    Locale2["EnglishUS"] = "en-US";
    Locale2["EnglishGB"] = "en-GB";
    Locale2["Bulgarian"] = "bg";
    Locale2["ChineseCN"] = "zh-CN";
    Locale2["ChineseTW"] = "zh-TW";
    Locale2["Croatian"] = "hr";
    Locale2["Czech"] = "cs";
    Locale2["Danish"] = "da";
    Locale2["Dutch"] = "nl";
    Locale2["Finnish"] = "fi";
    Locale2["French"] = "fr";
    Locale2["German"] = "de";
    Locale2["Greek"] = "el";
    Locale2["Hindi"] = "hi";
    Locale2["Hungarian"] = "hu";
    Locale2["Italian"] = "it";
    Locale2["Japanese"] = "ja";
    Locale2["Korean"] = "ko";
    Locale2["Lithuanian"] = "lt";
    Locale2["Norwegian"] = "no";
    Locale2["Polish"] = "pl";
    Locale2["PortugueseBR"] = "pt-BR";
    Locale2["Romanian"] = "ro";
    Locale2["Russian"] = "ru";
    Locale2["SpanishES"] = "es-ES";
    Locale2["Swedish"] = "sv-SE";
    Locale2["Thai"] = "th";
    Locale2["Turkish"] = "tr";
    Locale2["Ukrainian"] = "uk";
    Locale2["Vietnamese"] = "vi";
  })(Locale = exports.Locale || (exports.Locale = {}));
});

// node_modules/discord-api-types/rest/v10/application.js
var require_application2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/auditLog.js
var require_auditLog2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/autoModeration.js
var require_autoModeration2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/channel.js
var require_channel3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/emoji.js
var require_emoji2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/gateway.js
var require_gateway2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/guild.js
var require_guild2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/guildScheduledEvent.js
var require_guildScheduledEvent2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/interactions.js
var require_interactions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/invite.js
var require_invite2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/oauth2.js
var require_oauth22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/stageInstance.js
var require_stageInstance2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/sticker.js
var require_sticker2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/template.js
var require_template2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/user.js
var require_user3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/voice.js
var require_voice2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/webhook.js
var require_webhook2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/monetization.js
var require_monetization2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EntitlementOwnerType = undefined;
  var EntitlementOwnerType;
  (function(EntitlementOwnerType2) {
    EntitlementOwnerType2[EntitlementOwnerType2["Guild"] = 1] = "Guild";
    EntitlementOwnerType2[EntitlementOwnerType2["User"] = 2] = "User";
  })(EntitlementOwnerType = exports.EntitlementOwnerType || (exports.EntitlementOwnerType = {}));
});

// node_modules/discord-api-types/rest/v10/index.js
var require_v103 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuth2Routes = exports.RouteBases = exports.ImageFormat = exports.CDNRoutes = exports.StickerPackApplicationId = exports.Routes = exports.APIVersion = undefined;
  __exportStar(require_common3(), exports);
  __exportStar(require_application2(), exports);
  __exportStar(require_auditLog2(), exports);
  __exportStar(require_autoModeration2(), exports);
  __exportStar(require_channel3(), exports);
  __exportStar(require_emoji2(), exports);
  __exportStar(require_gateway2(), exports);
  __exportStar(require_guild2(), exports);
  __exportStar(require_guildScheduledEvent2(), exports);
  __exportStar(require_interactions2(), exports);
  __exportStar(require_invite2(), exports);
  __exportStar(require_oauth22(), exports);
  __exportStar(require_stageInstance2(), exports);
  __exportStar(require_sticker2(), exports);
  __exportStar(require_template2(), exports);
  __exportStar(require_user3(), exports);
  __exportStar(require_voice2(), exports);
  __exportStar(require_webhook2(), exports);
  __exportStar(require_monetization2(), exports);
  exports.APIVersion = "10";
  exports.Routes = {
    applicationRoleConnectionMetadata(applicationId) {
      return `/applications/${applicationId}/role-connections/metadata`;
    },
    guildAutoModerationRules(guildId) {
      return `/guilds/${guildId}/auto-moderation/rules`;
    },
    guildAutoModerationRule(guildId, ruleId) {
      return `/guilds/${guildId}/auto-moderation/rules/${ruleId}`;
    },
    guildAuditLog(guildId) {
      return `/guilds/${guildId}/audit-logs`;
    },
    channel(channelId) {
      return `/channels/${channelId}`;
    },
    channelMessages(channelId) {
      return `/channels/${channelId}/messages`;
    },
    channelMessage(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}`;
    },
    channelMessageCrosspost(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}/crosspost`;
    },
    channelMessageOwnReaction(channelId, messageId, emoji) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/@me`;
    },
    channelMessageUserReaction(channelId, messageId, emoji, userId) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/${userId}`;
    },
    channelMessageReaction(channelId, messageId, emoji) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}`;
    },
    channelMessageAllReactions(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}/reactions`;
    },
    channelBulkDelete(channelId) {
      return `/channels/${channelId}/messages/bulk-delete`;
    },
    channelPermission(channelId, overwriteId) {
      return `/channels/${channelId}/permissions/${overwriteId}`;
    },
    channelInvites(channelId) {
      return `/channels/${channelId}/invites`;
    },
    channelFollowers(channelId) {
      return `/channels/${channelId}/followers`;
    },
    channelTyping(channelId) {
      return `/channels/${channelId}/typing`;
    },
    channelPins(channelId) {
      return `/channels/${channelId}/pins`;
    },
    channelPin(channelId, messageId) {
      return `/channels/${channelId}/pins/${messageId}`;
    },
    channelRecipient(channelId, userId) {
      return `/channels/${channelId}/recipients/${userId}`;
    },
    guildEmojis(guildId) {
      return `/guilds/${guildId}/emojis`;
    },
    guildEmoji(guildId, emojiId) {
      return `/guilds/${guildId}/emojis/${emojiId}`;
    },
    guilds() {
      return "/guilds";
    },
    guild(guildId) {
      return `/guilds/${guildId}`;
    },
    guildPreview(guildId) {
      return `/guilds/${guildId}/preview`;
    },
    guildChannels(guildId) {
      return `/guilds/${guildId}/channels`;
    },
    guildMember(guildId, userId = "@me") {
      return `/guilds/${guildId}/members/${userId}`;
    },
    guildMembers(guildId) {
      return `/guilds/${guildId}/members`;
    },
    guildMembersSearch(guildId) {
      return `/guilds/${guildId}/members/search`;
    },
    guildCurrentMemberNickname(guildId) {
      return `/guilds/${guildId}/members/@me/nick`;
    },
    guildMemberRole(guildId, memberId, roleId) {
      return `/guilds/${guildId}/members/${memberId}/roles/${roleId}`;
    },
    guildMFA(guildId) {
      return `/guilds/${guildId}/mfa`;
    },
    guildBans(guildId) {
      return `/guilds/${guildId}/bans`;
    },
    guildBan(guildId, userId) {
      return `/guilds/${guildId}/bans/${userId}`;
    },
    guildRoles(guildId) {
      return `/guilds/${guildId}/roles`;
    },
    guildRole(guildId, roleId) {
      return `/guilds/${guildId}/roles/${roleId}`;
    },
    guildPrune(guildId) {
      return `/guilds/${guildId}/prune`;
    },
    guildVoiceRegions(guildId) {
      return `/guilds/${guildId}/regions`;
    },
    guildInvites(guildId) {
      return `/guilds/${guildId}/invites`;
    },
    guildIntegrations(guildId) {
      return `/guilds/${guildId}/integrations`;
    },
    guildIntegration(guildId, integrationId) {
      return `/guilds/${guildId}/integrations/${integrationId}`;
    },
    guildWidgetSettings(guildId) {
      return `/guilds/${guildId}/widget`;
    },
    guildWidgetJSON(guildId) {
      return `/guilds/${guildId}/widget.json`;
    },
    guildVanityUrl(guildId) {
      return `/guilds/${guildId}/vanity-url`;
    },
    guildWidgetImage(guildId) {
      return `/guilds/${guildId}/widget.png`;
    },
    invite(code) {
      return `/invites/${code}`;
    },
    template(code) {
      return `/guilds/templates/${code}`;
    },
    guildTemplates(guildId) {
      return `/guilds/${guildId}/templates`;
    },
    guildTemplate(guildId, code) {
      return `/guilds/${guildId}/templates/${code}`;
    },
    threads(parentId, messageId) {
      const parts = ["", "channels", parentId];
      if (messageId)
        parts.push("messages", messageId);
      parts.push("threads");
      return parts.join("/");
    },
    guildActiveThreads(guildId) {
      return `/guilds/${guildId}/threads/active`;
    },
    channelThreads(channelId, archivedStatus) {
      return `/channels/${channelId}/threads/archived/${archivedStatus}`;
    },
    channelJoinedArchivedThreads(channelId) {
      return `/channels/${channelId}/users/@me/threads/archived/private`;
    },
    threadMembers(threadId, userId) {
      const parts = ["", "channels", threadId, "thread-members"];
      if (userId)
        parts.push(userId);
      return parts.join("/");
    },
    user(userId = "@me") {
      return `/users/${userId}`;
    },
    userApplicationRoleConnection(applicationId) {
      return `/users/@me/applications/${applicationId}/role-connection`;
    },
    userGuilds() {
      return `/users/@me/guilds`;
    },
    userGuildMember(guildId) {
      return `/users/@me/guilds/${guildId}/member`;
    },
    userGuild(guildId) {
      return `/users/@me/guilds/${guildId}`;
    },
    userChannels() {
      return `/users/@me/channels`;
    },
    userConnections() {
      return `/users/@me/connections`;
    },
    voiceRegions() {
      return `/voice/regions`;
    },
    channelWebhooks(channelId) {
      return `/channels/${channelId}/webhooks`;
    },
    guildWebhooks(guildId) {
      return `/guilds/${guildId}/webhooks`;
    },
    webhook(webhookId, webhookToken) {
      const parts = ["", "webhooks", webhookId];
      if (webhookToken)
        parts.push(webhookToken);
      return parts.join("/");
    },
    webhookMessage(webhookId, webhookToken, messageId = "@original") {
      return `/webhooks/${webhookId}/${webhookToken}/messages/${messageId}`;
    },
    webhookPlatform(webhookId, webhookToken, platform) {
      return `/webhooks/${webhookId}/${webhookToken}/${platform}`;
    },
    gateway() {
      return `/gateway`;
    },
    gatewayBot() {
      return `/gateway/bot`;
    },
    oauth2CurrentApplication() {
      return `/oauth2/applications/@me`;
    },
    oauth2CurrentAuthorization() {
      return `/oauth2/@me`;
    },
    oauth2Authorization() {
      return `/oauth2/authorize`;
    },
    oauth2TokenExchange() {
      return `/oauth2/token`;
    },
    oauth2TokenRevocation() {
      return `/oauth2/token/revoke`;
    },
    applicationCommands(applicationId) {
      return `/applications/${applicationId}/commands`;
    },
    applicationCommand(applicationId, commandId) {
      return `/applications/${applicationId}/commands/${commandId}`;
    },
    applicationGuildCommands(applicationId, guildId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands`;
    },
    applicationGuildCommand(applicationId, guildId, commandId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}`;
    },
    interactionCallback(interactionId, interactionToken) {
      return `/interactions/${interactionId}/${interactionToken}/callback`;
    },
    guildMemberVerification(guildId) {
      return `/guilds/${guildId}/member-verification`;
    },
    guildVoiceState(guildId, userId = "@me") {
      return `/guilds/${guildId}/voice-states/${userId}`;
    },
    guildApplicationCommandsPermissions(applicationId, guildId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/permissions`;
    },
    applicationCommandPermissions(applicationId, guildId, commandId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}/permissions`;
    },
    guildWelcomeScreen(guildId) {
      return `/guilds/${guildId}/welcome-screen`;
    },
    stageInstances() {
      return `/stage-instances`;
    },
    stageInstance(channelId) {
      return `/stage-instances/${channelId}`;
    },
    sticker(stickerId) {
      return `/stickers/${stickerId}`;
    },
    stickerPacks() {
      return "/sticker-packs";
    },
    nitroStickerPacks() {
      return "/sticker-packs";
    },
    guildStickers(guildId) {
      return `/guilds/${guildId}/stickers`;
    },
    guildSticker(guildId, stickerId) {
      return `/guilds/${guildId}/stickers/${stickerId}`;
    },
    guildScheduledEvents(guildId) {
      return `/guilds/${guildId}/scheduled-events`;
    },
    guildScheduledEvent(guildId, guildScheduledEventId) {
      return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}`;
    },
    guildScheduledEventUsers(guildId, guildScheduledEventId) {
      return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}/users`;
    },
    guildOnboarding(guildId) {
      return `/guilds/${guildId}/onboarding`;
    },
    currentApplication() {
      return "/applications/@me";
    },
    entitlements(applicationId) {
      return `/applications/${applicationId}/entitlements`;
    },
    entitlement(applicationId, entitlementId) {
      return `/applications/${applicationId}/entitlements/${entitlementId}`;
    },
    skus(applicationId) {
      return `/applications/${applicationId}/skus`;
    }
  };
  exports.StickerPackApplicationId = "710982414301790216";
  exports.CDNRoutes = {
    emoji(emojiId, format) {
      return `/emojis/${emojiId}.${format}`;
    },
    guildIcon(guildId, guildIcon, format) {
      return `icons/${guildId}/${guildIcon}.${format}`;
    },
    guildSplash(guildId, guildSplash, format) {
      return `/splashes/${guildId}/${guildSplash}.${format}`;
    },
    guildDiscoverySplash(guildId, guildDiscoverySplash, format) {
      return `/discovery-splashes/${guildId}/${guildDiscoverySplash}.${format}`;
    },
    guildBanner(guildId, guildBanner, format) {
      return `/banners/${guildId}/${guildBanner}.${format}`;
    },
    userBanner(userId, userBanner, format) {
      return `/banners/${userId}/${userBanner}.${format}`;
    },
    defaultUserAvatar(index) {
      return `/embed/avatars/${index}.png`;
    },
    userAvatar(userId, userAvatar, format) {
      return `/avatars/${userId}/${userAvatar}.${format}`;
    },
    guildMemberAvatar(guildId, userId, memberAvatar, format) {
      return `/guilds/${guildId}/users/${userId}/avatars/${memberAvatar}.${format}`;
    },
    userAvatarDecoration(userId, userAvatarDecoration) {
      return `/avatar-decorations/${userId}/${userAvatarDecoration}.png`;
    },
    applicationIcon(applicationId, applicationIcon, format) {
      return `/app-icons/${applicationId}/${applicationIcon}.${format}`;
    },
    applicationCover(applicationId, applicationCoverImage, format) {
      return `/app-icons/${applicationId}/${applicationCoverImage}.${format}`;
    },
    applicationAsset(applicationId, applicationAssetId, format) {
      return `/app-assets/${applicationId}/${applicationAssetId}.${format}`;
    },
    achievementIcon(applicationId, achievementId, achievementIconHash, format) {
      return `/app-assets/${applicationId}/achievements/${achievementId}/icons/${achievementIconHash}.${format}`;
    },
    stickerPackBanner(stickerPackBannerAssetId, format) {
      return `/app-assets/${exports.StickerPackApplicationId}/store/${stickerPackBannerAssetId}.${format}`;
    },
    storePageAsset(applicationId, assetId) {
      return `/app-assets/${applicationId}/store/${assetId}.png`;
    },
    teamIcon(teamId, teamIcon, format) {
      return `/team-icons/${teamId}/${teamIcon}.${format}`;
    },
    sticker(stickerId, format) {
      return `/stickers/${stickerId}.${format}`;
    },
    roleIcon(roleId, roleIcon, format) {
      return `/role-icons/${roleId}/${roleIcon}.${format}`;
    },
    guildScheduledEventCover(guildScheduledEventId, guildScheduledEventCoverImage, format) {
      return `/guild-events/${guildScheduledEventId}/${guildScheduledEventCoverImage}.${format}`;
    },
    guildMemberBanner(guildId, userId, guildMemberBanner, format) {
      return `/guilds/${guildId}/users/${userId}/banners/${guildMemberBanner}.${format}`;
    }
  };
  var ImageFormat;
  (function(ImageFormat2) {
    ImageFormat2["JPEG"] = "jpeg";
    ImageFormat2["PNG"] = "png";
    ImageFormat2["WebP"] = "webp";
    ImageFormat2["GIF"] = "gif";
    ImageFormat2["Lottie"] = "json";
  })(ImageFormat = exports.ImageFormat || (exports.ImageFormat = {}));
  exports.RouteBases = {
    api: `https://discord.com/api/v${exports.APIVersion}`,
    cdn: "https://cdn.discordapp.com",
    invite: "https://discord.gg",
    template: "https://discord.new",
    gift: "https://discord.gift",
    scheduledEvent: "https://discord.com/events"
  };
  Object.freeze(exports.RouteBases);
  exports.OAuth2Routes = {
    authorizationURL: `${exports.RouteBases.api}${exports.Routes.oauth2Authorization()}`,
    tokenURL: `${exports.RouteBases.api}${exports.Routes.oauth2TokenExchange()}`,
    tokenRevocationURL: `${exports.RouteBases.api}${exports.Routes.oauth2TokenRevocation()}`
  };
  Object.freeze(exports.OAuth2Routes);
});

// node_modules/discord-api-types/rpc/common.js
var require_common4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RPCCloseEventCodes = exports.RPCErrorCodes = undefined;
  var RPCErrorCodes;
  (function(RPCErrorCodes2) {
    RPCErrorCodes2[RPCErrorCodes2["UnknownError"] = 1000] = "UnknownError";
    RPCErrorCodes2[RPCErrorCodes2["InvalidPayload"] = 4000] = "InvalidPayload";
    RPCErrorCodes2[RPCErrorCodes2["InvalidCommand"] = 4002] = "InvalidCommand";
    RPCErrorCodes2[RPCErrorCodes2["InvalidGuild"] = 4003] = "InvalidGuild";
    RPCErrorCodes2[RPCErrorCodes2["InvalidEvent"] = 4004] = "InvalidEvent";
    RPCErrorCodes2[RPCErrorCodes2["InvalidChannel"] = 4005] = "InvalidChannel";
    RPCErrorCodes2[RPCErrorCodes2["InvalidPermissions"] = 4006] = "InvalidPermissions";
    RPCErrorCodes2[RPCErrorCodes2["InvalidClientId"] = 4007] = "InvalidClientId";
    RPCErrorCodes2[RPCErrorCodes2["InvalidOrigin"] = 4008] = "InvalidOrigin";
    RPCErrorCodes2[RPCErrorCodes2["InvalidToken"] = 4009] = "InvalidToken";
    RPCErrorCodes2[RPCErrorCodes2["InvalidUser"] = 4010] = "InvalidUser";
    RPCErrorCodes2[RPCErrorCodes2["OAuth2Error"] = 5000] = "OAuth2Error";
    RPCErrorCodes2[RPCErrorCodes2["SelectChannelTimedOut"] = 5001] = "SelectChannelTimedOut";
    RPCErrorCodes2[RPCErrorCodes2["GetGuildTimedOut"] = 5002] = "GetGuildTimedOut";
    RPCErrorCodes2[RPCErrorCodes2["SelectVoiceForceRequired"] = 5003] = "SelectVoiceForceRequired";
    RPCErrorCodes2[RPCErrorCodes2["CaptureShortcutAlreadyListening"] = 5004] = "CaptureShortcutAlreadyListening";
  })(RPCErrorCodes = exports.RPCErrorCodes || (exports.RPCErrorCodes = {}));
  var RPCCloseEventCodes;
  (function(RPCCloseEventCodes2) {
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidClientId"] = 4000] = "InvalidClientId";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidOrigin"] = 4001] = "InvalidOrigin";
    RPCCloseEventCodes2[RPCCloseEventCodes2["RateLimited"] = 4002] = "RateLimited";
    RPCCloseEventCodes2[RPCCloseEventCodes2["TokenRevoked"] = 4003] = "TokenRevoked";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidVersion"] = 4004] = "InvalidVersion";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidEncoding"] = 4005] = "InvalidEncoding";
  })(RPCCloseEventCodes = exports.RPCCloseEventCodes || (exports.RPCCloseEventCodes = {}));
});

// node_modules/discord-api-types/rpc/v10.js
var require_v104 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_common4(), exports);
});

// node_modules/discord-api-types/utils/v10.js
var require_v105 = __commonJS((exports) => {
  var isDMInteraction = function(interaction) {
    return Reflect.has(interaction, "user");
  };
  var isGuildInteraction = function(interaction) {
    return Reflect.has(interaction, "guild_id");
  };
  var isApplicationCommandDMInteraction = function(interaction) {
    return isDMInteraction(interaction);
  };
  var isApplicationCommandGuildInteraction = function(interaction) {
    return isGuildInteraction(interaction);
  };
  var isMessageComponentDMInteraction = function(interaction) {
    return isDMInteraction(interaction);
  };
  var isMessageComponentGuildInteraction = function(interaction) {
    return isGuildInteraction(interaction);
  };
  var isLinkButton = function(component) {
    return component.style === index_1.ButtonStyle.Link;
  };
  var isInteractionButton = function(component) {
    return component.style !== index_1.ButtonStyle.Link;
  };
  var isMessageComponentInteraction = function(interaction) {
    return interaction.type === index_1.InteractionType.MessageComponent;
  };
  var isMessageComponentButtonInteraction = function(interaction) {
    return interaction.data.component_type === index_1.ComponentType.Button;
  };
  var isMessageComponentSelectMenuInteraction = function(interaction) {
    return [
      index_1.ComponentType.StringSelect,
      index_1.ComponentType.UserSelect,
      index_1.ComponentType.RoleSelect,
      index_1.ComponentType.MentionableSelect,
      index_1.ComponentType.ChannelSelect
    ].includes(interaction.data.component_type);
  };
  var isChatInputApplicationCommandInteraction = function(interaction) {
    return interaction.data.type === index_1.ApplicationCommandType.ChatInput;
  };
  var isContextMenuApplicationCommandInteraction = function(interaction) {
    return interaction.data.type === index_1.ApplicationCommandType.Message || interaction.data.type === index_1.ApplicationCommandType.User;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isContextMenuApplicationCommandInteraction = exports.isChatInputApplicationCommandInteraction = exports.isMessageComponentSelectMenuInteraction = exports.isMessageComponentButtonInteraction = exports.isMessageComponentInteraction = exports.isInteractionButton = exports.isLinkButton = exports.isMessageComponentGuildInteraction = exports.isMessageComponentDMInteraction = exports.isApplicationCommandGuildInteraction = exports.isApplicationCommandDMInteraction = exports.isGuildInteraction = exports.isDMInteraction = undefined;
  var index_1 = require_v102();
  exports.isDMInteraction = isDMInteraction;
  exports.isGuildInteraction = isGuildInteraction;
  exports.isApplicationCommandDMInteraction = isApplicationCommandDMInteraction;
  exports.isApplicationCommandGuildInteraction = isApplicationCommandGuildInteraction;
  exports.isMessageComponentDMInteraction = isMessageComponentDMInteraction;
  exports.isMessageComponentGuildInteraction = isMessageComponentGuildInteraction;
  exports.isLinkButton = isLinkButton;
  exports.isInteractionButton = isInteractionButton;
  exports.isMessageComponentInteraction = isMessageComponentInteraction;
  exports.isMessageComponentButtonInteraction = isMessageComponentButtonInteraction;
  exports.isMessageComponentSelectMenuInteraction = isMessageComponentSelectMenuInteraction;
  exports.isChatInputApplicationCommandInteraction = isChatInputApplicationCommandInteraction;
  exports.isContextMenuApplicationCommandInteraction = isContextMenuApplicationCommandInteraction;
});

// node_modules/discord-api-types/v10.js
var require_v106 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Utils = undefined;
  __exportStar(require_v10(), exports);
  __exportStar(require_globals(), exports);
  __exportStar(require_v102(), exports);
  __exportStar(require_v103(), exports);
  __exportStar(require_v104(), exports);
  exports.Utils = require_v105();
});

// node_modules/@discordjs/rest/node_modules/@discordjs/collection/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    findLast(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const val = entries[index][1];
        const key = entries[index][0];
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findLastKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const key = entries[index][0];
        const val = entries[index][1];
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    reduceRight(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      const entries = [...this.entries()];
      let accumulator;
      let index;
      if (initialValue === undefined) {
        if (entries.length === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = entries[entries.length - 1][1];
        index = entries.length - 1;
      } else {
        accumulator = initialValue;
        index = entries.length;
      }
      while (--index >= 0) {
        const key = entries[index][0];
        const val = entries[index][1];
        accumulator = fn(accumulator, val, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersection(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    union(other) {
      const coll = new this.constructor[Symbol.species](this);
      for (const [key, value] of other) {
        if (!coll.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    symmetricDifference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    toReversed() {
      return new this.constructor[Symbol.species](this).reverse();
    }
    toSorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.entries()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "2.0.0";
});

// node_modules/@sapphire/snowflake/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var cmpBigInt = function(a, b) {
    return a === b ? 0 : a < b ? -1 : 1;
  };
  var cmpString = function(a, b) {
    return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;
  };
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var IncrementSymbol = Symbol("@sapphire/snowflake.increment");
  var EpochSymbol = Symbol("@sapphire/snowflake.epoch");
  var ProcessIdSymbol = Symbol("@sapphire/snowflake.processId");
  var WorkerIdSymbol = Symbol("@sapphire/snowflake.workerId");
  var MaximumWorkerId = 0b11111n;
  var MaximumProcessId = 0b11111n;
  var MaximumIncrement = 0b111111111111n;
  var _a;
  var _b;
  var _c;
  var _d;
  var Snowflake = class {
    constructor(epoch) {
      __publicField(this, "decode", this.deconstruct);
      __publicField(this, _a);
      __publicField(this, _b, 0n);
      __publicField(this, _c, 1n);
      __publicField(this, _d, 0n);
      this[EpochSymbol] = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);
    }
    get epoch() {
      return this[EpochSymbol];
    }
    get processId() {
      return this[ProcessIdSymbol];
    }
    set processId(value) {
      this[ProcessIdSymbol] = BigInt(value) & MaximumProcessId;
    }
    get workerId() {
      return this[WorkerIdSymbol];
    }
    set workerId(value) {
      this[WorkerIdSymbol] = BigInt(value) & MaximumWorkerId;
    }
    generate({
      increment,
      timestamp = Date.now(),
      workerId = this[WorkerIdSymbol],
      processId = this[ProcessIdSymbol]
    } = {}) {
      if (timestamp instanceof Date)
        timestamp = BigInt(timestamp.getTime());
      else if (typeof timestamp === "number")
        timestamp = BigInt(timestamp);
      else if (typeof timestamp !== "bigint") {
        throw new TypeError(`"timestamp" argument must be a number, bigint, or Date (received ${typeof timestamp})`);
      }
      if (typeof increment !== "bigint") {
        increment = this[IncrementSymbol];
        this[IncrementSymbol] = increment + 1n & MaximumIncrement;
      }
      return timestamp - this[EpochSymbol] << 22n | (workerId & MaximumWorkerId) << 17n | (processId & MaximumProcessId) << 12n | increment & MaximumIncrement;
    }
    deconstruct(id) {
      const bigIntId = BigInt(id);
      const epoch = this[EpochSymbol];
      return {
        id: bigIntId,
        timestamp: (bigIntId >> 22n) + epoch,
        workerId: bigIntId >> 17n & MaximumWorkerId,
        processId: bigIntId >> 12n & MaximumProcessId,
        increment: bigIntId & MaximumIncrement,
        epoch
      };
    }
    timestampFrom(id) {
      return Number((BigInt(id) >> 22n) + this[EpochSymbol]);
    }
    static compare(a, b) {
      const typeA = typeof a;
      return typeA === typeof b ? typeA === "string" ? cmpString(a, b) : cmpBigInt(a, b) : cmpBigInt(BigInt(a), BigInt(b));
    }
  };
  __name(Snowflake, "Snowflake");
  _a = EpochSymbol, _b = IncrementSymbol, _c = ProcessIdSymbol, _d = WorkerIdSymbol;
  __name(cmpBigInt, "cmpBigInt");
  __name(cmpString, "cmpString");
  var DiscordSnowflake = new Snowflake(1420070400000n);
  var TwitterSnowflake = new Snowflake(1288834974657n);
  exports.DiscordSnowflake = DiscordSnowflake;
  exports.MaximumIncrement = MaximumIncrement;
  exports.MaximumProcessId = MaximumProcessId;
  exports.MaximumWorkerId = MaximumWorkerId;
  exports.Snowflake = Snowflake;
  exports.TwitterSnowflake = TwitterSnowflake;
});

// node_modules/@vladfrangu/async_event_emitter/dist/index.cjs
var require_dist4 = __commonJS((exports, module) => {
  var validateListener = function(input) {
    if (typeof input !== "function") {
      throw new TypeError(`The listener argument must be a function. Received ${typeof input}`);
    }
  };
  var validateAbortSignal = function(input) {
    if (input && !(input instanceof AbortSignal)) {
      throw new TypeError(`The signal option must be an AbortSignal. Received ${input}`);
    }
  };
  var spliceOne = function(list, index) {
    for (;index + 1 < list.length; index++) {
      list[index] = list[index + 1];
    }
    list.pop();
  };
  var arrayClone = function(arr) {
    switch (arr.length) {
      case 2:
        return [arr[0], arr[1]];
      case 3:
        return [arr[0], arr[1], arr[2]];
      case 4:
        return [arr[0], arr[1], arr[2], arr[3]];
      case 5:
        return [arr[0], arr[1], arr[2], arr[3], arr[4]];
      case 6:
        return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];
    }
    return arr.slice();
  };
  var identicalSequenceRange = function(a, b) {
    for (let i = 0;i < a.length - 3; i++) {
      const pos = b.indexOf(a[i]);
      if (pos !== -1) {
        const rest = b.length - pos;
        if (rest > 3) {
          let len = 1;
          const maxLen = Math.min(a.length - i, rest);
          while (maxLen > len && a[i + len] === b[pos + len]) {
            len++;
          }
          if (len > 3) {
            return [len, i];
          }
        }
      }
    }
    return [0, 0];
  };
  var enhanceStackTrace = function(err, own) {
    let ctorInfo = "";
    try {
      const { name } = this.constructor;
      if (name !== "AsyncEventEmitter")
        ctorInfo = ` on ${name} instance`;
    } catch {
    }
    const sep = `
Emitted 'error' event${ctorInfo} at:
`;
    const errStack = err.stack.split("\n").slice(1);
    const ownStack = own.stack.split("\n").slice(1);
    const { 0: len, 1: off } = identicalSequenceRange(ownStack, errStack);
    if (len > 0) {
      ownStack.splice(off + 1, len - 2, "    [... lines matching original stack trace ...]");
    }
    return err.stack + sep + ownStack.join("\n");
  };
  var onceWrapper = function() {
    if (!this.fired) {
      this.eventEmitter.removeListener(this.eventName, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0) {
        return this.listener.call(this.eventEmitter);
      }
      return this.listener.apply(this.eventEmitter, arguments);
    }
  };
  var getReason = function(signal) {
    return signal?.reason;
  };
  var eventTargetAgnosticRemoveListener = function(emitter, name, listener, flags) {
    if (typeof emitter.off === "function") {
      emitter.off(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
      emitter.removeEventListener(name, listener, flags);
    }
  };
  var eventTargetAgnosticAddListener = function(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags?.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, listener, flags);
    }
  };
  var createIterResult = function(value, done) {
    return { value, done };
  };
  var handleMaybeAsync = function(emitter, result) {
    try {
      const fin = result.finally;
      if (typeof fin === "function") {
        const promiseId = String(++emitter["_wrapperId"]);
        emitter["_internalPromiseMap"].set(promiseId, result);
        fin.call(result, __name(function final() {
          emitter["_internalPromiseMap"].delete(promiseId);
        }, "final"));
      }
    } catch (err) {
      emitter.emit("error", err);
    }
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    AbortError: () => AbortError,
    AsyncEventEmitter: () => AsyncEventEmitter
  });
  module.exports = __toCommonJS(src_exports);
  __name(validateListener, "validateListener");
  __name(validateAbortSignal, "validateAbortSignal");
  __name(spliceOne, "spliceOne");
  __name(arrayClone, "arrayClone");
  __name(identicalSequenceRange, "identicalSequenceRange");
  __name(enhanceStackTrace, "enhanceStackTrace");
  var _AsyncEventEmitter = class _AsyncEventEmitter2 {
    constructor() {
      this._events = {
        __proto__: null
      };
      this._eventCount = 0;
      this._maxListeners = 10;
      this._internalPromiseMap = new Map;
      this._wrapperId = 0n;
    }
    addListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, false);
      this._addListener(eventName, wrapped, false);
      return this;
    }
    on(eventName, listener) {
      return this.addListener(eventName, listener);
    }
    once(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, true);
      this._addListener(eventName, wrapped, false);
      return this;
    }
    removeListener(eventName, listener) {
      validateListener(listener);
      const events = this._events;
      const eventList = events[eventName];
      if (eventList === undefined) {
        return this;
      }
      if (eventList === listener || eventList.listener === listener) {
        if (--this._eventCount === 0) {
          this._events = { __proto__: null };
        } else {
          delete events[eventName];
          if (events.removeListener) {
            this.emit("removeListener", eventName, eventList.listener ?? eventList);
          }
        }
      } else if (typeof eventList !== "function") {
        let position = -1;
        for (let i = eventList.length - 1;i >= 0; i--) {
          if (eventList[i] === listener || eventList[i].listener === listener) {
            position = i;
            break;
          }
        }
        if (position < 0) {
          return this;
        }
        if (position === 0) {
          eventList.shift();
        } else {
          spliceOne(eventList, position);
        }
        if (eventList.length === 0) {
          delete events[eventName];
          --this._eventCount;
        }
        if (events.removeListener !== undefined) {
          this.emit("removeListener", eventName, listener);
        }
      }
      return this;
    }
    off(eventName, listener) {
      return this.removeListener(eventName, listener);
    }
    removeAllListeners(event) {
      const events = this._events;
      if (events.removeListener === undefined) {
        if (!event) {
          this._events = { __proto__: null };
          this._eventCount = 0;
        } else if (events[event] !== undefined) {
          if (--this._eventCount === 0) {
            this._events = { __proto__: null };
          } else {
            delete events[event];
          }
        }
        return this;
      }
      if (!event) {
        for (const key of Reflect.ownKeys(events)) {
          if (key === "removeListener") {
            continue;
          }
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = { __proto__: null };
        this._eventCount = 0;
        return this;
      }
      const listeners = events[event];
      if (typeof listeners === "function") {
        this.removeListener(event, listeners);
      } else if (listeners !== undefined) {
        for (let i = listeners.length - 1;i >= 0; i--) {
          this.removeListener(event, listeners[i]);
        }
      }
      return this;
    }
    setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new RangeError(`Expected to get a non-negative number for "setMaxListeners", got ${n} instead`);
      }
      this._maxListeners = n;
      return this;
    }
    getMaxListeners() {
      return this._maxListeners;
    }
    listeners(eventName) {
      const eventList = this._events[eventName];
      if (eventList === undefined) {
        return [];
      }
      if (typeof eventList === "function") {
        return [eventList.listener ?? eventList];
      }
      const ret = arrayClone(eventList);
      for (let i = 0;i < ret.length; ++i) {
        const orig = ret[i].listener;
        if (typeof orig === "function") {
          ret[i] = orig;
        }
      }
      return ret;
    }
    rawListeners(eventName) {
      const eventList = this._events[eventName];
      if (eventList === undefined) {
        return [];
      }
      if (typeof eventList === "function") {
        return [eventList];
      }
      return arrayClone(eventList);
    }
    emit(eventName, ...args) {
      let doError = eventName === "error";
      const events = this._events;
      if (events !== undefined) {
        doError = doError && events.error === undefined;
      } else if (!doError) {
        return false;
      }
      if (doError) {
        let er;
        if (args.length > 0) {
          er = args[0];
        }
        if (er instanceof Error) {
          try {
            const capture = {};
            Error.captureStackTrace(capture, _AsyncEventEmitter2.prototype.emit);
            Object.defineProperty(er, "stack", {
              value: enhanceStackTrace.call(this, er, capture),
              configurable: true
            });
          } catch {
          }
          throw er;
        }
        const stringifiedError = String(er);
        const err = new Error(`Unhandled 'error' event emitted, received ${stringifiedError}`);
        err.context = er;
        throw err;
      }
      const handlers = events[eventName];
      if (handlers === undefined) {
        return false;
      }
      if (typeof handlers === "function") {
        const result = handlers.apply(this, args);
        if (result !== undefined && result !== null) {
          handleMaybeAsync(this, result);
        }
      } else {
        const len = handlers.length;
        const listeners = arrayClone(handlers);
        for (let i = 0;i < len; ++i) {
          const result = listeners[i].apply(this, args);
          if (result !== undefined && result !== null) {
            handleMaybeAsync(this, result);
          }
        }
      }
      return true;
    }
    listenerCount(eventName) {
      const events = this._events;
      if (events === undefined) {
        return 0;
      }
      const eventListeners = events[eventName];
      if (typeof eventListeners === "function") {
        return 1;
      }
      return eventListeners?.length ?? 0;
    }
    prependListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, false);
      this._addListener(eventName, wrapped, true);
      return this;
    }
    prependOnceListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, true);
      this._addListener(eventName, wrapped, true);
      return this;
    }
    eventNames() {
      return this._eventCount > 0 ? Reflect.ownKeys(this._events) : [];
    }
    async waitForAllListenersToComplete() {
      const promises = [...this._internalPromiseMap.values()];
      if (promises.length === 0) {
        return false;
      }
      await Promise.all(promises);
      return true;
    }
    _addListener(eventName, wrappedListener, prepend) {
      if (this._events.newListener !== undefined) {
        this.emit("newListener", eventName, wrappedListener.listener ?? wrappedListener);
      }
      let existing = this._events[eventName];
      if (existing === undefined) {
        existing = this._events[eventName] = wrappedListener;
        ++this._eventCount;
      } else if (typeof existing === "function") {
        existing = this._events[eventName] = prepend ? [wrappedListener, existing] : [existing, wrappedListener];
      } else if (prepend) {
        existing.unshift(wrappedListener);
      } else {
        existing.push(wrappedListener);
      }
      if (this._maxListeners > 0 && existing.length > this._maxListeners && !existing._hasWarnedAboutMaxListeners) {
        existing._hasWarnedAboutMaxListeners = true;
        const warningMessage = [
          `Possible AsyncEventEmitter memory leak detected. ${existing.length} ${String(eventName)} listeners added to ${this.constructor.name}.`,
          `Use emitter.setMaxListeners() to increase the limit.`
        ].join(" ");
        console.warn(warningMessage);
      }
    }
    _wrapListener(eventName, listener, once) {
      if (!once) {
        return listener;
      }
      const state = {
        fired: false,
        wrapFn: undefined,
        eventEmitter: this,
        eventName,
        listener
      };
      const aliased = onceWrapper;
      const wrapped = aliased.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    static listenerCount(emitter, eventName) {
      return emitter.listenerCount(eventName);
    }
    static async once(emitter, eventName, options = {}) {
      const signal = options?.signal;
      validateAbortSignal(signal);
      if (signal?.aborted) {
        throw new AbortError(undefined, { cause: getReason(signal) });
      }
      return new Promise((resolve, reject) => {
        const errorListener = __name((err) => {
          emitter.removeListener(eventName, resolver);
          if (signal) {
            eventTargetAgnosticRemoveListener(emitter, eventName, abortListener);
          }
          reject(err);
        }, "errorListener");
        const resolver = __name((...args) => {
          emitter.removeListener("error", errorListener);
          if (signal) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          resolve(args);
        }, "resolver");
        emitter.once(eventName, resolver);
        if (eventName !== "error") {
          emitter.once("error", errorListener);
        }
        const abortListener = __name(() => {
          eventTargetAgnosticRemoveListener(emitter, eventName, resolver);
          eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
          reject(new AbortError(undefined, { cause: getReason(signal) }));
        }, "abortListener");
        if (signal) {
          eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
        }
      });
    }
    static on(emitter, eventName, options = {}) {
      const signal = options?.signal;
      validateAbortSignal(signal);
      if (signal?.aborted) {
        throw new AbortError(undefined, { cause: getReason(signal) });
      }
      const unconsumedEvents = [];
      const unconsumedPromises = [];
      let error = null;
      let finished = false;
      const abortListener = __name(() => {
        errorHandler(new AbortError(undefined, { cause: getReason(signal) }));
      }, "abortListener");
      const eventHandler = __name((...args) => {
        const promise = unconsumedPromises.shift();
        if (promise) {
          promise.resolve(createIterResult(args, false));
        } else {
          unconsumedEvents.push(args);
        }
      }, "eventHandler");
      const errorHandler = __name((err) => {
        finished = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
          toError.reject(err);
        } else {
          error = err;
        }
        iterator.return();
      }, "errorHandler");
      const iterator = Object.setPrototypeOf({
        next() {
          const value = unconsumedEvents.shift();
          if (value) {
            return Promise.resolve(createIterResult(value, false));
          }
          if (error) {
            const p = Promise.reject(error);
            error = null;
            return p;
          }
          if (finished) {
            return Promise.resolve(createIterResult(undefined, true));
          }
          return new Promise((resolve, reject) => {
            unconsumedPromises.push({ resolve, reject });
          });
        },
        return() {
          emitter.off(eventName, eventHandler);
          emitter.off("error", errorHandler);
          if (signal) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          finished = true;
          const doneResult = createIterResult(undefined, true);
          for (const promise of unconsumedPromises) {
            promise.resolve(doneResult);
          }
          return Promise.resolve(doneResult);
        },
        throw(err) {
          if (!err || !(err instanceof Error)) {
            throw new TypeError(`Expected Error instance to be thrown in AsyncEventEmitter.AsyncIterator. Got ${err}`);
          }
          error = err;
          emitter.off(eventName, eventHandler);
          emitter.off("error", errorHandler);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      }, AsyncIteratorPrototype);
      emitter.on(eventName, eventHandler);
      if (eventName !== "error") {
        emitter.on("error", errorHandler);
      }
      if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener);
      }
      return iterator;
    }
  };
  __name(_AsyncEventEmitter, "AsyncEventEmitter");
  var AsyncEventEmitter = _AsyncEventEmitter;
  __name(onceWrapper, "onceWrapper");
  __name(getReason, "getReason");
  __name(eventTargetAgnosticRemoveListener, "eventTargetAgnosticRemoveListener");
  __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
  var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
  }).prototype);
  __name(createIterResult, "createIterResult");
  var _AbortError = class _AbortError2 extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object") {
        throw new TypeError(`Failed to create AbortError: options is not an object or undefined`);
      }
      super(message, options);
      this.code = "ABORT_ERR";
      this.name = "AbortError";
    }
  };
  __name(_AbortError, "AbortError");
  var AbortError = _AbortError;
  __name(handleMaybeAsync, "handleMaybeAsync");
});

// node_modules/magic-bytes.js/dist/model/toHex.js
var require_toHex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromHex = exports.toHex = undefined;
  var hex = (num) => new Number(num).toString(16).toLowerCase();
  var toHex = (num) => `0x${hex(num).length === 1 ? "0" + hex(num) : hex(num)}`;
  exports.toHex = toHex;
  var fromHex = (hex2) => new Number(hex2);
  exports.fromHex = fromHex;
});

// node_modules/magic-bytes.js/dist/model/tree.js
var require_tree = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createComplexNode = exports.createNode = exports.merge = undefined;
  var createMatch = (leaf) => ({
    typename: leaf.typename,
    mime: leaf.info.mime,
    extension: leaf.info.extension
  });
  var isMatchingNode = (tree, path) => tree && path.length === 0;
  var head = (arr) => arr[0];
  var tail = (arr) => arr.slice(1, arr.length);
  var merge = (node, tree) => {
    if (node.bytes.length === 0)
      return tree;
    const currentByte = head(node.bytes);
    const path = tail(node.bytes);
    const currentTree = tree.bytes[currentByte];
    if (isMatchingNode(currentTree, path)) {
      const matchingNode = tree.bytes[currentByte];
      tree.bytes[currentByte] = {
        ...matchingNode,
        matches: [
          ...matchingNode.matches ? matchingNode.matches : [],
          createMatch(node)
        ]
      };
      return tree;
    }
    if (tree.bytes[currentByte]) {
      tree.bytes[currentByte] = exports.merge(exports.createNode(node.typename, path, node.info), tree.bytes[currentByte]);
      return tree;
    }
    if (!tree.bytes[currentByte]) {
      tree.bytes[currentByte] = {
        ...tree.bytes[currentByte],
        ...exports.createComplexNode(node.typename, path, node.info)
      };
    }
    return tree;
  };
  exports.merge = merge;
  var createNode = (typename, bytes, info) => {
    return { typename, bytes, info: info ? info : {} };
  };
  exports.createNode = createNode;
  var createComplexNode = (typename, bytes, info) => {
    let obj = {
      bytes: {},
      matches: undefined
    };
    const currentKey = head(bytes);
    const path = tail(bytes);
    if (bytes.length === 0) {
      return {
        matches: [
          createMatch({
            typename,
            info: info ? { extension: info.extension, mime: info.mime } : {}
          })
        ],
        bytes: {}
      };
    }
    obj.bytes[currentKey] = exports.createComplexNode(typename, path, info);
    return obj;
  };
  exports.createComplexNode = createComplexNode;
});

// node_modules/magic-bytes.js/dist/model/pattern-tree.js
var require_pattern_tree = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var toHex_1 = require_toHex();
  var tree_1 = require_tree();
  var tree = {
    noOffset: null,
    offset: {}
  };
  var add = (typename, signature, additionalInfo, offset) => {
    if (offset) {
      const existing = tree.offset[toHex_1.toHex(offset)];
      if (!existing) {
        tree.offset[toHex_1.toHex(offset)] = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
      } else {
        const merged = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), { ...existing });
        tree.offset[toHex_1.toHex(offset)] = merged;
      }
    } else {
      if (tree.noOffset === null) {
        tree.noOffset = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
      } else {
        tree.noOffset = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), tree.noOffset);
      }
    }
  };
  add("gif", ["0x47", "0x49", "0x46", "0x38", "0x37", "0x61"], {
    mime: "image/gif",
    extension: "gif"
  });
  add("gif", ["0x47", "0x49", "0x46", "0x38", "0x39", "0x61"], {
    mime: "image/gif",
    extension: "gif"
  });
  add("jpg", ["0xFF", "0xD8", "0xFF"], {
    mime: "image/jpeg",
    extension: "jpeg"
  });
  add("jpg", ["0xFF", "0xD8", "0xFF", "0xDB"], {
    mime: "image/jpeg",
    extension: "jpeg"
  });
  add("jpg", [
    "0xFF",
    "0xD8",
    "0xFF",
    "0xE0",
    "?",
    "?",
    "0x4A",
    "0x46",
    "0x49",
    "0x46",
    "0x00",
    "0x01"
  ], { mime: "image/jpeg", extension: "jpeg" });
  add("jpg", [
    "0xFF",
    "0xD8",
    "0xFF",
    "0xE1",
    "?",
    "?",
    "0x45",
    "0x78",
    "0x69",
    "0x66",
    "0x00",
    "0x00"
  ], { mime: "image/jpeg", extension: "jpeg" });
  add("webp", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x45",
    "0x42",
    "0x50"
  ], { mime: "image/webp", extension: "webp" });
  add("heif", ["0x66", "0x74", "0x79", "0x70", "0x6D", "0x69", "0x66", "0x31"], { mime: "image/heif", extension: "heif" }, 4);
  add("heif", ["0x66", "0x74", "0x79", "0x70", "0x68", "0x65", "0x69", "0x63"], { mime: "image/heif", extension: "heic" }, 4);
  add("rpm", ["0xed", "0xab", "0xee", "0xdb"]);
  add("bin", ["0x53", "0x50", "0x30", "0x31"], {
    mime: "application/octet-stream",
    extension: "bin"
  });
  add("pic", ["0x00"]);
  add("pif", ["0x00"]);
  add("sea", ["0x00"]);
  add("ytr", ["0x00"]);
  add("mp4", ["0x66", "0x74", "0x79", "0x70"], { mime: "video/mp4", extension: "mp4" }, 4);
  add("ttf", ["0x00", "0x01", "0x00", "0x00", "0x00"], {
    mime: "font/ttf",
    extension: "ttf"
  });
  add("otf", ["0x4F", "0x54", "0x54", "0x4F"], {
    mime: "font/otf",
    extension: "otf"
  });
  add("eot", ["0x50", "0x4C"], {
    mime: "application/vnd.ms-fontobject",
    extension: "eot"
  });
  add("woff", ["0x77", "0x4F", "0x46", "0x46"], {
    mime: "font/woff",
    extension: "woff"
  });
  add("woff2", ["0x77", "0x4F", "0x46", "0x32"], {
    mime: "font/woff2",
    extension: "woff2"
  });
  add("pdb", [
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
  ]);
  add("dba", ["0xBE", "0xBA", "0xFE", "0xCA"]);
  add("dba2", ["0x00", "0x01", "0x42", "0x44"]);
  add("tda", ["0x00", "0x01", "0x44", "0x54"]);
  add("tda2", ["0x00", "0x01", "0x00", "0x00"]);
  add("ico", ["0x00", "0x00", "0x01", "0x00"], {
    mime: "image/x-icon",
    extension: "ico"
  });
  add("3gp", ["0x66", "0x74", "0x79", "0x70", "0x33", "0x67"]);
  add("z", ["0x1F", "0x9D"]);
  add("tar.z", ["0x1F", "0xA0"]);
  add("bac", [
    "0x42",
    "0x41",
    "0x43",
    "0x4B",
    "0x4D",
    "0x49",
    "0x4B",
    "0x45",
    "0x44",
    "0x49",
    "0x53",
    "0x4B"
  ]);
  add("bz2", ["0x42", "0x5A", "0x68"], {
    mime: "application/x-bzip2",
    extension: "bz2"
  });
  add("tif", ["0x49", "0x49", "0x2A", "0x00"], {
    mime: "image/tiff",
    extension: "tif"
  });
  add("tiff", ["0x4D", "0x4D", "0x00", "0x2A"], {
    mime: "image/tiff",
    extension: "tiff"
  });
  add("cr2", [
    "0x49",
    "0x49",
    "0x2A",
    "0x00",
    "0x10",
    "0x00",
    "0x00",
    "0x00",
    "0x43",
    "0x52"
  ]);
  add("cin", ["0x80", "0x2A", "0x5F", "0xD7"]);
  add("cin1", ["0x52", "0x4E", "0x43", "0x01"]);
  add("cin2", ["0x52", "0x4E", "0x43", "0x02"]);
  add("dpx", ["0x53", "0x44", "0x50", "0x58"]);
  add("dpx2", ["0x58", "0x50", "0x44", "0x53"]);
  add("exr", ["0x76", "0x2F", "0x31", "0x01"]);
  add("bpg", ["0x42", "0x50", "0x47", "0xFB"]);
  add("ilbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x49",
    "0x4C",
    "0x42",
    "0x4D"
  ]);
  add("8svx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x38",
    "0x53",
    "0x56",
    "0x58"
  ]);
  add("acbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x43",
    "0x42",
    "0x4D"
  ]);
  add("anbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x42",
    "0x4D"
  ]);
  add("anim", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x49",
    "0x4D"
  ]);
  add("faxx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x58",
    "0x58"
  ]);
  add("ftxt", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x54",
    "0x58",
    "0x54"
  ]);
  add("smus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x53",
    "0x4D",
    "0x55",
    "0x53"
  ]);
  add("cmus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x43",
    "0x4D",
    "0x55",
    "0x53"
  ]);
  add("yuvn", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x59",
    "0x55",
    "0x56",
    "0x4E"
  ]);
  add("iff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x4E",
    "0x54"
  ]);
  add("aiff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x49",
    "0x46",
    "0x46"
  ], { mime: "audio/x-aiff", extension: "aiff" });
  add("idx", ["0x49", "0x4E", "0x44", "0x58"]);
  add("lz", ["0x4C", "0x5A", "0x49", "0x50"]);
  add("exe", ["0x4D", "0x5A"]);
  add("zip", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/zip",
    extension: "zip"
  });
  add("zip", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/zip",
    extension: "zip"
  });
  add("zip", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/zip",
    extension: "zip"
  });
  add("jar", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  add("jar", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  add("jar", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  add("odt", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  add("odt", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  add("odt", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  add("ods", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  add("ods", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  add("ods", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  add("odp", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  add("odp", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  add("odp", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  add("docx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  add("docx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  add("docx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  add("xlsx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  add("xlsx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  add("xlsx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  add("pptx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  add("pptx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  add("pptx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  add("vsdx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  add("vsdx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  add("vsdx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
  });
  add("apk", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  add("apk", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  add("apk", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
  });
  add("aar", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  add("aar", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  add("aar", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
  });
  add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x00"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x01", "0x00"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  add("rar", ["0x7F", "0x45", "0x4C", "0x46"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  add("png", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
    mime: "image/png",
    extension: "png"
  });
  add("apng", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
    mime: "image/apng",
    extension: "apng"
  });
  add("class", ["0xCA", "0xFE", "0xBA", "0xBE"]);
  add("class", ["0xEF", "0xBB", "0xBF"]);
  add("class", ["0xFE", "0xed", "0xFA", "0xCE"], undefined, 4096);
  add("class", ["0xFE", "0xed", "0xFA", "0xCF"], undefined, 4096);
  add("class", ["0xCE", "0xFA", "0xed", "0xFE"]);
  add("class", ["0xCF", "0xFA", "0xed", "0xFE"]);
  add("class", ["0xFF", "0xFE"]);
  add("class", ["0xFF", "0xFE"]);
  add("class", ["0xFF", "0xFE", "0x00", "0x00"]);
  add("ps", ["0x25", "0x21", "0x50", "0x53"]);
  add("pdf", ["0x25", "0x50", "0x44", "0x46"], {
    mime: "application/pdf",
    extension: "pdf"
  });
  add("asf", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  add("wma", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  add("wmv", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  add("deploymentimage", [
    "0x24",
    "0x53",
    "0x44",
    "0x49",
    "0x30",
    "0x30",
    "0x30",
    "0x31"
  ]);
  add("ogv", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x80",
    "0x74",
    "0x68",
    "0x65",
    "0x6F",
    "0x72",
    "0x61"
  ], {
    mime: "video/ogg",
    extension: "ogv"
  });
  add("ogm", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x01",
    "0x76",
    "0x69",
    "0x64",
    "0x65",
    "0x6F",
    "0x00"
  ], {
    mime: "video/ogg",
    extension: "ogm"
  });
  add("oga", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x7F",
    "0x46",
    "0x4C",
    "0x41",
    "0x43"
  ], {
    mime: "audio/ogg",
    extension: "oga"
  });
  add("spx", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x53",
    "0x70",
    "0x65",
    "0x65",
    "0x78",
    "0x20",
    "0x20"
  ], {
    mime: "audio/ogg",
    extension: "spx"
  });
  add("ogg", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x01",
    "0x76",
    "0x6F",
    "0x72",
    "0x62",
    "0x69",
    "0x73"
  ], {
    mime: "audio/ogg",
    extension: "ogg"
  });
  add("ogx", ["0x4F", "0x67", "0x67", "0x53"], {
    mime: "application/ogg",
    extension: "ogx"
  });
  add("psd", ["0x38", "0x42", "0x50", "0x53"], {
    mime: "application/x-photoshop",
    extension: "psd"
  });
  add("clip", ["0x43", "0x53", "0x46", "0x43", "0x48", "0x55", "0x4e", "0x4b"]);
  add("wav", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x41",
    "0x56",
    "0x45"
  ], { mime: "audio/x-wav", extension: "wav" });
  add("avi", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x56",
    "0x49",
    "0x20"
  ], { mime: "video/x-msvideo", extension: "avi" });
  add("mp3", ["0xFF", "0xFB"], { mime: "audio/mpeg", extension: "mp3" });
  add("mp3", ["0xFF", "0xF3"], { mime: "audio/mpeg", extension: "mp3" });
  add("mp3", ["0xFF", "0xF2"], { mime: "audio/mpeg", extension: "mp3" });
  add("mp3", ["0x49", "0x44", "0x33"], { mime: "audio/mpeg", extension: "mp3" });
  add("bmp", ["0x42", "0x4D"], { mime: "image/bmp", extension: "bmp" });
  add("iso", ["0x43", "0x44", "0x30", "0x30", "0x31"]);
  add("flac", ["0x66", "0x4C", "0x61", "0x43"]);
  add("mid", ["0x4D", "0x54", "0x68", "0x64"], {
    mime: "audio/midi",
    extension: "mid"
  });
  add("midi", ["0x4D", "0x54", "0x68", "0x64"], {
    mime: "audio/midi",
    extension: "midi"
  });
  add("doc", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/msword",
    extension: "doc"
  });
  add("xls", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/vnd.ms-excel",
    extension: "xls"
  });
  add("ppt", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/vnd.ms-powerpoint",
    extension: "ppt"
  });
  add("msg", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"]);
  add("dex", ["0x64", "0x65", "0x78", "0x0A", "0x30", "0x33", "0x35", "0x00"]);
  add("vmdk", ["0x4B", "0x44", "0x4D"]);
  add("crx", ["0x43", "0x72", "0x32", "0x34"]);
  add("fh8", ["0x41", "0x47", "0x44", "0x33"]);
  add("cwk", [
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
  ]);
  add("cwk", [
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
  ]);
  add("toast", ["0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
  add("toast", ["0x8B", "0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
  add("dmg", ["0x78", "0x01", "0x73", "0x0D", "0x62", "0x62", "0x60"]);
  add("xar", ["0x78", "0x61", "0x72", "0x21"]);
  add("dat", ["0x50", "0x4D", "0x4F", "0x43", "0x43", "0x4D", "0x4F", "0x43"]);
  add("nes", ["0x4E", "0x45", "0x53", "0x1A"]);
  add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x00", "0x30", "0x30"], undefined, 257);
  add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x20", "0x20", "0x00"], undefined, 257);
  add("tox", ["0x74", "0x6F", "0x78", "0x33"]);
  add("mlv", ["0x4D", "0x4C", "0x56", "0x49"]);
  add("windowsupdate", [
    "0x44",
    "0x43",
    "0x4D",
    "0x01",
    "0x50",
    "0x41",
    "0x33",
    "0x30"
  ]);
  add("7z", ["0x37", "0x7A", "0xBC", "0xAF", "0x27", "0x1C"], {
    mime: "application/x-7z-compressed",
    extension: "7z"
  });
  add("gz", ["0x1F", "0x8B"], { mime: "application/gzip", extension: "gz" });
  add("tar.gz", ["0x1F", "0x8B"], {
    mime: "application/gzip",
    extension: "tar.gz"
  });
  add("xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
    mime: "application/gzip",
    extension: "xz"
  });
  add("tar.xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
    mime: "application/gzip",
    extension: "tar.xz"
  });
  add("lz2", ["0x04", "0x22", "0x4D", "0x18"]);
  add("cab", ["0x4D", "0x53", "0x43", "0x46"]);
  add("mkv", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "video/x-matroska",
    extension: "mkv"
  });
  add("mka", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "audio/x-matroska",
    extension: "mka"
  });
  add("mks", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "video/x-matroska",
    extension: "mks"
  });
  add("mk3d", ["0x1A", "0x45", "0xDF", "0xA3"]);
  add("webm", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "audio/webm",
    extension: "webm"
  });
  add("dcm", ["0x44", "0x49", "0x43", "0x4D"], undefined, 128);
  add("xml", ["0x3C", "0x3f", "0x78", "0x6d", "0x6C", "0x20"], {
    mime: "application/xml",
    extension: "xml"
  });
  add("wasm", ["0x00", "0x61", "0x73", "0x6d"], {
    mime: "application/wasm",
    extension: "wasm"
  });
  add("lep", ["0xCF", "0x84", "0x01"]);
  add("swf", ["0x43", "0x57", "0x53"], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
  });
  add("swf", ["0x46", "0x57", "0x53"], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
  });
  add("deb", ["0x21", "0x3C", "0x61", "0x72", "0x63", "0x68", "0x3E"]);
  add("rtf", ["0x7B", "0x5C", "0x72", "0x74", "0x66", "0x31"], {
    mime: "application/rtf",
    extension: "rtf"
  });
  add("m2p", ["0x00", "0x00", "0x01", "0xBA"]);
  add("vob", ["0x00", "0x00", "0x01", "0xBA"]);
  add("mpg", ["0x00", "0x00", "0x01", "0xBA"], {
    mime: "video/mpeg",
    extension: "mpg"
  });
  add("mpeg", ["0x00", "0x00", "0x01", "0xBA"], {
    mime: "video/mpeg",
    extension: "mpeg"
  });
  add("mpeg", ["0x47"], { mime: "video/mpeg", extension: "mpeg" });
  add("mpeg", ["0x00", "0x00", "0x01", "0xB3"], {
    mime: "video/mpeg",
    extension: "mpeg"
  });
  add("mov", ["0x66", "0x72", "0x65", "0x65"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  add("mov", ["0x6D", "0x64", "0x61", "0x74"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  add("mov", ["0x6D", "0x6F", "0x6F", "0x76"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  add("mov", ["0x77", "0x69", "0x64", "0x65"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  add("mov", ["0x66", "0x74", "0x79", "0x70", "0x71", "0x74"], {
    mime: "video/quicktime",
    extension: "mov"
  }, 4);
  add("hl2demo", ["0x48", "0x4C", "0x32", "0x44", "0x45", "0x4D", "0x4F"]);
  add("txt", ["0xEF", "0xBB", "0xBF"], {
    mime: "text/plain; charset=UTF-8",
    extension: "txt"
  });
  add("txt", ["0xFF", "0xFE"], {
    mime: "text/plain; charset=UTF-16LE",
    extension: "txt"
  });
  add("txt", ["0xFE", "0xFF"], {
    mime: "text/plain; charset=UTF-16BE",
    extension: "txt"
  });
  add("txt", ["0xFF", "0xFE", "0x00", "0x00"], {
    mime: "text/plain; charset=UTF-32LE",
    extension: "txt"
  });
  add("txt", ["0x00", "0x00", "0xFE", "0xFF"], {
    mime: "text/plain; charset=UTF-32BE",
    extension: "txt"
  });
  add("SubRip", ["0x31", "0x0D", "0x0A", "0x30", "0x30", "0x3A"], {
    mime: "application/x-subrip",
    extension: "srt"
  });
  add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0A"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0D"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x20"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x09"
  ], {
    mime: "text/vtt",
    extension: "vtt"
  });
  add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x0A"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x0D"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x20"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  add("WebVTT", ["0x57", "0x45", "0x42", "0x56", "0x54", "0x54", "0x09"], {
    mime: "text/vtt",
    extension: "vtt"
  });
  add("Json", ["0x7B"], {
    mime: "application/json",
    extension: ".json"
  });
  add("Json", ["0x5B"], {
    mime: "application/json",
    extension: ".json"
  });
  add("ELF", ["0x7F", "0x45", "0x4C", "0x46"], {
    mime: "application/x-executable",
    extension: ".elf"
  });
  add("Mach-O", ["0xFE", "0xED", "0xFA", "0xC"], {
    mime: "application/x-mach-binary",
    extension: ".o"
  });
  add("Mach-O", ["0xFE", "0xED", "0xFA", "0xCF"], {
    mime: "application/x-executable",
    extension: "elf"
  });
  add("EML", ["0x52", "0x65", "0x63", "0x65", "0x69", "0x76", "0x65", "0x64", "0x3A"], {
    mime: "message/rfc822",
    extension: ".eml"
  });
  exports.default = () => tree;
});

// node_modules/magic-bytes.js/dist/index.js
var require_dist5 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filetypeextension = exports.filetypemime = exports.filetypename = exports.filetypeinfo = undefined;
  var pattern_tree_1 = __importDefault(require_pattern_tree());
  var toHex_1 = require_toHex();
  var patternTree = pattern_tree_1.default();
  var filetypeinfo = (bytes) => {
    let tree = patternTree;
    for (const k of Object.keys(tree.offset)) {
      const offset = toHex_1.fromHex(k);
      const offsetExceedsFile = offset >= bytes.length;
      if (offsetExceedsFile) {
        continue;
      }
      const node = patternTree.offset[k];
      const guessed = walkTree(offset, bytes, node);
      if (guessed.length > 0) {
        return guessed;
      }
    }
    if (tree.noOffset === null) {
      return [];
    }
    return walkTree(0, bytes, tree.noOffset);
  };
  exports.filetypeinfo = filetypeinfo;
  var walkTree = (index, bytes, node) => {
    let step = node;
    let guessFile = [];
    while (true) {
      const currentByte = toHex_1.toHex(bytes[index]);
      if (step.bytes["?"] && !step.bytes[currentByte]) {
        step = step.bytes["?"];
      } else {
        step = step.bytes[currentByte];
      }
      if (!step) {
        return guessFile;
      }
      if (step && step.matches) {
        guessFile = step.matches.slice(0);
      }
      index += 1;
    }
  };
  exports.default = exports.filetypeinfo;
  var filetypename = (bytes) => exports.filetypeinfo(bytes).map((e) => e.typename);
  exports.filetypename = filetypename;
  var filetypemime = (bytes) => exports.filetypeinfo(bytes).map((e) => e.mime ? e.mime : null).filter((x) => x !== null);
  exports.filetypemime = filetypemime;
  var filetypeextension = (bytes) => exports.filetypeinfo(bytes).map((e) => e.extension ? e.extension : null).filter((x) => x !== null);
  exports.filetypeextension = filetypeextension;
});

// node_modules/@sapphire/async-queue/dist/cjs/index.cjs
var require_cjs = __commonJS((exports) => {
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var _AsyncQueueEntry = class _AsyncQueueEntry2 {
    constructor(queue) {
      __publicField(this, "promise");
      __publicField(this, "resolve");
      __publicField(this, "reject");
      __publicField(this, "queue");
      __publicField(this, "signal", null);
      __publicField(this, "signalListener", null);
      this.queue = queue;
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
    }
    setSignal(signal) {
      if (signal.aborted)
        return this;
      this.signal = signal;
      this.signalListener = () => {
        const index = this.queue["promises"].indexOf(this);
        if (index !== -1)
          this.queue["promises"].splice(index, 1);
        this.reject(new Error("Request aborted manually"));
      };
      this.signal.addEventListener("abort", this.signalListener);
      return this;
    }
    use() {
      this.dispose();
      this.resolve();
      return this;
    }
    abort() {
      this.dispose();
      this.reject(new Error("Request aborted manually"));
      return this;
    }
    dispose() {
      if (this.signal) {
        this.signal.removeEventListener("abort", this.signalListener);
        this.signal = null;
        this.signalListener = null;
      }
    }
  };
  __name(_AsyncQueueEntry, "AsyncQueueEntry");
  var AsyncQueueEntry = _AsyncQueueEntry;
  var _AsyncQueue = class _AsyncQueue2 {
    constructor() {
      __publicField(this, "promises", []);
    }
    get remaining() {
      return this.promises.length;
    }
    get queued() {
      return this.remaining === 0 ? 0 : this.remaining - 1;
    }
    wait(options) {
      const entry = new AsyncQueueEntry(this);
      if (this.promises.length === 0) {
        this.promises.push(entry);
        return Promise.resolve();
      }
      this.promises.push(entry);
      if (options?.signal)
        entry.setSignal(options.signal);
      return entry.promise;
    }
    shift() {
      if (this.promises.length === 0)
        return;
      if (this.promises.length === 1) {
        this.promises.shift();
        return;
      }
      this.promises.shift();
      this.promises[0].use();
    }
    abortAll() {
      if (this.queued === 0)
        return;
      for (let i = 1;i < this.promises.length; ++i) {
        this.promises[i].abort();
      }
      this.promises.length = 1;
    }
  };
  __name(_AsyncQueue, "AsyncQueue");
  var AsyncQueue = _AsyncQueue;
  exports.AsyncQueue = AsyncQueue;
});

// node_modules/@discordjs/rest/dist/index.js
var require_dist6 = __commonJS((exports, module) => {
  var setDefaultStrategy = function(newStrategy) {
    defaultStrategy = newStrategy;
  };
  var getDefaultStrategy = function() {
    return defaultStrategy;
  };
  async function makeRequest(url, init) {
    const options = {
      ...init,
      body: await resolveBody(init.body)
    };
    const res = await (0, import_undici.request)(url, options);
    return {
      body: res.body,
      async arrayBuffer() {
        return res.body.arrayBuffer();
      },
      async json() {
        return res.body.json();
      },
      async text() {
        return res.body.text();
      },
      get bodyUsed() {
        return res.body.bodyUsed;
      },
      headers: new import_undici.Headers(res.headers),
      status: res.statusCode,
      statusText: import_node_http.STATUS_CODES[res.statusCode],
      ok: res.statusCode >= 200 && res.statusCode < 300
    };
  }
  async function resolveBody(body) {
    if (body == null) {
      return null;
    } else if (typeof body === "string") {
      return body;
    } else if (import_node_util.types.isUint8Array(body)) {
      return body;
    } else if (import_node_util.types.isArrayBuffer(body)) {
      return new Uint8Array(body);
    } else if (body instanceof import_node_url.URLSearchParams) {
      return body.toString();
    } else if (body instanceof DataView) {
      return new Uint8Array(body.buffer);
    } else if (body instanceof Blob) {
      return new Uint8Array(await body.arrayBuffer());
    } else if (body instanceof FormData) {
      return body;
    } else if (body[Symbol.iterator]) {
      const chunks = [...body];
      return Buffer.concat(chunks);
    } else if (body[Symbol.asyncIterator]) {
      const chunks = [];
      for await (const chunk of body) {
        chunks.push(chunk);
      }
      return Buffer.concat(chunks);
    }
    throw new TypeError(`Unable to resolve body.`);
  }
  var serializeSearchParam = function(value) {
    switch (typeof value) {
      case "string":
        return value;
      case "number":
      case "bigint":
      case "boolean":
        return value.toString();
      case "object":
        if (value === null)
          return null;
        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value.toISOString();
        }
        if (typeof value.toString === "function" && value.toString !== Object.prototype.toString)
          return value.toString();
        return null;
      default:
        return null;
    }
  };
  var makeURLSearchParams = function(options) {
    const params = new URLSearchParams;
    if (!options)
      return params;
    for (const [key, value] of Object.entries(options)) {
      const serialized = serializeSearchParam(value);
      if (serialized !== null)
        params.append(key, serialized);
    }
    return params;
  };
  async function parseResponse(res) {
    if (res.headers.get("Content-Type")?.startsWith("application/json")) {
      return res.json();
    }
    return res.arrayBuffer();
  }
  var hasSublimit = function(bucketRoute, body, method) {
    if (bucketRoute === "/channels/:id") {
      if (typeof body !== "object" || body === null)
        return false;
      if (method !== "PATCH")
        return false;
      const castedBody = body;
      return ["name", "topic"].some((key) => Reflect.has(castedBody, key));
    }
    return true;
  };
  var shouldRetry = function(error) {
    if (error.name === "AbortError")
      return true;
    return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
  };
  async function onRateLimit(manager, rateLimitData) {
    const { options } = manager;
    if (!options.rejectOnRateLimit)
      return;
    const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
    if (shouldThrow) {
      throw new RateLimitError(rateLimitData);
    }
  }
  var calculateUserDefaultAvatarIndex = function(userId) {
    return Number(BigInt(userId) >> 22n) % 6;
  };
  async function sleep(ms) {
    return new Promise((resolve) => {
      setTimeout(() => resolve(), ms);
    });
  }
  var isBufferLike = function(value) {
    return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;
  };
  var deprecationWarning = function(message) {
    if (typeof globalThis.process === "undefined") {
      console.warn(`${DEPRECATION_WARNING_PREFIX}: ${message}`);
    } else {
      process.emitWarning(message, DEPRECATION_WARNING_PREFIX);
    }
  };
  var isErrorGroupWrapper = function(error) {
    return Reflect.has(error, "_errors");
  };
  var isErrorResponse = function(error) {
    return typeof Reflect.get(error, "message") === "string";
  };
  var incrementInvalidCount = function(manager) {
    if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
      invalidCountResetTime = Date.now() + 1000 * 60 * 10;
      invalidCount = 0;
    }
    invalidCount++;
    const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
    if (emitInvalid) {
      manager.emit("invalidRequestWarning", {
        count: invalidCount,
        remainingTime: invalidCountResetTime - Date.now()
      });
    }
  };
  async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
    const controller = new AbortController;
    const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
    if (requestData.signal) {
      if (requestData.signal.aborted)
        controller.abort();
      else
        requestData.signal.addEventListener("abort", () => controller.abort());
    }
    let res;
    try {
      res = await manager.options.makeRequest(url, { ...options, signal: controller.signal });
    } catch (error) {
      if (!(error instanceof Error))
        throw error;
      if (shouldRetry(error) && retries !== manager.options.retries) {
        return null;
      }
      throw error;
    } finally {
      clearTimeout(timeout);
    }
    if (manager.listenerCount("response")) {
      manager.emit("response", {
        method: options.method ?? "get",
        path: routeId.original,
        route: routeId.bucketRoute,
        options,
        data: requestData,
        retries
      }, res instanceof Response ? res.clone() : { ...res });
    }
    return res;
  }
  async function handleErrors(manager, res, method, url, requestData, retries) {
    const status = res.status;
    if (status >= 500 && status < 600) {
      if (retries !== manager.options.retries) {
        return null;
      }
      throw new HTTPError(status, res.statusText, method, url, requestData);
    } else {
      if (status >= 400 && status < 500) {
        if (status === 401 && requestData.auth) {
          manager.setToken(null);
        }
        const data = await parseResponse(res);
        throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
      }
      return res;
    }
  }
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
    ALLOWED_SIZES: () => ALLOWED_SIZES,
    ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
    BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
    CDN: () => CDN,
    DEPRECATION_WARNING_PREFIX: () => DEPRECATION_WARNING_PREFIX,
    DefaultRestOptions: () => DefaultRestOptions,
    DefaultUserAgent: () => DefaultUserAgent,
    DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,
    DiscordAPIError: () => DiscordAPIError,
    HTTPError: () => HTTPError,
    OverwrittenMimeTypes: () => OverwrittenMimeTypes,
    REST: () => REST,
    RESTEvents: () => RESTEvents,
    RateLimitError: () => RateLimitError,
    RequestMethod: () => RequestMethod,
    calculateUserDefaultAvatarIndex: () => calculateUserDefaultAvatarIndex,
    makeURLSearchParams: () => makeURLSearchParams,
    parseResponse: () => parseResponse,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var import_node_buffer = __require("buffer");
  var import_util2 = require_dist();
  var import_undici2 = require_undici();
  var defaultStrategy;
  __name(setDefaultStrategy, "setDefaultStrategy");
  __name(getDefaultStrategy, "getDefaultStrategy");
  var import_node_http = __require("http");
  var import_node_url = __require("url");
  var import_node_util = __require("util");
  var import_undici = require_undici();
  __name(makeRequest, "makeRequest");
  __name(resolveBody, "resolveBody");
  var import_util = require_dist();
  var import_v10 = require_v106();
  var DefaultUserAgent = `DiscordBot (https://discord.js.org, 2.2.0)`;
  var DefaultUserAgentAppendix = (0, import_util.getUserAgentAppendix)();
  var DefaultRestOptions = {
    agent: null,
    api: "https://discord.com/api",
    authPrefix: "Bot",
    cdn: "https://cdn.discordapp.com",
    headers: {},
    invalidRequestWarningInterval: 0,
    globalRequestsPerSecond: 50,
    offset: 50,
    rejectOnRateLimit: null,
    retries: 3,
    timeout: 15000,
    userAgentAppendix: DefaultUserAgentAppendix,
    version: import_v10.APIVersion,
    hashSweepInterval: 14400000,
    hashLifetime: 86400000,
    handlerSweepInterval: 3600000,
    async makeRequest(...args) {
      return getDefaultStrategy()(...args);
    }
  };
  var RESTEvents = ((RESTEvents2) => {
    RESTEvents2["Debug"] = "restDebug";
    RESTEvents2["HandlerSweep"] = "handlerSweep";
    RESTEvents2["HashSweep"] = "hashSweep";
    RESTEvents2["InvalidRequestWarning"] = "invalidRequestWarning";
    RESTEvents2["RateLimited"] = "rateLimited";
    RESTEvents2["Response"] = "response";
    return RESTEvents2;
  })(RESTEvents || {});
  var ALLOWED_EXTENSIONS = ["webp", "png", "jpg", "jpeg", "gif"];
  var ALLOWED_STICKER_EXTENSIONS = ["png", "json", "gif"];
  var ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
  var OverwrittenMimeTypes = {
    "image/apng": "image/png"
  };
  var BurstHandlerMajorIdKey = "burst";
  var DEPRECATION_WARNING_PREFIX = "DeprecationWarning";
  var RateLimitError = class _RateLimitError extends Error {
    static {
      __name(this, "RateLimitError");
    }
    timeToReset;
    limit;
    method;
    hash;
    url;
    route;
    majorParameter;
    global;
    retryAfter;
    sublimitTimeout;
    scope;
    constructor({
      timeToReset,
      limit,
      method,
      hash,
      url,
      route,
      majorParameter,
      global: global2,
      retryAfter,
      sublimitTimeout,
      scope
    }) {
      super();
      this.timeToReset = timeToReset;
      this.limit = limit;
      this.method = method;
      this.hash = hash;
      this.url = url;
      this.route = route;
      this.majorParameter = majorParameter;
      this.global = global2;
      this.retryAfter = retryAfter;
      this.sublimitTimeout = sublimitTimeout;
      this.scope = scope;
    }
    get name() {
      return `${_RateLimitError.name}[${this.route}]`;
    }
  };
  var RequestMethod = ((RequestMethod2) => {
    RequestMethod2["Delete"] = "DELETE";
    RequestMethod2["Get"] = "GET";
    RequestMethod2["Patch"] = "PATCH";
    RequestMethod2["Post"] = "POST";
    RequestMethod2["Put"] = "PUT";
    return RequestMethod2;
  })(RequestMethod || {});
  __name(serializeSearchParam, "serializeSearchParam");
  __name(makeURLSearchParams, "makeURLSearchParams");
  __name(parseResponse, "parseResponse");
  __name(hasSublimit, "hasSublimit");
  __name(shouldRetry, "shouldRetry");
  __name(onRateLimit, "onRateLimit");
  __name(calculateUserDefaultAvatarIndex, "calculateUserDefaultAvatarIndex");
  __name(sleep, "sleep");
  __name(isBufferLike, "isBufferLike");
  __name(deprecationWarning, "deprecationWarning");
  var deprecationEmittedForEmoji = false;
  var CDN = class {
    constructor(base = DefaultRestOptions.cdn) {
      this.base = base;
    }
    static {
      __name(this, "CDN");
    }
    appAsset(clientId, assetHash, options) {
      return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);
    }
    appIcon(clientId, iconHash, options) {
      return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);
    }
    avatar(id, avatarHash, options) {
      return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);
    }
    avatarDecoration(userId, userAvatarDecoration, options) {
      return this.makeURL(`/avatar-decorations/${userId}/${userAvatarDecoration}`, options);
    }
    banner(id, bannerHash, options) {
      return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);
    }
    channelIcon(channelId, iconHash, options) {
      return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);
    }
    defaultAvatar(index) {
      return this.makeURL(`/embed/avatars/${index}`, { extension: "png" });
    }
    discoverySplash(guildId, splashHash, options) {
      return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);
    }
    emoji(emojiId, options) {
      let resolvedOptions;
      if (typeof options === "string") {
        if (!deprecationEmittedForEmoji) {
          deprecationWarning("Passing a string for the second parameter of CDN#emoji() is deprecated. Use an object instead.");
          deprecationEmittedForEmoji = true;
        }
        resolvedOptions = { extension: options };
      } else {
        resolvedOptions = options;
      }
      return this.makeURL(`/emojis/${emojiId}`, resolvedOptions);
    }
    guildMemberAvatar(guildId, userId, avatarHash, options) {
      return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);
    }
    guildMemberBanner(guildId, userId, bannerHash, options) {
      return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);
    }
    icon(id, iconHash, options) {
      return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);
    }
    roleIcon(roleId, roleIconHash, options) {
      return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);
    }
    splash(guildId, splashHash, options) {
      return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);
    }
    sticker(stickerId, extension = "png") {
      return this.makeURL(`/stickers/${stickerId}`, { allowedExtensions: ALLOWED_STICKER_EXTENSIONS, extension });
    }
    stickerPackBanner(bannerId, options) {
      return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);
    }
    teamIcon(teamId, iconHash, options) {
      return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);
    }
    guildScheduledEventCover(scheduledEventId, coverHash, options) {
      return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);
    }
    dynamicMakeURL(route, hash, { forceStatic = false, ...options } = {}) {
      return this.makeURL(route, !forceStatic && hash.startsWith("a_") ? { ...options, extension: "gif" } : options);
    }
    makeURL(route, { allowedExtensions = ALLOWED_EXTENSIONS, extension = "webp", size } = {}) {
      extension = String(extension).toLowerCase();
      if (!allowedExtensions.includes(extension)) {
        throw new RangeError(`Invalid extension provided: ${extension}
Must be one of: ${allowedExtensions.join(", ")}`);
      }
      if (size && !ALLOWED_SIZES.includes(size)) {
        throw new RangeError(`Invalid size provided: ${size}
Must be one of: ${ALLOWED_SIZES.join(", ")}`);
      }
      const url = new URL(`${this.base}${route}.${extension}`);
      if (size) {
        url.searchParams.set("size", String(size));
      }
      return url.toString();
    }
  };
  __name(isErrorGroupWrapper, "isErrorGroupWrapper");
  __name(isErrorResponse, "isErrorResponse");
  var DiscordAPIError = class _DiscordAPIError extends Error {
    constructor(rawError, code, status, method, url, bodyData) {
      super(_DiscordAPIError.getMessage(rawError));
      this.rawError = rawError;
      this.code = code;
      this.status = status;
      this.method = method;
      this.url = url;
      this.requestBody = { files: bodyData.files, json: bodyData.body };
    }
    static {
      __name(this, "DiscordAPIError");
    }
    requestBody;
    get name() {
      return `${_DiscordAPIError.name}[${this.code}]`;
    }
    static getMessage(error) {
      let flattened = "";
      if ("code" in error) {
        if (error.errors) {
          flattened = [...this.flattenDiscordError(error.errors)].join("\n");
        }
        return error.message && flattened ? `${error.message}
${flattened}` : error.message || flattened || "Unknown Error";
      }
      return error.error_description ?? "No Description";
    }
    static *flattenDiscordError(obj, key = "") {
      if (isErrorResponse(obj)) {
        return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();
      }
      for (const [otherKey, val] of Object.entries(obj)) {
        const nextKey = otherKey.startsWith("_") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;
        if (typeof val === "string") {
          yield val;
        } else if (isErrorGroupWrapper(val)) {
          for (const error of val._errors) {
            yield* this.flattenDiscordError(error, nextKey);
          }
        } else {
          yield* this.flattenDiscordError(val, nextKey);
        }
      }
    }
  };
  var HTTPError = class _HTTPError extends Error {
    constructor(status, statusText, method, url, bodyData) {
      super(statusText);
      this.status = status;
      this.method = method;
      this.url = url;
      this.requestBody = { files: bodyData.files, json: bodyData.body };
    }
    static {
      __name(this, "HTTPError");
    }
    requestBody;
    name = _HTTPError.name;
  };
  var import_collection = require_dist2();
  var import_snowflake = require_dist3();
  var import_async_event_emitter = require_dist4();
  var import_magic_bytes = require_dist5();
  var invalidCount = 0;
  var invalidCountResetTime = null;
  __name(incrementInvalidCount, "incrementInvalidCount");
  __name(makeNetworkRequest, "makeNetworkRequest");
  __name(handleErrors, "handleErrors");
  var BurstHandler = class {
    constructor(manager, hash, majorParameter) {
      this.manager = manager;
      this.hash = hash;
      this.majorParameter = majorParameter;
      this.id = `${hash}:${majorParameter}`;
    }
    static {
      __name(this, "BurstHandler");
    }
    id;
    inactive = false;
    debug(message) {
      this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
    }
    async queueRequest(routeId, url, options, requestData) {
      return this.runRequest(routeId, url, options, requestData);
    }
    async runRequest(routeId, url, options, requestData, retries = 0) {
      const method = options.method ?? "get";
      const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
      if (res === null) {
        return this.runRequest(routeId, url, options, requestData, ++retries);
      }
      const status = res.status;
      let retryAfter = 0;
      const retry = res.headers.get("Retry-After");
      if (retry)
        retryAfter = Number(retry) * 1000 + this.manager.options.offset;
      if (status === 401 || status === 403 || status === 429) {
        incrementInvalidCount(this.manager);
      }
      if (status >= 200 && status < 300) {
        return res;
      } else if (status === 429) {
        const isGlobal = res.headers.has("X-RateLimit-Global");
        const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
        await onRateLimit(this.manager, {
          global: isGlobal,
          method,
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: Number.POSITIVE_INFINITY,
          timeToReset: retryAfter,
          retryAfter,
          sublimitTimeout: 0,
          scope
        });
        this.debug([
          "Encountered unexpected 429 rate limit",
          `  Global         : ${isGlobal}`,
          `  Method         : ${method}`,
          `  URL            : ${url}`,
          `  Bucket         : ${routeId.bucketRoute}`,
          `  Major parameter: ${routeId.majorParameter}`,
          `  Hash           : ${this.hash}`,
          `  Limit          : ${Number.POSITIVE_INFINITY}`,
          `  Retry After    : ${retryAfter}ms`,
          `  Sublimit       : None`,
          `  Scope          : ${scope}`
        ].join("\n"));
        await sleep(retryAfter);
        return this.runRequest(routeId, url, options, requestData, retries);
      } else {
        const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
        if (handled === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        return handled;
      }
    }
  };
  var import_async_queue = require_cjs();
  var SequentialHandler = class {
    constructor(manager, hash, majorParameter) {
      this.manager = manager;
      this.hash = hash;
      this.majorParameter = majorParameter;
      this.id = `${hash}:${majorParameter}`;
    }
    static {
      __name(this, "SequentialHandler");
    }
    id;
    reset = -1;
    remaining = 1;
    limit = Number.POSITIVE_INFINITY;
    #asyncQueue = new import_async_queue.AsyncQueue;
    #sublimitedQueue = null;
    #sublimitPromise = null;
    #shiftSublimit = false;
    get inactive() {
      return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;
    }
    get globalLimited() {
      return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
    }
    get localLimited() {
      return this.remaining <= 0 && Date.now() < this.reset;
    }
    get limited() {
      return this.globalLimited || this.localLimited;
    }
    get timeToReset() {
      return this.reset + this.manager.options.offset - Date.now();
    }
    debug(message) {
      this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
    }
    async globalDelayFor(time) {
      await sleep(time);
      this.manager.globalDelay = null;
    }
    async queueRequest(routeId, url, options, requestData) {
      let queue = this.#asyncQueue;
      let queueType = 0;
      if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
        queue = this.#sublimitedQueue;
        queueType = 1;
      }
      await queue.wait({ signal: requestData.signal });
      if (queueType === 0) {
        if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
          queue = this.#sublimitedQueue;
          const wait = queue.wait();
          this.#asyncQueue.shift();
          await wait;
        } else if (this.#sublimitPromise) {
          await this.#sublimitPromise.promise;
        }
      }
      try {
        return await this.runRequest(routeId, url, options, requestData);
      } finally {
        queue.shift();
        if (this.#shiftSublimit) {
          this.#shiftSublimit = false;
          this.#sublimitedQueue?.shift();
        }
        if (this.#sublimitedQueue?.remaining === 0) {
          this.#sublimitPromise?.resolve();
          this.#sublimitedQueue = null;
        }
      }
    }
    async runRequest(routeId, url, options, requestData, retries = 0) {
      while (this.limited) {
        const isGlobal = this.globalLimited;
        let limit2;
        let timeout;
        let delay;
        if (isGlobal) {
          limit2 = this.manager.options.globalRequestsPerSecond;
          timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
          if (!this.manager.globalDelay) {
            this.manager.globalDelay = this.globalDelayFor(timeout);
          }
          delay = this.manager.globalDelay;
        } else {
          limit2 = this.limit;
          timeout = this.timeToReset;
          delay = sleep(timeout);
        }
        const rateLimitData = {
          global: isGlobal,
          method: options.method ?? "get",
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: limit2,
          timeToReset: timeout,
          retryAfter: timeout,
          sublimitTimeout: 0,
          scope: "user"
        };
        this.manager.emit("rateLimited", rateLimitData);
        await onRateLimit(this.manager, rateLimitData);
        if (isGlobal) {
          this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
        } else {
          this.debug(`Waiting ${timeout}ms for rate limit to pass`);
        }
        await delay;
      }
      if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
        this.manager.globalReset = Date.now() + 1000;
        this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
      }
      this.manager.globalRemaining--;
      const method = options.method ?? "get";
      const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
      if (res === null) {
        return this.runRequest(routeId, url, options, requestData, ++retries);
      }
      const status = res.status;
      let retryAfter = 0;
      const limit = res.headers.get("X-RateLimit-Limit");
      const remaining = res.headers.get("X-RateLimit-Remaining");
      const reset = res.headers.get("X-RateLimit-Reset-After");
      const hash = res.headers.get("X-RateLimit-Bucket");
      const retry = res.headers.get("Retry-After");
      const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
      this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;
      this.remaining = remaining ? Number(remaining) : 1;
      this.reset = reset ? Number(reset) * 1000 + Date.now() + this.manager.options.offset : Date.now();
      if (retry)
        retryAfter = Number(retry) * 1000 + this.manager.options.offset;
      if (hash && hash !== this.hash) {
        this.debug(["Received bucket hash update", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join("\n"));
        this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });
      } else if (hash) {
        const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);
        if (hashData) {
          hashData.lastAccess = Date.now();
        }
      }
      let sublimitTimeout = null;
      if (retryAfter > 0) {
        if (res.headers.has("X-RateLimit-Global")) {
          this.manager.globalRemaining = 0;
          this.manager.globalReset = Date.now() + retryAfter;
        } else if (!this.localLimited) {
          sublimitTimeout = retryAfter;
        }
      }
      if (status === 401 || status === 403 || status === 429) {
        incrementInvalidCount(this.manager);
      }
      if (res.ok) {
        return res;
      } else if (status === 429) {
        const isGlobal = this.globalLimited;
        let limit2;
        let timeout;
        if (isGlobal) {
          limit2 = this.manager.options.globalRequestsPerSecond;
          timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
        } else {
          limit2 = this.limit;
          timeout = this.timeToReset;
        }
        await onRateLimit(this.manager, {
          global: isGlobal,
          method,
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          hash: this.hash,
          limit: limit2,
          timeToReset: timeout,
          retryAfter,
          sublimitTimeout: sublimitTimeout ?? 0,
          scope
        });
        this.debug([
          "Encountered unexpected 429 rate limit",
          `  Global         : ${isGlobal.toString()}`,
          `  Method         : ${method}`,
          `  URL            : ${url}`,
          `  Bucket         : ${routeId.bucketRoute}`,
          `  Major parameter: ${routeId.majorParameter}`,
          `  Hash           : ${this.hash}`,
          `  Limit          : ${limit2}`,
          `  Retry After    : ${retryAfter}ms`,
          `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`,
          `  Scope          : ${scope}`
        ].join("\n"));
        if (sublimitTimeout) {
          const firstSublimit = !this.#sublimitedQueue;
          if (firstSublimit) {
            this.#sublimitedQueue = new import_async_queue.AsyncQueue;
            this.#sublimitedQueue.wait();
            this.#asyncQueue.shift();
          }
          this.#sublimitPromise?.resolve();
          this.#sublimitPromise = null;
          await sleep(sublimitTimeout);
          let resolve;
          const promise = new Promise((res2) => resolve = res2);
          this.#sublimitPromise = { promise, resolve };
          if (firstSublimit) {
            await this.#asyncQueue.wait();
            this.#shiftSublimit = true;
          }
        }
        return this.runRequest(routeId, url, options, requestData, retries);
      } else {
        const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
        if (handled === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        return handled;
      }
    }
  };
  var REST = class _REST extends import_async_event_emitter.AsyncEventEmitter {
    static {
      __name(this, "REST");
    }
    agent = null;
    cdn;
    globalRemaining;
    globalDelay = null;
    globalReset = -1;
    hashes = new import_collection.Collection;
    handlers = new import_collection.Collection;
    #token = null;
    hashTimer;
    handlerTimer;
    options;
    constructor(options = {}) {
      super();
      this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);
      this.options = { ...DefaultRestOptions, ...options };
      this.options.offset = Math.max(0, this.options.offset);
      this.globalRemaining = Math.max(1, this.options.globalRequestsPerSecond);
      this.agent = options.agent ?? null;
      this.setupSweepers();
    }
    setupSweepers() {
      const validateMaxInterval = __name((interval) => {
        if (interval > 14400000) {
          throw new Error("Cannot set an interval greater than 4 hours");
        }
      }, "validateMaxInterval");
      if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
        validateMaxInterval(this.options.hashSweepInterval);
        this.hashTimer = setInterval(() => {
          const sweptHashes = new import_collection.Collection;
          const currentDate = Date.now();
          this.hashes.sweep((val, key) => {
            if (val.lastAccess === -1)
              return false;
            const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;
            if (shouldSweep) {
              sweptHashes.set(key, val);
              this.emit("restDebug", `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);
            }
            return shouldSweep;
          });
          this.emit("hashSweep", sweptHashes);
        }, this.options.hashSweepInterval);
        this.hashTimer.unref?.();
      }
      if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
        validateMaxInterval(this.options.handlerSweepInterval);
        this.handlerTimer = setInterval(() => {
          const sweptHandlers = new import_collection.Collection;
          this.handlers.sweep((val, key) => {
            const { inactive } = val;
            if (inactive) {
              sweptHandlers.set(key, val);
              this.emit("restDebug", `Handler ${val.id} for ${key} swept due to being inactive`);
            }
            return inactive;
          });
          this.emit("handlerSweep", sweptHandlers);
        }, this.options.handlerSweepInterval);
        this.handlerTimer.unref?.();
      }
    }
    async get(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "GET" });
    }
    async delete(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "DELETE" });
    }
    async post(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "POST" });
    }
    async put(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "PUT" });
    }
    async patch(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "PATCH" });
    }
    async request(options) {
      const response = await this.queueRequest(options);
      return parseResponse(response);
    }
    setAgent(agent) {
      this.agent = agent;
      return this;
    }
    setToken(token) {
      this.#token = token;
      return this;
    }
    async queueRequest(request2) {
      const routeId = _REST.generateRouteData(request2.fullRoute, request2.method);
      const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
        value: `Global(${request2.method}:${routeId.bucketRoute})`,
        lastAccess: -1
      };
      const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
      const { url, fetchOptions } = await this.resolveRequest(request2);
      return handler.queueRequest(routeId, url, fetchOptions, {
        body: request2.body,
        files: request2.files,
        auth: request2.auth !== false,
        signal: request2.signal
      });
    }
    createHandler(hash, majorParameter) {
      const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
      this.handlers.set(queue.id, queue);
      return queue;
    }
    async resolveRequest(request2) {
      const { options } = this;
      let query = "";
      if (request2.query) {
        const resolvedQuery = request2.query.toString();
        if (resolvedQuery !== "") {
          query = `?${resolvedQuery}`;
        }
      }
      const headers = {
        ...this.options.headers,
        "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
      };
      if (request2.auth !== false) {
        if (!this.#token) {
          throw new Error("Expected token to be set for this request, but none was present");
        }
        headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${this.#token}`;
      }
      if (request2.reason?.length) {
        headers["X-Audit-Log-Reason"] = encodeURIComponent(request2.reason);
      }
      const url = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
      let finalBody;
      let additionalHeaders = {};
      if (request2.files?.length) {
        const formData = new FormData;
        for (const [index, file] of request2.files.entries()) {
          const fileKey = file.key ?? `files[${index}]`;
          if (isBufferLike(file.data)) {
            let contentType = file.contentType;
            if (!contentType) {
              const [parsedType] = (0, import_magic_bytes.filetypeinfo)(file.data);
              if (parsedType) {
                contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? "application/octet-stream";
              }
            }
            formData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);
          } else {
            formData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);
          }
        }
        if (request2.body != null) {
          if (request2.appendToFormData) {
            for (const [key, value] of Object.entries(request2.body)) {
              formData.append(key, value);
            }
          } else {
            formData.append("payload_json", JSON.stringify(request2.body));
          }
        }
        finalBody = formData;
      } else if (request2.body != null) {
        if (request2.passThroughBody) {
          finalBody = request2.body;
        } else {
          finalBody = JSON.stringify(request2.body);
          additionalHeaders = { "Content-Type": "application/json" };
        }
      }
      const method = request2.method.toUpperCase();
      const fetchOptions = {
        body: ["GET", "HEAD"].includes(method) ? null : finalBody,
        headers: { ...request2.headers, ...additionalHeaders, ...headers },
        method,
        dispatcher: request2.dispatcher ?? this.agent ?? undefined
      };
      return { url, fetchOptions };
    }
    clearHashSweeper() {
      clearInterval(this.hashTimer);
    }
    clearHandlerSweeper() {
      clearInterval(this.handlerTimer);
    }
    static generateRouteData(endpoint, method) {
      if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
        return {
          majorParameter: BurstHandlerMajorIdKey,
          bucketRoute: "/interactions/:id/:token/callback",
          original: endpoint
        };
      }
      const majorIdMatch = /(?:^\/webhooks\/(\d{17,19}\/[^/?]+))|(?:^\/(?:channels|guilds|webhooks)\/(\d{17,19}))/.exec(endpoint);
      const majorId = majorIdMatch?.[2] ?? majorIdMatch?.[1] ?? "global";
      const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction").replace(/\/webhooks\/:id\/[^/?]+/, "/webhooks/:id/:token");
      let exceptions = "";
      if (method === "DELETE" && baseRoute === "/channels/:id/messages/:id") {
        const id = /\d{17,19}$/.exec(endpoint)[0];
        const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
        if (Date.now() - timestamp > 1000 * 60 * 60 * 24 * 14) {
          exceptions += "/Delete Old Message";
        }
      }
      return {
        majorParameter: majorId,
        bucketRoute: baseRoute + exceptions,
        original: endpoint
      };
    }
  };
  var version = "2.2.0";
  globalThis.FormData ??= import_undici2.FormData;
  globalThis.Blob ??= import_node_buffer.Blob;
  setDefaultStrategy((0, import_util2.shouldUseGlobalFetchAndWebSocket)() ? fetch : makeRequest);
});

// node_modules/discord.js/src/errors/ErrorCodes.js
var require_ErrorCodes = __commonJS((exports, module) => {
  var keys = [
    "ClientInvalidOption",
    "ClientInvalidProvidedShards",
    "ClientMissingIntents",
    "ClientNotReady",
    "TokenInvalid",
    "TokenMissing",
    "ApplicationCommandPermissionsTokenMissing",
    "WSCloseRequested",
    "WSConnectionExists",
    "WSNotOpen",
    "ManagerDestroyed",
    "BitFieldInvalid",
    "ShardingInvalid",
    "ShardingRequired",
    "InvalidIntents",
    "DisallowedIntents",
    "ShardingNoShards",
    "ShardingInProcess",
    "ShardingInvalidEvalBroadcast",
    "ShardingShardNotFound",
    "ShardingAlreadySpawned",
    "ShardingProcessExists",
    "ShardingWorkerExists",
    "ShardingReadyTimeout",
    "ShardingReadyDisconnected",
    "ShardingReadyDied",
    "ShardingNoChildExists",
    "ShardingShardMiscalculation",
    "ColorRange",
    "ColorConvert",
    "InviteOptionsMissingChannel",
    "ButtonLabel",
    "ButtonURL",
    "ButtonCustomId",
    "SelectMenuCustomId",
    "SelectMenuPlaceholder",
    "SelectOptionLabel",
    "SelectOptionValue",
    "SelectOptionDescription",
    "InteractionCollectorError",
    "FileNotFound",
    "UserBannerNotFetched",
    "UserNoDMChannel",
    "VoiceNotStageChannel",
    "VoiceStateNotOwn",
    "VoiceStateInvalidType",
    "ReqResourceType",
    "ImageFormat",
    "ImageSize",
    "MessageBulkDeleteType",
    "MessageNonceType",
    "MessageContentType",
    "SplitMaxLen",
    "BanResolveId",
    "FetchBanResolveId",
    "PruneDaysType",
    "GuildChannelResolve",
    "GuildVoiceChannelResolve",
    "GuildChannelOrphan",
    "GuildChannelUnowned",
    "GuildOwned",
    "GuildMembersTimeout",
    "GuildUncachedMe",
    "ChannelNotCached",
    "StageChannelResolve",
    "GuildScheduledEventResolve",
    "FetchOwnerId",
    "InvalidType",
    "InvalidElement",
    "MessageThreadParent",
    "MessageExistingThread",
    "ThreadInvitableType",
    "WebhookMessage",
    "WebhookTokenUnavailable",
    "WebhookURLInvalid",
    "WebhookApplication",
    "MessageReferenceMissing",
    "EmojiType",
    "EmojiManaged",
    "MissingManageGuildExpressionsPermission",
    "MissingManageEmojisAndStickersPermission",
    "NotGuildSticker",
    "ReactionResolveUser",
    "VanityURL",
    "InviteResolveCode",
    "InviteNotFound",
    "DeleteGroupDMChannel",
    "FetchGroupDMChannel",
    "MemberFetchNonceLength",
    "GlobalCommandPermissions",
    "GuildUncachedEntityResolve",
    "InteractionAlreadyReplied",
    "InteractionNotReplied",
    "InteractionEphemeralReplied",
    "CommandInteractionOptionNotFound",
    "CommandInteractionOptionType",
    "CommandInteractionOptionEmpty",
    "CommandInteractionOptionNoSubcommand",
    "CommandInteractionOptionNoSubcommandGroup",
    "CommandInteractionOptionInvalidChannelType",
    "AutocompleteInteractionOptionNoFocusedOption",
    "ModalSubmitInteractionFieldNotFound",
    "ModalSubmitInteractionFieldType",
    "InvalidMissingScopes",
    "InvalidScopesWithPermissions",
    "NotImplemented",
    "SweepFilterReturn",
    "GuildForumMessageRequired"
  ];
  module.exports = Object.fromEntries(keys.map((key) => [key, key]));
});

// node_modules/discord.js/src/errors/Messages.js
var require_Messages = __commonJS((exports, module) => {
  var DjsErrorCodes = require_ErrorCodes();
  var Messages = {
    [DjsErrorCodes.ClientInvalidOption]: (prop, must) => `The ${prop} option must be ${must}`,
    [DjsErrorCodes.ClientInvalidProvidedShards]: "None of the provided shards were valid.",
    [DjsErrorCodes.ClientMissingIntents]: "Valid intents must be provided for the Client.",
    [DjsErrorCodes.ClientNotReady]: (action) => `The client needs to be logged in to ${action}.`,
    [DjsErrorCodes.TokenInvalid]: "An invalid token was provided.",
    [DjsErrorCodes.TokenMissing]: "Request to use token, but token was unavailable to the client.",
    [DjsErrorCodes.ApplicationCommandPermissionsTokenMissing]: "Editing application command permissions requires an OAuth2 bearer token, but none was provided.",
    [DjsErrorCodes.WSCloseRequested]: "WebSocket closed due to user request.",
    [DjsErrorCodes.WSConnectionExists]: "There is already an existing WebSocket connection.",
    [DjsErrorCodes.WSNotOpen]: (data = "data") => `WebSocket not open to send ${data}`,
    [DjsErrorCodes.ManagerDestroyed]: "Manager was destroyed.",
    [DjsErrorCodes.BitFieldInvalid]: (bit) => `Invalid bitfield flag or number: ${bit}.`,
    [DjsErrorCodes.ShardingInvalid]: "Invalid shard settings were provided.",
    [DjsErrorCodes.ShardingRequired]: "This session would have handled too many guilds - Sharding is required.",
    [DjsErrorCodes.InvalidIntents]: "Invalid intent provided for WebSocket intents.",
    [DjsErrorCodes.DisallowedIntents]: "Privileged intent provided is not enabled or whitelisted.",
    [DjsErrorCodes.ShardingNoShards]: "No shards have been spawned.",
    [DjsErrorCodes.ShardingInProcess]: "Shards are still being spawned.",
    [DjsErrorCodes.ShardingInvalidEvalBroadcast]: "Script to evaluate must be a function",
    [DjsErrorCodes.ShardingShardNotFound]: (id) => `Shard ${id} could not be found.`,
    [DjsErrorCodes.ShardingAlreadySpawned]: (count) => `Already spawned ${count} shards.`,
    [DjsErrorCodes.ShardingProcessExists]: (id) => `Shard ${id} already has an active process.`,
    [DjsErrorCodes.ShardingWorkerExists]: (id) => `Shard ${id} already has an active worker.`,
    [DjsErrorCodes.ShardingReadyTimeout]: (id) => `Shard ${id}'s Client took too long to become ready.`,
    [DjsErrorCodes.ShardingReadyDisconnected]: (id) => `Shard ${id}'s Client disconnected before becoming ready.`,
    [DjsErrorCodes.ShardingReadyDied]: (id) => `Shard ${id}'s process exited before its Client became ready.`,
    [DjsErrorCodes.ShardingNoChildExists]: (id) => `Shard ${id} has no active process or worker.`,
    [DjsErrorCodes.ShardingShardMiscalculation]: (shard, guild, count) => `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,
    [DjsErrorCodes.ColorRange]: "Color must be within the range 0 - 16777215 (0xFFFFFF).",
    [DjsErrorCodes.ColorConvert]: "Unable to convert color to a number.",
    [DjsErrorCodes.InviteOptionsMissingChannel]: "A valid guild channel must be provided when GuildScheduledEvent is EXTERNAL.",
    [DjsErrorCodes.ButtonLabel]: "MessageButton label must be a string",
    [DjsErrorCodes.ButtonURL]: "MessageButton URL must be a string",
    [DjsErrorCodes.ButtonCustomId]: "MessageButton customId must be a string",
    [DjsErrorCodes.SelectMenuCustomId]: "MessageSelectMenu customId must be a string",
    [DjsErrorCodes.SelectMenuPlaceholder]: "MessageSelectMenu placeholder must be a string",
    [DjsErrorCodes.SelectOptionLabel]: "MessageSelectOption label must be a string",
    [DjsErrorCodes.SelectOptionValue]: "MessageSelectOption value must be a string",
    [DjsErrorCodes.SelectOptionDescription]: "MessageSelectOption description must be a string",
    [DjsErrorCodes.InteractionCollectorError]: (reason) => `Collector received no interactions before ending with reason: ${reason}`,
    [DjsErrorCodes.FileNotFound]: (file) => `File could not be found: ${file}`,
    [DjsErrorCodes.UserBannerNotFetched]: "You must fetch this user's banner before trying to generate its URL!",
    [DjsErrorCodes.UserNoDMChannel]: "No DM Channel exists!",
    [DjsErrorCodes.VoiceNotStageChannel]: "You are only allowed to do this in stage channels.",
    [DjsErrorCodes.VoiceStateNotOwn]: "You cannot self-deafen/mute/request to speak on VoiceStates that do not belong to the ClientUser.",
    [DjsErrorCodes.VoiceStateInvalidType]: (name) => `${name} must be a boolean.`,
    [DjsErrorCodes.ReqResourceType]: "The resource must be a string, Buffer or a valid file stream.",
    [DjsErrorCodes.ImageFormat]: (format) => `Invalid image format: ${format}`,
    [DjsErrorCodes.ImageSize]: (size) => `Invalid image size: ${size}`,
    [DjsErrorCodes.MessageBulkDeleteType]: "The messages must be an Array, Collection, or number.",
    [DjsErrorCodes.MessageNonceType]: "Message nonce must be an integer or a string.",
    [DjsErrorCodes.MessageContentType]: "Message content must be a string.",
    [DjsErrorCodes.SplitMaxLen]: "Chunk exceeds the max length and contains no split characters.",
    [DjsErrorCodes.BanResolveId]: (ban = false) => `Couldn't resolve the user id to ${ban ? "ban" : "unban"}.`,
    [DjsErrorCodes.FetchBanResolveId]: "Couldn't resolve the user id to fetch the ban.",
    [DjsErrorCodes.PruneDaysType]: "Days must be a number",
    [DjsErrorCodes.GuildChannelResolve]: "Could not resolve channel to a guild channel.",
    [DjsErrorCodes.GuildVoiceChannelResolve]: "Could not resolve channel to a guild voice channel.",
    [DjsErrorCodes.GuildChannelOrphan]: "Could not find a parent to this guild channel.",
    [DjsErrorCodes.GuildChannelUnowned]: "The fetched channel does not belong to this manager's guild.",
    [DjsErrorCodes.GuildOwned]: "Guild is owned by the client.",
    [DjsErrorCodes.GuildMembersTimeout]: "Members didn't arrive in time.",
    [DjsErrorCodes.GuildUncachedMe]: "The client user as a member of this guild is uncached.",
    [DjsErrorCodes.ChannelNotCached]: "Could not find the channel where this message came from in the cache!",
    [DjsErrorCodes.StageChannelResolve]: "Could not resolve channel to a stage channel.",
    [DjsErrorCodes.GuildScheduledEventResolve]: "Could not resolve the guild scheduled event.",
    [DjsErrorCodes.FetchOwnerId]: "Couldn't resolve the guild ownerId to fetch the member.",
    [DjsErrorCodes.InvalidType]: (name, expected, an = false) => `Supplied ${name} is not a${an ? "n" : ""} ${expected}.`,
    [DjsErrorCodes.InvalidElement]: (type, name, elem) => `Supplied ${type} ${name} includes an invalid element: ${elem}`,
    [DjsErrorCodes.MessageThreadParent]: "The message was not sent in a guild text or news channel",
    [DjsErrorCodes.MessageExistingThread]: "The message already has a thread",
    [DjsErrorCodes.ThreadInvitableType]: (type) => `Invitable cannot be edited on ${type}`,
    [DjsErrorCodes.WebhookMessage]: "The message was not sent by a webhook.",
    [DjsErrorCodes.WebhookTokenUnavailable]: "This action requires a webhook token, but none is available.",
    [DjsErrorCodes.WebhookURLInvalid]: "The provided webhook URL is not valid.",
    [DjsErrorCodes.WebhookApplication]: "This message webhook belongs to an application and cannot be fetched.",
    [DjsErrorCodes.MessageReferenceMissing]: "The message does not reference another message",
    [DjsErrorCodes.EmojiType]: "Emoji must be a string or GuildEmoji/ReactionEmoji",
    [DjsErrorCodes.EmojiManaged]: "Emoji is managed and has no Author.",
    [DjsErrorCodes.MissingManageGuildExpressionsPermission]: (guild) => `Client must have Manage Guild Expressions permission in guild ${guild} to see emoji authors.`,
    [DjsErrorCodes.MissingManageEmojisAndStickersPermission]: (guild) => `Client must have Manage Emojis and Stickers permission in guild ${guild} to see emoji authors.`,
    [DjsErrorCodes.NotGuildSticker]: "Sticker is a standard (non-guild) sticker and has no author.",
    [DjsErrorCodes.ReactionResolveUser]: "Couldn't resolve the user id to remove from the reaction.",
    [DjsErrorCodes.VanityURL]: "This guild does not have the vanity URL feature enabled.",
    [DjsErrorCodes.InviteResolveCode]: "Could not resolve the code to fetch the invite.",
    [DjsErrorCodes.InviteNotFound]: "Could not find the requested invite.",
    [DjsErrorCodes.DeleteGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot delete them",
    [DjsErrorCodes.FetchGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot fetch them",
    [DjsErrorCodes.MemberFetchNonceLength]: "Nonce length must not exceed 32 characters.",
    [DjsErrorCodes.GlobalCommandPermissions]: "Permissions for global commands may only be fetched or modified by providing a GuildResolvable or from a guild's application command manager.",
    [DjsErrorCodes.GuildUncachedEntityResolve]: (type) => `Cannot resolve ${type} from an arbitrary guild, provide an id instead`,
    [DjsErrorCodes.InteractionAlreadyReplied]: "The reply to this interaction has already been sent or deferred.",
    [DjsErrorCodes.InteractionNotReplied]: "The reply to this interaction has not been sent or deferred.",
    [DjsErrorCodes.InteractionEphemeralReplied]: "Ephemeral responses cannot be deleted.",
    [DjsErrorCodes.CommandInteractionOptionNotFound]: (name) => `Required option "${name}" not found.`,
    [DjsErrorCodes.CommandInteractionOptionType]: (name, type, expected) => `Option "${name}" is of type: ${type}; expected ${expected}.`,
    [DjsErrorCodes.CommandInteractionOptionEmpty]: (name, type) => `Required option "${name}" is of type: ${type}; expected a non-empty value.`,
    [DjsErrorCodes.CommandInteractionOptionNoSubcommand]: "No subcommand specified for interaction.",
    [DjsErrorCodes.CommandInteractionOptionNoSubcommandGroup]: "No subcommand group specified for interaction.",
    [DjsErrorCodes.CommandInteractionOptionInvalidChannelType]: (name, type, expected) => `The type of channel of the option "${name}" is: ${type}; expected ${expected}.`,
    [DjsErrorCodes.AutocompleteInteractionOptionNoFocusedOption]: "No focused option for autocomplete interaction.",
    [DjsErrorCodes.ModalSubmitInteractionFieldNotFound]: (customId) => `Required field with custom id "${customId}" not found.`,
    [DjsErrorCodes.ModalSubmitInteractionFieldType]: (customId, type, expected) => `Field with custom id "${customId}" is of type: ${type}; expected ${expected}.`,
    [DjsErrorCodes.InvalidMissingScopes]: "At least one valid scope must be provided for the invite",
    [DjsErrorCodes.InvalidScopesWithPermissions]: "Permissions cannot be set without the bot scope.",
    [DjsErrorCodes.NotImplemented]: (what, name) => `Method ${what} not implemented on ${name}.`,
    [DjsErrorCodes.SweepFilterReturn]: "The return value of the sweepFilter function was not false or a Function",
    [DjsErrorCodes.GuildForumMessageRequired]: "You must provide a message to create a guild forum thread"
  };
  module.exports = Messages;
});

// node_modules/discord.js/src/errors/DJSError.js
var require_DJSError = __commonJS((exports, module) => {
  var makeDiscordjsError = function(Base) {
    return class DiscordjsError extends Base {
      constructor(code, ...args) {
        super(message(code, args));
        this.code = code;
        Error.captureStackTrace?.(this, DiscordjsError);
      }
      get name() {
        return `${super.name} [${this.code}]`;
      }
    };
  };
  var message = function(code, args) {
    if (!(code in ErrorCodes))
      throw new Error("Error code must be a valid DiscordjsErrorCodes");
    const msg = Messages[code];
    if (!msg)
      throw new Error(`No message associated with error code: ${code}.`);
    if (typeof msg === "function")
      return msg(...args);
    if (!args?.length)
      return msg;
    args.unshift(msg);
    return String(...args);
  };
  var ErrorCodes = require_ErrorCodes();
  var Messages = require_Messages();
  module.exports = {
    DiscordjsError: makeDiscordjsError(Error),
    DiscordjsTypeError: makeDiscordjsError(TypeError),
    DiscordjsRangeError: makeDiscordjsError(RangeError)
  };
});

// node_modules/discord.js/src/errors/index.js
var require_errors2 = __commonJS((exports, module) => {
  module.exports = require_DJSError();
  module.exports.ErrorCodes = require_ErrorCodes();
  module.exports.Messages = require_Messages();
});

// node_modules/lodash.snakecase/index.js
var require_lodash = __commonJS((exports, module) => {
  var arrayReduce = function(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  };
  var asciiWords = function(string) {
    return string.match(reAsciiWord) || [];
  };
  var basePropertyOf = function(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  };
  var hasUnicodeWord = function(string) {
    return reHasUnicodeWord.test(string);
  };
  var unicodeWords = function(string) {
    return string.match(reUnicodeWord) || [];
  };
  var baseToString = function(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  };
  var createCompounder = function(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  };
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var isSymbol = function(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  };
  var toString = function(value) {
    return value == null ? "" : baseToString(value);
  };
  var deburr = function(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  };
  var words = function(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;
    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  };
  var INFINITY = 1 / 0;
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff";
  var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
  var rsComboSymbolsRange = "\\u20d0-\\u20f0";
  var rsDingbatRange = "\\u2700-\\u27bf";
  var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
  var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
  var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
  var rsPunctuationRange = "\\u2000-\\u206f";
  var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
  var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
  var rsVarRange = "\\ufe0e\\ufe0f";
  var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "['\u2019]";
  var rsBreak = "[" + rsBreakRange + "]";
  var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
  var rsDigits = "\\d+";
  var rsDingbat = "[" + rsDingbatRange + "]";
  var rsLower = "[" + rsLowerRange + "]";
  var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
  var rsFitz = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
  var rsNonAstral = "[^" + rsAstralRange + "]";
  var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsUpper = "[" + rsUpperRange + "]";
  var rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
  var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
  var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
  var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
  var reOptMod = rsModifier + "?";
  var rsOptVar = "[" + rsVarRange + "]?";
  var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
  var rsSeq = rsOptVar + reOptMod + rsOptJoin;
  var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    "\xC0": "A",
    "\xC1": "A",
    "\xC2": "A",
    "\xC3": "A",
    "\xC4": "A",
    "\xC5": "A",
    "\xE0": "a",
    "\xE1": "a",
    "\xE2": "a",
    "\xE3": "a",
    "\xE4": "a",
    "\xE5": "a",
    "\xC7": "C",
    "\xE7": "c",
    "\xD0": "D",
    "\xF0": "d",
    "\xC8": "E",
    "\xC9": "E",
    "\xCA": "E",
    "\xCB": "E",
    "\xE8": "e",
    "\xE9": "e",
    "\xEA": "e",
    "\xEB": "e",
    "\xCC": "I",
    "\xCD": "I",
    "\xCE": "I",
    "\xCF": "I",
    "\xEC": "i",
    "\xED": "i",
    "\xEE": "i",
    "\xEF": "i",
    "\xD1": "N",
    "\xF1": "n",
    "\xD2": "O",
    "\xD3": "O",
    "\xD4": "O",
    "\xD5": "O",
    "\xD6": "O",
    "\xD8": "O",
    "\xF2": "o",
    "\xF3": "o",
    "\xF4": "o",
    "\xF5": "o",
    "\xF6": "o",
    "\xF8": "o",
    "\xD9": "U",
    "\xDA": "U",
    "\xDB": "U",
    "\xDC": "U",
    "\xF9": "u",
    "\xFA": "u",
    "\xFB": "u",
    "\xFC": "u",
    "\xDD": "Y",
    "\xFD": "y",
    "\xFF": "y",
    "\xC6": "Ae",
    "\xE6": "ae",
    "\xDE": "Th",
    "\xFE": "th",
    "\xDF": "ss",
    "\u0100": "A",
    "\u0102": "A",
    "\u0104": "A",
    "\u0101": "a",
    "\u0103": "a",
    "\u0105": "a",
    "\u0106": "C",
    "\u0108": "C",
    "\u010A": "C",
    "\u010C": "C",
    "\u0107": "c",
    "\u0109": "c",
    "\u010B": "c",
    "\u010D": "c",
    "\u010E": "D",
    "\u0110": "D",
    "\u010F": "d",
    "\u0111": "d",
    "\u0112": "E",
    "\u0114": "E",
    "\u0116": "E",
    "\u0118": "E",
    "\u011A": "E",
    "\u0113": "e",
    "\u0115": "e",
    "\u0117": "e",
    "\u0119": "e",
    "\u011B": "e",
    "\u011C": "G",
    "\u011E": "G",
    "\u0120": "G",
    "\u0122": "G",
    "\u011D": "g",
    "\u011F": "g",
    "\u0121": "g",
    "\u0123": "g",
    "\u0124": "H",
    "\u0126": "H",
    "\u0125": "h",
    "\u0127": "h",
    "\u0128": "I",
    "\u012A": "I",
    "\u012C": "I",
    "\u012E": "I",
    "\u0130": "I",
    "\u0129": "i",
    "\u012B": "i",
    "\u012D": "i",
    "\u012F": "i",
    "\u0131": "i",
    "\u0134": "J",
    "\u0135": "j",
    "\u0136": "K",
    "\u0137": "k",
    "\u0138": "k",
    "\u0139": "L",
    "\u013B": "L",
    "\u013D": "L",
    "\u013F": "L",
    "\u0141": "L",
    "\u013A": "l",
    "\u013C": "l",
    "\u013E": "l",
    "\u0140": "l",
    "\u0142": "l",
    "\u0143": "N",
    "\u0145": "N",
    "\u0147": "N",
    "\u014A": "N",
    "\u0144": "n",
    "\u0146": "n",
    "\u0148": "n",
    "\u014B": "n",
    "\u014C": "O",
    "\u014E": "O",
    "\u0150": "O",
    "\u014D": "o",
    "\u014F": "o",
    "\u0151": "o",
    "\u0154": "R",
    "\u0156": "R",
    "\u0158": "R",
    "\u0155": "r",
    "\u0157": "r",
    "\u0159": "r",
    "\u015A": "S",
    "\u015C": "S",
    "\u015E": "S",
    "\u0160": "S",
    "\u015B": "s",
    "\u015D": "s",
    "\u015F": "s",
    "\u0161": "s",
    "\u0162": "T",
    "\u0164": "T",
    "\u0166": "T",
    "\u0163": "t",
    "\u0165": "t",
    "\u0167": "t",
    "\u0168": "U",
    "\u016A": "U",
    "\u016C": "U",
    "\u016E": "U",
    "\u0170": "U",
    "\u0172": "U",
    "\u0169": "u",
    "\u016B": "u",
    "\u016D": "u",
    "\u016F": "u",
    "\u0171": "u",
    "\u0173": "u",
    "\u0174": "W",
    "\u0175": "w",
    "\u0176": "Y",
    "\u0177": "y",
    "\u0178": "Y",
    "\u0179": "Z",
    "\u017B": "Z",
    "\u017D": "Z",
    "\u017A": "z",
    "\u017C": "z",
    "\u017E": "z",
    "\u0132": "IJ",
    "\u0133": "ij",
    "\u0152": "Oe",
    "\u0153": "oe",
    "\u0149": "'n",
    "\u017F": "ss"
  };
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var deburrLetter = basePropertyOf(deburredLetters);
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  var snakeCase = createCompounder(function(result, word, index) {
    return result + (index ? "_" : "") + word.toLowerCase();
  });
  module.exports = snakeCase;
});

// node_modules/discord.js/src/util/Transformers.js
var require_Transformers = __commonJS((exports, module) => {
  var toSnakeCase = function(obj) {
    if (typeof obj !== "object" || !obj)
      return obj;
    if (obj instanceof Date)
      return obj;
    if (isJSONEncodable(obj))
      return toSnakeCase(obj.toJSON());
    if (Array.isArray(obj))
      return obj.map(toSnakeCase);
    return Object.fromEntries(Object.entries(obj).map(([key, value]) => [snakeCase(key), toSnakeCase(value)]));
  };
  var _transformAPIAutoModerationAction = function(autoModerationAction) {
    return {
      type: autoModerationAction.type,
      metadata: {
        durationSeconds: autoModerationAction.metadata.duration_seconds ?? null,
        channelId: autoModerationAction.metadata.channel_id ?? null,
        customMessage: autoModerationAction.metadata.custom_message ?? null
      }
    };
  };
  var { isJSONEncodable } = require_dist();
  var snakeCase = require_lodash();
  module.exports = { toSnakeCase, _transformAPIAutoModerationAction };
});

// node_modules/discord.js/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    $schema: "https://json.schemastore.org/package.json",
    name: "discord.js",
    version: "14.14.1",
    description: "A powerful library for interacting with the Discord API",
    main: "./src/index.js",
    types: "./typings/index.d.ts",
    directories: {
      lib: "src",
      test: "test"
    },
    files: [
      "src",
      "typings"
    ],
    contributors: [
      "Crawl <icrawltogo@gmail.com>",
      "Amish Shah <amishshah.2k@gmail.com>",
      "Vlad Frangu <kingdgrizzle@gmail.com>",
      "SpaceEEC <spaceeec@yahoo.com>",
      "Aura Rom\xE1n <kyradiscord@gmail.com>"
    ],
    license: "Apache-2.0",
    keywords: [
      "discord",
      "api",
      "bot",
      "client",
      "node",
      "discordapp"
    ],
    repository: {
      type: "git",
      url: "https://github.com/discordjs/discord.js.git",
      directory: "packages/discord.js"
    },
    bugs: {
      url: "https://github.com/discordjs/discord.js/issues"
    },
    homepage: "https://discord.js.org",
    dependencies: {
      "@discordjs/collection": "1.5.3",
      "@sapphire/snowflake": "3.5.1",
      "@types/ws": "8.5.9",
      "discord-api-types": "0.37.61",
      "fast-deep-equal": "3.1.3",
      "lodash.snakecase": "4.1.1",
      tslib: "2.6.2",
      undici: "5.27.2",
      ws: "8.14.2",
      "@discordjs/builders": "^1.7.0",
      "@discordjs/formatters": "^0.3.3",
      "@discordjs/util": "^1.0.2",
      "@discordjs/rest": "^2.1.0",
      "@discordjs/ws": "^1.0.2"
    },
    devDependencies: {
      "@favware/cliff-jumper": "2.2.1",
      "@types/node": "16.18.60",
      "@typescript-eslint/eslint-plugin": "^6.10.0",
      "@typescript-eslint/parser": "^6.10.0",
      "cross-env": "^7.0.3",
      dtslint: "4.2.1",
      eslint: "8.53.0",
      "eslint-formatter-pretty": "5.0.0",
      jest: "29.7.0",
      prettier: "3.0.3",
      tsd: "0.29.0",
      tslint: "6.1.3",
      turbo: "^1.10.17-canary.0",
      typescript: "5.2.2",
      "@discordjs/api-extractor": "^7.38.1",
      "@discordjs/docgen": "^0.12.1"
    },
    engines: {
      node: ">=16.11.0"
    },
    scripts: {
      test: "pnpm run docs:test && pnpm run test:typescript",
      "test:typescript": "tsc --noEmit && tsd",
      lint: "prettier --check . && tslint typings/index.d.ts && cross-env ESLINT_USE_FLAT_CONFIG=false eslint --format=pretty src typings",
      format: "prettier --write . && cross-env ESLINT_USE_FLAT_CONFIG=false eslint --fix --format=pretty src",
      fmt: "pnpm run format",
      docs: "docgen -i './src/*.js' './src/**/*.js' -c ./docs/index.json -r ../../ -o ./docs/docs.json && pnpm run docs:new",
      "docs:test": "docgen -i './src/*.js' './src/**/*.js' -c ./docs/index.json -r ../../",
      "docs:new": "api-extractor -d run --local",
      changelog: "git cliff --prepend ./CHANGELOG.md -u -c ./cliff.toml -r ../../ --include-path 'packages/discord.js/*'",
      release: "cliff-jumper"
    }
  };
});

// node_modules/@discordjs/collection/dist/index.js
var require_dist7 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersect(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of other) {
        if (this.has(key) && Object.is(value, this.get(key))) {
          coll.set(key, value);
        }
      }
      return coll;
    }
    subtract(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key) || !Object.is(value, other.get(key))) {
          coll.set(key, value);
        }
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    sorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.values()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "1.5.3";
});

// node_modules/discord.js/src/util/LimitedCollection.js
var require_LimitedCollection = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class LimitedCollection extends Collection {
    constructor(options = {}, iterable) {
      if (typeof options !== "object" || options === null) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      }
      const { maxSize = Infinity, keepOverLimit = null } = options;
      if (typeof maxSize !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "maxSize", "number");
      }
      if (keepOverLimit !== null && typeof keepOverLimit !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "keepOverLimit", "function");
      }
      super(iterable);
      this.maxSize = maxSize;
      this.keepOverLimit = keepOverLimit;
    }
    set(key, value) {
      if (this.maxSize === 0 && !this.keepOverLimit?.(value, key, this))
        return this;
      if (this.size >= this.maxSize && !this.has(key)) {
        for (const [k, v] of this.entries()) {
          const keep = this.keepOverLimit?.(v, k, this) ?? false;
          if (!keep) {
            this.delete(k);
            break;
          }
        }
      }
      return super.set(key, value);
    }
    static get [Symbol.species]() {
      return Collection;
    }
  }
  module.exports = LimitedCollection;
});

// node_modules/discord.js/src/util/Options.js
var require_Options = __commonJS((exports, module) => {
  var { DefaultRestOptions, DefaultUserAgentAppendix } = require_dist6();
  var { toSnakeCase } = require_Transformers();
  var { version } = require_package();

  class Options extends null {
    static userAgentAppendix = `discord.js/${version} ${DefaultUserAgentAppendix}`.trimEnd();
    static createDefault() {
      return {
        closeTimeout: 5000,
        waitGuildTimeout: 15000,
        shardCount: 1,
        makeCache: this.cacheWithLimits(this.DefaultMakeCacheSettings),
        partials: [],
        failIfNotExists: true,
        presence: {},
        sweepers: this.DefaultSweeperSettings,
        ws: {
          large_threshold: 50,
          version: 10
        },
        rest: {
          ...DefaultRestOptions,
          userAgentAppendix: this.userAgentAppendix
        },
        jsonTransformer: toSnakeCase
      };
    }
    static cacheWithLimits(settings = {}) {
      const { Collection } = require_dist7();
      const LimitedCollection = require_LimitedCollection();
      return (managerType, _, manager) => {
        const setting = settings[manager.name] ?? settings[managerType.name];
        if (setting == null) {
          return new Collection;
        }
        if (typeof setting === "number") {
          if (setting === Infinity) {
            return new Collection;
          }
          return new LimitedCollection({ maxSize: setting });
        }
        const noLimit = setting.maxSize == null || setting.maxSize === Infinity;
        if (noLimit) {
          return new Collection;
        }
        return new LimitedCollection(setting);
      };
    }
    static cacheEverything() {
      const { Collection } = require_dist7();
      return () => new Collection;
    }
    static get DefaultMakeCacheSettings() {
      return {
        MessageManager: 200
      };
    }
    static get DefaultSweeperSettings() {
      return {
        threads: {
          interval: 3600,
          lifetime: 14400
        }
      };
    }
  }
  module.exports = Options;
});

// node_modules/discord.js/src/util/Colors.js
var require_Colors = __commonJS((exports, module) => {
  module.exports = {
    Default: 0,
    White: 16777215,
    Aqua: 1752220,
    Green: 5763719,
    Blue: 3447003,
    Yellow: 16705372,
    Purple: 10181046,
    LuminousVividPink: 15277667,
    Fuchsia: 15418782,
    Gold: 15844367,
    Orange: 15105570,
    Red: 15548997,
    Grey: 9807270,
    Navy: 3426654,
    DarkAqua: 1146986,
    DarkGreen: 2067276,
    DarkBlue: 2123412,
    DarkPurple: 7419530,
    DarkVividPink: 11342935,
    DarkGold: 12745742,
    DarkOrange: 11027200,
    DarkRed: 10038562,
    DarkGrey: 9936031,
    DarkerGrey: 8359053,
    LightGrey: 12370112,
    DarkNavy: 2899536,
    Blurple: 5793266,
    Greyple: 10070709,
    DarkButNotBlack: 2895667,
    NotQuiteBlack: 2303786
  };
});

// node_modules/discord.js/src/util/BitField.js
var require_BitField = __commonJS((exports, module) => {
  var { DiscordjsRangeError, ErrorCodes } = require_errors2();

  class BitField {
    static Flags = {};
    static DefaultBit = 0;
    constructor(bits = this.constructor.DefaultBit) {
      this.bitfield = this.constructor.resolve(bits);
    }
    any(bit) {
      return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;
    }
    equals(bit) {
      return this.bitfield === this.constructor.resolve(bit);
    }
    has(bit) {
      bit = this.constructor.resolve(bit);
      return (this.bitfield & bit) === bit;
    }
    missing(bits, ...hasParams) {
      return new this.constructor(bits).remove(this).toArray(...hasParams);
    }
    freeze() {
      return Object.freeze(this);
    }
    add(...bits) {
      let total = this.constructor.DefaultBit;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield | total);
      this.bitfield |= total;
      return this;
    }
    remove(...bits) {
      let total = this.constructor.DefaultBit;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield & ~total);
      this.bitfield &= ~total;
      return this;
    }
    serialize(...hasParams) {
      const serialized = {};
      for (const [flag, bit] of Object.entries(this.constructor.Flags)) {
        if (isNaN(flag))
          serialized[flag] = this.has(bit, ...hasParams);
      }
      return serialized;
    }
    toArray(...hasParams) {
      return [...this[Symbol.iterator](...hasParams)];
    }
    toJSON() {
      return typeof this.bitfield === "number" ? this.bitfield : this.bitfield.toString();
    }
    valueOf() {
      return this.bitfield;
    }
    *[Symbol.iterator](...hasParams) {
      for (const bitName of Object.keys(this.constructor.Flags)) {
        if (isNaN(bitName) && this.has(bitName, ...hasParams))
          yield bitName;
      }
    }
    static resolve(bit) {
      const { DefaultBit } = this;
      if (typeof DefaultBit === typeof bit && bit >= DefaultBit)
        return bit;
      if (bit instanceof BitField)
        return bit.bitfield;
      if (Array.isArray(bit)) {
        return bit.map((bit_) => this.resolve(bit_)).reduce((prev, bit_) => prev | bit_, DefaultBit);
      }
      if (typeof bit === "string") {
        if (!isNaN(bit))
          return typeof DefaultBit === "bigint" ? BigInt(bit) : Number(bit);
        if (this.Flags[bit] !== undefined)
          return this.Flags[bit];
      }
      throw new DiscordjsRangeError(ErrorCodes.BitFieldInvalid, bit);
    }
  }
  module.exports = BitField;
});

// node_modules/discord.js/src/util/AttachmentFlagsBitField.js
var require_AttachmentFlagsBitField = __commonJS((exports, module) => {
  var { AttachmentFlags } = require_v106();
  var BitField = require_BitField();

  class AttachmentFlagsBitField extends BitField {
    static Flags = AttachmentFlags;
  }
  module.exports = AttachmentFlagsBitField;
});

// node_modules/discord.js/src/structures/Attachment.js
var require_Attachment = __commonJS((exports, module) => {
  var AttachmentFlagsBitField = require_AttachmentFlagsBitField();
  var { basename, flatten } = require_Util();

  class Attachment {
    constructor(data) {
      this.attachment = data.url;
      this.name = data.filename;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("size" in data) {
        this.size = data.size;
      }
      if ("url" in data) {
        this.url = data.url;
      }
      if ("proxy_url" in data) {
        this.proxyURL = data.proxy_url;
      }
      if ("height" in data) {
        this.height = data.height;
      } else {
        this.height ??= null;
      }
      if ("width" in data) {
        this.width = data.width;
      } else {
        this.width ??= null;
      }
      if ("content_type" in data) {
        this.contentType = data.content_type;
      } else {
        this.contentType ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      this.ephemeral = data.ephemeral ?? false;
      if ("duration_secs" in data) {
        this.duration = data.duration_secs;
      } else {
        this.duration ??= null;
      }
      if ("waveform" in data) {
        this.waveform = data.waveform;
      } else {
        this.waveform ??= null;
      }
      if ("flags" in data) {
        this.flags = new AttachmentFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new AttachmentFlagsBitField().freeze();
      }
    }
    get spoiler() {
      return basename(this.url ?? this.name).startsWith("SPOILER_");
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = Attachment;
});

// node_modules/@discordjs/formatters/dist/index.js
var require_dist8 = __commonJS((exports, module) => {
  var escapeMarkdown = function(text, options = {}) {
    const {
      codeBlock: codeBlock2 = true,
      inlineCode: inlineCode2 = true,
      bold: bold2 = true,
      italic: italic2 = true,
      underline = true,
      strikethrough: strikethrough2 = true,
      spoiler: spoiler2 = true,
      codeBlockContent = true,
      inlineCodeContent = true,
      escape = true,
      heading: heading2 = false,
      bulletedList = false,
      numberedList = false,
      maskedLink = false
    } = options;
    if (!codeBlockContent) {
      return text.split("```").map((subString, index, array) => {
        if (index % 2 && index !== array.length - 1)
          return subString;
        return escapeMarkdown(subString, {
          inlineCode: inlineCode2,
          bold: bold2,
          italic: italic2,
          underline,
          strikethrough: strikethrough2,
          spoiler: spoiler2,
          inlineCodeContent,
          escape,
          heading: heading2,
          bulletedList,
          numberedList,
          maskedLink
        });
      }).join(codeBlock2 ? "\\`\\`\\`" : "```");
    }
    if (!inlineCodeContent) {
      return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {
        if (index % 2 && index !== array.length - 1)
          return subString;
        return escapeMarkdown(subString, {
          codeBlock: codeBlock2,
          bold: bold2,
          italic: italic2,
          underline,
          strikethrough: strikethrough2,
          spoiler: spoiler2,
          escape,
          heading: heading2,
          bulletedList,
          numberedList,
          maskedLink
        });
      }).join(inlineCode2 ? "\\`" : "`");
    }
    let res = text;
    if (escape)
      res = escapeEscape(res);
    if (inlineCode2)
      res = escapeInlineCode(res);
    if (codeBlock2)
      res = escapeCodeBlock(res);
    if (italic2)
      res = escapeItalic(res);
    if (bold2)
      res = escapeBold(res);
    if (underline)
      res = escapeUnderline(res);
    if (strikethrough2)
      res = escapeStrikethrough(res);
    if (spoiler2)
      res = escapeSpoiler(res);
    if (heading2)
      res = escapeHeading(res);
    if (bulletedList)
      res = escapeBulletedList(res);
    if (numberedList)
      res = escapeNumberedList(res);
    if (maskedLink)
      res = escapeMaskedLink(res);
    return res;
  };
  var escapeCodeBlock = function(text) {
    return text.replaceAll("```", "\\`\\`\\`");
  };
  var escapeInlineCode = function(text) {
    return text.replaceAll(/(?<=^|[^`])``?(?=[^`]|$)/g, (match) => match.length === 2 ? "\\`\\`" : "\\`");
  };
  var escapeItalic = function(text) {
    let idx = 0;
    const newText = text.replaceAll(/(?<=^|[^*])\*([^*]|\*\*|$)/g, (_, match) => {
      if (match === "**")
        return ++idx % 2 ? `\\*${match}` : `${match}\\*`;
      return `\\*${match}`;
    });
    idx = 0;
    return newText.replaceAll(/(?<=^|[^_])(?<!<a?:.+)_(?!:\d+>)([^_]|__|$)/g, (_, match) => {
      if (match === "__")
        return ++idx % 2 ? `\\_${match}` : `${match}\\_`;
      return `\\_${match}`;
    });
  };
  var escapeBold = function(text) {
    let idx = 0;
    return text.replaceAll(/\*\*(\*)?/g, (_, match) => {
      if (match)
        return ++idx % 2 ? `${match}\\*\\*` : `\\*\\*${match}`;
      return "\\*\\*";
    });
  };
  var escapeUnderline = function(text) {
    let idx = 0;
    return text.replaceAll(/(?<!<a?:.+)__(_)?(?!:\d+>)/g, (_, match) => {
      if (match)
        return ++idx % 2 ? `${match}\\_\\_` : `\\_\\_${match}`;
      return "\\_\\_";
    });
  };
  var escapeStrikethrough = function(text) {
    return text.replaceAll("~~", "\\~\\~");
  };
  var escapeSpoiler = function(text) {
    return text.replaceAll("||", "\\|\\|");
  };
  var escapeEscape = function(text) {
    return text.replaceAll("\\", "\\\\");
  };
  var escapeHeading = function(text) {
    return text.replaceAll(/^( {0,2})([*-] )?( *)(#{1,3} )/gm, "$1$2$3\\$4");
  };
  var escapeBulletedList = function(text) {
    return text.replaceAll(/^( *)([*-])( +)/gm, "$1\\$2$3");
  };
  var escapeNumberedList = function(text) {
    return text.replaceAll(/^( *\d+)\./gm, "$1\\.");
  };
  var escapeMaskedLink = function(text) {
    return text.replaceAll(/\[.+]\(.+\)/gm, "\\$&");
  };
  var codeBlock = function(language, content) {
    return content === undefined ? `\`\`\`
${language}
\`\`\`` : `\`\`\`${language}
${content}
\`\`\``;
  };
  var inlineCode = function(content) {
    return `\`${content}\``;
  };
  var italic = function(content) {
    return `_${content}_`;
  };
  var bold = function(content) {
    return `**${content}**`;
  };
  var underscore = function(content) {
    return `__${content}__`;
  };
  var strikethrough = function(content) {
    return `~~${content}~~`;
  };
  var quote = function(content) {
    return `> ${content}`;
  };
  var blockQuote = function(content) {
    return `>>> ${content}`;
  };
  var hideLinkEmbed = function(url) {
    return `<${url}>`;
  };
  var hyperlink = function(content, url, title) {
    return title ? `[${content}](${url} "${title}")` : `[${content}](${url})`;
  };
  var spoiler = function(content) {
    return `||${content}||`;
  };
  var userMention = function(userId) {
    return `<@${userId}>`;
  };
  var channelMention = function(channelId) {
    return `<#${channelId}>`;
  };
  var roleMention = function(roleId) {
    return `<@&${roleId}>`;
  };
  var chatInputApplicationCommandMention = function(commandName, subcommandGroupName, subcommandName, commandId) {
    if (commandId !== undefined) {
      return `</${commandName} ${subcommandGroupName} ${subcommandName}:${commandId}>`;
    }
    if (subcommandName !== undefined) {
      return `</${commandName} ${subcommandGroupName}:${subcommandName}>`;
    }
    return `</${commandName}:${subcommandGroupName}>`;
  };
  var formatEmoji = function(emojiId, animated = false) {
    return `<${animated ? "a" : ""}:_:${emojiId}>`;
  };
  var channelLink = function(channelId, guildId) {
    return `https://discord.com/channels/${guildId ?? "@me"}/${channelId}`;
  };
  var messageLink = function(channelId, messageId, guildId) {
    return `${guildId === undefined ? channelLink(channelId) : channelLink(channelId, guildId)}/${messageId}`;
  };
  var heading = function(content, level) {
    switch (level) {
      case 3:
        return `### ${content}`;
      case 2:
        return `## ${content}`;
      default:
        return `# ${content}`;
    }
  };
  var listCallback = function(element, startNumber, depth = 0) {
    if (Array.isArray(element)) {
      return element.map((element2) => listCallback(element2, startNumber, depth + 1)).join("\n");
    }
    return `${"  ".repeat(depth - 1)}${startNumber ? `${startNumber}.` : "-"} ${element}`;
  };
  var orderedList = function(list, startNumber = 1) {
    return listCallback(list, Math.max(startNumber, 1));
  };
  var unorderedList = function(list) {
    return listCallback(list);
  };
  var time = function(timeOrSeconds, style) {
    if (typeof timeOrSeconds !== "number") {
      timeOrSeconds = Math.floor((timeOrSeconds?.getTime() ?? Date.now()) / 1000);
    }
    return typeof style === "string" ? `<t:${timeOrSeconds}:${style}>` : `<t:${timeOrSeconds}>`;
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Faces: () => Faces,
    GuildNavigationMentions: () => GuildNavigationMentions,
    HeadingLevel: () => HeadingLevel,
    TimestampStyles: () => TimestampStyles,
    blockQuote: () => blockQuote,
    bold: () => bold,
    channelLink: () => channelLink,
    channelMention: () => channelMention,
    chatInputApplicationCommandMention: () => chatInputApplicationCommandMention,
    codeBlock: () => codeBlock,
    escapeBold: () => escapeBold,
    escapeBulletedList: () => escapeBulletedList,
    escapeCodeBlock: () => escapeCodeBlock,
    escapeEscape: () => escapeEscape,
    escapeHeading: () => escapeHeading,
    escapeInlineCode: () => escapeInlineCode,
    escapeItalic: () => escapeItalic,
    escapeMarkdown: () => escapeMarkdown,
    escapeMaskedLink: () => escapeMaskedLink,
    escapeNumberedList: () => escapeNumberedList,
    escapeSpoiler: () => escapeSpoiler,
    escapeStrikethrough: () => escapeStrikethrough,
    escapeUnderline: () => escapeUnderline,
    formatEmoji: () => formatEmoji,
    heading: () => heading,
    hideLinkEmbed: () => hideLinkEmbed,
    hyperlink: () => hyperlink,
    inlineCode: () => inlineCode,
    italic: () => italic,
    messageLink: () => messageLink,
    orderedList: () => orderedList,
    quote: () => quote,
    roleMention: () => roleMention,
    spoiler: () => spoiler,
    strikethrough: () => strikethrough,
    time: () => time,
    underscore: () => underscore,
    unorderedList: () => unorderedList,
    userMention: () => userMention
  });
  module.exports = __toCommonJS(src_exports);
  __name(escapeMarkdown, "escapeMarkdown");
  __name(escapeCodeBlock, "escapeCodeBlock");
  __name(escapeInlineCode, "escapeInlineCode");
  __name(escapeItalic, "escapeItalic");
  __name(escapeBold, "escapeBold");
  __name(escapeUnderline, "escapeUnderline");
  __name(escapeStrikethrough, "escapeStrikethrough");
  __name(escapeSpoiler, "escapeSpoiler");
  __name(escapeEscape, "escapeEscape");
  __name(escapeHeading, "escapeHeading");
  __name(escapeBulletedList, "escapeBulletedList");
  __name(escapeNumberedList, "escapeNumberedList");
  __name(escapeMaskedLink, "escapeMaskedLink");
  __name(codeBlock, "codeBlock");
  __name(inlineCode, "inlineCode");
  __name(italic, "italic");
  __name(bold, "bold");
  __name(underscore, "underscore");
  __name(strikethrough, "strikethrough");
  __name(quote, "quote");
  __name(blockQuote, "blockQuote");
  __name(hideLinkEmbed, "hideLinkEmbed");
  __name(hyperlink, "hyperlink");
  __name(spoiler, "spoiler");
  __name(userMention, "userMention");
  __name(channelMention, "channelMention");
  __name(roleMention, "roleMention");
  __name(chatInputApplicationCommandMention, "chatInputApplicationCommandMention");
  __name(formatEmoji, "formatEmoji");
  __name(channelLink, "channelLink");
  __name(messageLink, "messageLink");
  var HeadingLevel = ((HeadingLevel2) => {
    HeadingLevel2[HeadingLevel2["One"] = 1] = "One";
    HeadingLevel2[HeadingLevel2["Two"] = 2] = "Two";
    HeadingLevel2[HeadingLevel2["Three"] = 3] = "Three";
    return HeadingLevel2;
  })(HeadingLevel || {});
  __name(heading, "heading");
  __name(listCallback, "listCallback");
  __name(orderedList, "orderedList");
  __name(unorderedList, "unorderedList");
  __name(time, "time");
  var TimestampStyles = {
    ShortTime: "t",
    LongTime: "T",
    ShortDate: "d",
    LongDate: "D",
    ShortDateTime: "f",
    LongDateTime: "F",
    RelativeTime: "R"
  };
  var Faces = ((Faces2) => {
    Faces2["Shrug"] = "\xAF_(\u30C4)_/\xAF";
    Faces2["Tableflip"] = "(\u256F\xB0\u25A1\xB0)\u256F\uFE35 \u253B\u2501\u253B";
    Faces2["Unflip"] = "\u252C\u2500\u252C\u30CE( \xBA _ \xBA\u30CE)";
    return Faces2;
  })(Faces || {});
  var GuildNavigationMentions = ((GuildNavigationMentions2) => {
    GuildNavigationMentions2["Browse"] = "<id:browse>";
    GuildNavigationMentions2["Customize"] = "<id:customize>";
    GuildNavigationMentions2["Guide"] = "<id:guide>";
    return GuildNavigationMentions2;
  })(GuildNavigationMentions || {});
});

// node_modules/discord.js/src/structures/Base.js
var require_Base = __commonJS((exports, module) => {
  var { flatten } = require_Util();

  class Base {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
    _patch(data) {
      return data;
    }
    _update(data) {
      const clone = this._clone();
      this._patch(data);
      return clone;
    }
    toJSON(...props) {
      return flatten(this, ...props);
    }
    valueOf() {
      return this.id;
    }
  }
  module.exports = Base;
});

// node_modules/discord.js/src/util/ChannelFlagsBitField.js
var require_ChannelFlagsBitField = __commonJS((exports, module) => {
  var { ChannelFlags } = require_v106();
  var BitField = require_BitField();

  class ChannelFlagsBitField extends BitField {
    static Flags = ChannelFlags;
  }
  module.exports = ChannelFlagsBitField;
});

// node_modules/discord.js/src/util/Constants.js
var require_Constants = __commonJS((exports) => {
  var { ChannelType, MessageType, ComponentType, ImageFormat, StickerFormatType } = require_v106();
  exports.MaxBulkDeletableMessageAge = 1209600000;
  exports.SweeperKeys = [
    "autoModerationRules",
    "applicationCommands",
    "bans",
    "emojis",
    "invites",
    "guildMembers",
    "messages",
    "presences",
    "reactions",
    "stageInstances",
    "stickers",
    "threadMembers",
    "threads",
    "users",
    "voiceStates"
  ];
  exports.NonSystemMessageTypes = [
    MessageType.Default,
    MessageType.Reply,
    MessageType.ChatInputCommand,
    MessageType.ContextMenuCommand
  ];
  exports.GuildTextBasedChannelTypes = [
    ChannelType.GuildText,
    ChannelType.GuildAnnouncement,
    ChannelType.AnnouncementThread,
    ChannelType.PublicThread,
    ChannelType.PrivateThread,
    ChannelType.GuildVoice,
    ChannelType.GuildStageVoice
  ];
  exports.TextBasedChannelTypes = [...exports.GuildTextBasedChannelTypes, ChannelType.DM];
  exports.ThreadChannelTypes = [ChannelType.AnnouncementThread, ChannelType.PublicThread, ChannelType.PrivateThread];
  exports.VoiceBasedChannelTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
  exports.SelectMenuTypes = [
    ComponentType.StringSelect,
    ComponentType.UserSelect,
    ComponentType.RoleSelect,
    ComponentType.MentionableSelect,
    ComponentType.ChannelSelect
  ];
  exports.DeletableMessageTypes = [
    MessageType.AutoModerationAction,
    MessageType.ChannelFollowAdd,
    MessageType.ChannelPinnedMessage,
    MessageType.ChatInputCommand,
    MessageType.ContextMenuCommand,
    MessageType.Default,
    MessageType.GuildBoost,
    MessageType.GuildBoostTier1,
    MessageType.GuildBoostTier2,
    MessageType.GuildBoostTier3,
    MessageType.GuildInviteReminder,
    MessageType.InteractionPremiumUpsell,
    MessageType.Reply,
    MessageType.RoleSubscriptionPurchase,
    MessageType.StageEnd,
    MessageType.StageRaiseHand,
    MessageType.StageSpeaker,
    MessageType.StageStart,
    MessageType.StageTopic,
    MessageType.ThreadCreated,
    MessageType.UserJoin
  ];
  exports.StickerFormatExtensionMap = {
    [StickerFormatType.PNG]: ImageFormat.PNG,
    [StickerFormatType.APNG]: ImageFormat.PNG,
    [StickerFormatType.Lottie]: ImageFormat.Lottie,
    [StickerFormatType.GIF]: ImageFormat.GIF
  };
});

// node_modules/discord.js/src/structures/BaseChannel.js
var require_BaseChannel = __commonJS((exports) => {
  var { channelLink, channelMention } = require_dist8();
  var { DiscordSnowflake } = require_dist3();
  var { ChannelType, Routes } = require_v106();
  var Base = require_Base();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();
  var { ThreadChannelTypes } = require_Constants();

  class BaseChannel extends Base {
    constructor(client, data, immediatePatch = true) {
      super(client);
      this.type = data.type;
      if (data && immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      if ("flags" in data) {
        this.flags = new ChannelFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new ChannelFlagsBitField().freeze();
      }
      this.id = data.id;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get url() {
      return this.isDMBased() ? channelLink(this.id) : channelLink(this.id, this.guildId);
    }
    get partial() {
      return false;
    }
    toString() {
      return channelMention(this.id);
    }
    async delete() {
      await this.client.rest.delete(Routes.channel(this.id));
      return this;
    }
    fetch(force = true) {
      return this.client.channels.fetch(this.id, { force });
    }
    isThread() {
      return ThreadChannelTypes.includes(this.type);
    }
    isTextBased() {
      return "messages" in this;
    }
    isDMBased() {
      return [ChannelType.DM, ChannelType.GroupDM].includes(this.type);
    }
    isVoiceBased() {
      return "bitrate" in this;
    }
    isThreadOnly() {
      return "availableTags" in this;
    }
    toJSON(...props) {
      return super.toJSON({ createdTimestamp: true }, ...props);
    }
  }
  exports.BaseChannel = BaseChannel;
});

// node_modules/discord.js/src/managers/BaseManager.js
var require_BaseManager = __commonJS((exports, module) => {
  class BaseManager {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
    }
  }
  module.exports = BaseManager;
});

// node_modules/discord.js/src/managers/DataManager.js
var require_DataManager = __commonJS((exports, module) => {
  var BaseManager = require_BaseManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class DataManager extends BaseManager {
    constructor(client, holds) {
      super(client);
      Object.defineProperty(this, "holds", { value: holds });
    }
    get cache() {
      throw new DiscordjsError(ErrorCodes.NotImplemented, "get cache", this.constructor.name);
    }
    resolve(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance;
      if (typeof idOrInstance === "string")
        return this.cache.get(idOrInstance) ?? null;
      return null;
    }
    resolveId(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance.id;
      if (typeof idOrInstance === "string")
        return idOrInstance;
      return null;
    }
    valueOf() {
      return this.cache;
    }
  }
  module.exports = DataManager;
});

// node_modules/discord.js/src/util/Symbols.js
var require_Symbols = __commonJS((exports) => {
  exports.MakeCacheOverrideSymbol = Symbol("djs.managers.makeCacheOverride");
});

// node_modules/discord.js/src/managers/CachedManager.js
var require_CachedManager = __commonJS((exports, module) => {
  var DataManager = require_DataManager();
  var { MakeCacheOverrideSymbol } = require_Symbols();

  class CachedManager extends DataManager {
    constructor(client, holds, iterable) {
      super(client, holds);
      Object.defineProperty(this, "_cache", {
        value: this.client.options.makeCache(this.constructor[MakeCacheOverrideSymbol] ?? this.constructor, this.holds, this.constructor)
      });
      if (iterable) {
        for (const item of iterable) {
          this._add(item);
        }
      }
    }
    get cache() {
      return this._cache;
    }
    _add(data, cache = true, { id, extras = [] } = {}) {
      const existing = this.cache.get(id ?? data.id);
      if (existing) {
        if (cache) {
          existing._patch(data);
          return existing;
        }
        const clone = existing._clone();
        clone._patch(data);
        return clone;
      }
      const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;
      if (cache)
        this.cache.set(id ?? entry.id, entry);
      return entry;
    }
  }
  module.exports = CachedManager;
});

// node_modules/discord.js/src/util/PermissionsBitField.js
var require_PermissionsBitField = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BitField = require_BitField();

  class PermissionsBitField extends BitField {
    static Flags = PermissionFlagsBits;
    static All = Object.values(PermissionFlagsBits).reduce((all, p) => all | p, 0n);
    static Default = BigInt(104324673);
    static StageModerator = PermissionFlagsBits.ManageChannels | PermissionFlagsBits.MuteMembers | PermissionFlagsBits.MoveMembers;
    static DefaultBit = BigInt(0);
    missing(bits, checkAdmin = true) {
      return checkAdmin && this.has(PermissionFlagsBits.Administrator) ? [] : super.missing(bits);
    }
    any(permission, checkAdmin = true) {
      return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.any(permission);
    }
    has(permission, checkAdmin = true) {
      return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.has(permission);
    }
    toArray() {
      return super.toArray(false);
    }
  }
  module.exports = PermissionsBitField;
});

// node_modules/discord.js/src/util/RoleFlagsBitField.js
var require_RoleFlagsBitField = __commonJS((exports, module) => {
  var { RoleFlags } = require_v106();
  var BitField = require_BitField();

  class RoleFlagsBitField extends BitField {
    static Flags = RoleFlags;
  }
  module.exports = RoleFlagsBitField;
});

// node_modules/discord.js/src/structures/Role.js
var require_Role = __commonJS((exports) => {
  var { roleMention } = require_dist8();
  var { DiscordSnowflake } = require_dist3();
  var { PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var PermissionsBitField = require_PermissionsBitField();
  var RoleFlagsBitField = require_RoleFlagsBitField();

  class Role extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.icon = null;
      this.unicodeEmoji = null;
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("color" in data) {
        this.color = data.color;
      }
      if ("hoist" in data) {
        this.hoist = data.hoist;
      }
      if ("position" in data) {
        this.rawPosition = data.position;
      }
      if ("permissions" in data) {
        this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();
      }
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("mentionable" in data) {
        this.mentionable = data.mentionable;
      }
      if ("icon" in data)
        this.icon = data.icon;
      if ("unicode_emoji" in data)
        this.unicodeEmoji = data.unicode_emoji;
      if ("flags" in data) {
        this.flags = new RoleFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new RoleFlagsBitField().freeze();
      }
      this.tags = data.tags ? {} : null;
      if (data.tags) {
        if ("bot_id" in data.tags) {
          this.tags.botId = data.tags.bot_id;
        }
        if ("integration_id" in data.tags) {
          this.tags.integrationId = data.tags.integration_id;
        }
        if ("premium_subscriber" in data.tags) {
          this.tags.premiumSubscriberRole = true;
        }
        if ("subscription_listing_id" in data.tags) {
          this.tags.subscriptionListingId = data.tags.subscription_listing_id;
        }
        if ("available_for_purchase" in data.tags) {
          this.tags.availableForPurchase = true;
        }
        if ("guild_connections" in data.tags) {
          this.tags.guildConnections = true;
        }
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get hexColor() {
      return `#${this.color.toString(16).padStart(6, "0")}`;
    }
    get members() {
      return this.id === this.guild.id ? this.guild.members.cache.clone() : this.guild.members.cache.filter((member) => member._roles.includes(this.id));
    }
    get editable() {
      if (this.managed)
        return false;
      const clientMember = this.guild.members.resolve(this.client.user);
      if (!clientMember.permissions.has(PermissionFlagsBits.ManageRoles))
        return false;
      return clientMember.roles.highest.comparePositionTo(this) > 0;
    }
    get position() {
      return this.guild.roles.cache.reduce((acc, role) => acc + (this.rawPosition === role.rawPosition ? BigInt(this.id) < BigInt(role.id) : this.rawPosition > role.rawPosition), 0);
    }
    comparePositionTo(role) {
      return this.guild.roles.comparePositions(this, role);
    }
    edit(options) {
      return this.guild.roles.edit(this, options);
    }
    permissionsIn(channel, checkAdmin = true) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      return channel.rolePermissions(this, checkAdmin);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setColor(color, reason) {
      return this.edit({ color, reason });
    }
    setHoist(hoist = true, reason) {
      return this.edit({ hoist, reason });
    }
    setPermissions(permissions, reason) {
      return this.edit({ permissions, reason });
    }
    setMentionable(mentionable = true, reason) {
      return this.edit({ mentionable, reason });
    }
    setIcon(icon, reason) {
      return this.edit({ icon, reason });
    }
    setUnicodeEmoji(unicodeEmoji, reason) {
      return this.edit({ unicodeEmoji, reason });
    }
    setPosition(position, options = {}) {
      return this.guild.roles.setPosition(this, position, options);
    }
    async delete(reason) {
      await this.guild.roles.delete(this.id, reason);
      return this;
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);
    }
    equals(role) {
      return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed && this.icon === role.icon && this.unicodeEmoji === role.unicodeEmoji;
    }
    toString() {
      if (this.id === this.guild.id)
        return "@everyone";
      return roleMention(this.id);
    }
    toJSON() {
      return {
        ...super.toJSON({ createdTimestamp: true }),
        permissions: this.permissions.toJSON()
      };
    }
  }
  exports.Role = Role;
});

// node_modules/discord.js/src/structures/PermissionOverwrites.js
var require_PermissionOverwrites = __commonJS((exports, module) => {
  var { OverwriteType } = require_v106();
  var Base = require_Base();
  var { Role } = require_Role();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var PermissionsBitField = require_PermissionsBitField();

  class PermissionOverwrites extends Base {
    constructor(client, data, channel) {
      super(client);
      Object.defineProperty(this, "channel", { value: channel });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("type" in data) {
        this.type = data.type;
      }
      if ("deny" in data) {
        this.deny = new PermissionsBitField(BigInt(data.deny)).freeze();
      }
      if ("allow" in data) {
        this.allow = new PermissionsBitField(BigInt(data.allow)).freeze();
      }
    }
    async edit(options, reason) {
      await this.channel.permissionOverwrites.upsert(this.id, options, { type: this.type, reason }, this);
      return this;
    }
    async delete(reason) {
      await this.channel.permissionOverwrites.delete(this.id, reason);
      return this;
    }
    toJSON() {
      return {
        id: this.id,
        type: this.type,
        allow: this.allow,
        deny: this.deny
      };
    }
    static resolveOverwriteOptions(options, { allow, deny } = {}) {
      allow = new PermissionsBitField(allow);
      deny = new PermissionsBitField(deny);
      for (const [perm, value] of Object.entries(options)) {
        if (value === true) {
          allow.add(perm);
          deny.remove(perm);
        } else if (value === false) {
          allow.remove(perm);
          deny.add(perm);
        } else if (value === null) {
          allow.remove(perm);
          deny.remove(perm);
        }
      }
      return { allow, deny };
    }
    static resolve(overwrite, guild) {
      if (overwrite instanceof this)
        return overwrite.toJSON();
      if (typeof overwrite.id === "string" && overwrite.type in OverwriteType) {
        return {
          id: overwrite.id,
          type: overwrite.type,
          allow: PermissionsBitField.resolve(overwrite.allow ?? PermissionsBitField.DefaultBit).toString(),
          deny: PermissionsBitField.resolve(overwrite.deny ?? PermissionsBitField.DefaultBit).toString()
        };
      }
      const userOrRole = guild.roles.resolve(overwrite.id) ?? guild.client.users.resolve(overwrite.id);
      if (!userOrRole)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
      const type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
      return {
        id: userOrRole.id,
        type,
        allow: PermissionsBitField.resolve(overwrite.allow ?? PermissionsBitField.DefaultBit).toString(),
        deny: PermissionsBitField.resolve(overwrite.deny ?? PermissionsBitField.DefaultBit).toString()
      };
    }
  }
  module.exports = PermissionOverwrites;
});

// node_modules/discord.js/src/managers/PermissionOverwriteManager.js
var require_PermissionOverwriteManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist7();
  var { OverwriteType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var PermissionOverwrites = require_PermissionOverwrites();
  var { Role } = require_Role();
  var cacheWarningEmitted = false;

  class PermissionOverwriteManager extends CachedManager {
    constructor(channel, iterable) {
      super(channel.client, PermissionOverwrites);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.channel = channel;
      if (iterable) {
        for (const item of iterable) {
          this._add(item);
        }
      }
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.channel] });
    }
    set(overwrites, reason) {
      if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {
        return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidType, "overwrites", "Array or Collection of Permission Overwrites", true));
      }
      return this.channel.edit({ permissionOverwrites: overwrites, reason });
    }
    async upsert(userOrRole, options, overwriteOptions = {}, existing) {
      let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
      let { type, reason } = overwriteOptions;
      if (typeof type !== "number") {
        userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);
        if (!userOrRole)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
        type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
      }
      const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options, existing);
      await this.client.rest.put(Routes.channelPermission(this.channel.id, userOrRoleId), {
        body: { id: userOrRoleId, type, allow, deny },
        reason
      });
      return this.channel;
    }
    create(userOrRole, options, overwriteOptions) {
      return this.upsert(userOrRole, options, overwriteOptions);
    }
    edit(userOrRole, options, overwriteOptions) {
      const existing = this.cache.get(this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole));
      return this.upsert(userOrRole, options, overwriteOptions, existing);
    }
    async delete(userOrRole, reason) {
      const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
      if (!userOrRoleId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
      await this.client.rest.delete(Routes.channelPermission(this.channel.id, userOrRoleId), { reason });
      return this.channel;
    }
  }
  module.exports = PermissionOverwriteManager;
});

// node_modules/discord.js/src/structures/GuildChannel.js
var require_GuildChannel = __commonJS((exports, module) => {
  var { Snowflake } = require_dist3();
  var { PermissionFlagsBits, ChannelType } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var PermissionOverwriteManager = require_PermissionOverwriteManager();
  var { VoiceBasedChannelTypes } = require_Constants();
  var PermissionsBitField = require_PermissionsBitField();
  var { getSortableGroupTypes } = require_Util();

  class GuildChannel extends BaseChannel {
    constructor(guild, data, client, immediatePatch = true) {
      super(client, data, false);
      this.guild = guild;
      this.guildId = guild?.id ?? data.guild_id;
      this.permissionOverwrites = new PermissionOverwriteManager(this);
      if (data && immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("name" in data) {
        this.name = data.name;
      }
      if ("position" in data) {
        this.rawPosition = data.position;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("parent_id" in data) {
        this.parentId = data.parent_id;
      } else {
        this.parentId ??= null;
      }
      if ("permission_overwrites" in data) {
        this.permissionOverwrites.cache.clear();
        for (const overwrite of data.permission_overwrites) {
          this.permissionOverwrites._add(overwrite);
        }
      }
    }
    _clone() {
      const clone = super._clone();
      clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());
      return clone;
    }
    get parent() {
      return this.guild.channels.resolve(this.parentId);
    }
    get permissionsLocked() {
      if (!this.parent)
        return null;
      const overwriteIds = new Set([
        ...this.permissionOverwrites.cache.keys(),
        ...this.parent.permissionOverwrites.cache.keys()
      ]);
      return [...overwriteIds].every((key) => {
        const channelVal = this.permissionOverwrites.cache.get(key);
        const parentVal = this.parent.permissionOverwrites.cache.get(key);
        if (!channelVal && parentVal.deny.bitfield === PermissionsBitField.DefaultBit && parentVal.allow.bitfield === PermissionsBitField.DefaultBit || !parentVal && channelVal.deny.bitfield === PermissionsBitField.DefaultBit && channelVal.allow.bitfield === PermissionsBitField.DefaultBit) {
          return true;
        }
        return channelVal !== undefined && parentVal !== undefined && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;
      });
    }
    get position() {
      const selfIsCategory = this.type === ChannelType.GuildCategory;
      const types = getSortableGroupTypes(this.type);
      let count = 0;
      for (const channel of this.guild.channels.cache.values()) {
        if (!types.includes(channel.type))
          continue;
        if (!selfIsCategory && channel.parentId !== this.parentId)
          continue;
        if (this.rawPosition === channel.rawPosition) {
          if (Snowflake.compare(channel.id, this.id) === -1)
            count++;
        } else if (this.rawPosition > channel.rawPosition) {
          count++;
        }
      }
      return count;
    }
    permissionsFor(memberOrRole, checkAdmin = true) {
      const member = this.guild.members.resolve(memberOrRole);
      if (member)
        return this.memberPermissions(member, checkAdmin);
      const role = this.guild.roles.resolve(memberOrRole);
      return role && this.rolePermissions(role, checkAdmin);
    }
    overwritesFor(member, verified = false, roles = null) {
      if (!verified)
        member = this.guild.members.resolve(member);
      if (!member)
        return [];
      roles ??= member.roles.cache;
      const roleOverwrites = [];
      let memberOverwrites;
      let everyoneOverwrites;
      for (const overwrite of this.permissionOverwrites.cache.values()) {
        if (overwrite.id === this.guild.id) {
          everyoneOverwrites = overwrite;
        } else if (roles.has(overwrite.id)) {
          roleOverwrites.push(overwrite);
        } else if (overwrite.id === member.id) {
          memberOverwrites = overwrite;
        }
      }
      return {
        everyone: everyoneOverwrites,
        roles: roleOverwrites,
        member: memberOverwrites
      };
    }
    memberPermissions(member, checkAdmin) {
      if (checkAdmin && member.id === this.guild.ownerId) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const roles = member.roles.cache;
      const permissions = new PermissionsBitField(roles.map((role) => role.permissions));
      if (checkAdmin && permissions.has(PermissionFlagsBits.Administrator)) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const overwrites = this.overwritesFor(member, true, roles);
      return permissions.remove(overwrites.everyone?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.everyone?.allow ?? PermissionsBitField.DefaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.deny) : PermissionsBitField.DefaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.allow) : PermissionsBitField.DefaultBit).remove(overwrites.member?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.member?.allow ?? PermissionsBitField.DefaultBit).freeze();
    }
    rolePermissions(role, checkAdmin) {
      if (checkAdmin && role.permissions.has(PermissionFlagsBits.Administrator)) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);
      const roleOverwrites = this.permissionOverwrites.cache.get(role.id);
      return role.permissions.remove(everyoneOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(everyoneOverwrites?.allow ?? PermissionsBitField.DefaultBit).remove(roleOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(roleOverwrites?.allow ?? PermissionsBitField.DefaultBit).freeze();
    }
    lockPermissions() {
      if (!this.parent)
        return Promise.reject(new DiscordjsError(ErrorCodes.GuildChannelOrphan));
      const permissionOverwrites = this.parent.permissionOverwrites.cache.map((overwrite) => overwrite.toJSON());
      return this.edit({ permissionOverwrites });
    }
    get members() {
      return this.guild.members.cache.filter((member) => this.permissionsFor(member).has(PermissionFlagsBits.ViewChannel, false));
    }
    edit(options) {
      return this.guild.channels.edit(this, options);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setParent(channel, { lockPermissions = true, reason } = {}) {
      return this.edit({
        parent: channel ?? null,
        lockPermissions,
        reason
      });
    }
    setPosition(position, options = {}) {
      return this.guild.channels.setPosition(this, position, options);
    }
    clone(options = {}) {
      return this.guild.channels.create({
        name: options.name ?? this.name,
        permissionOverwrites: this.permissionOverwrites.cache,
        topic: this.topic,
        type: this.type,
        nsfw: this.nsfw,
        parent: this.parent,
        bitrate: this.bitrate,
        userLimit: this.userLimit,
        rateLimitPerUser: this.rateLimitPerUser,
        position: this.rawPosition,
        reason: null,
        ...options
      });
    }
    equals(channel) {
      let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;
      if (equal) {
        if (this.permissionOverwrites && channel.permissionOverwrites) {
          equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);
        } else {
          equal = !this.permissionOverwrites && !channel.permissionOverwrites;
        }
      }
      return equal;
    }
    get deletable() {
      return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;
    }
    get manageable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      if (this.guild.members.me.communicationDisabledUntilTimestamp > Date.now())
        return false;
      const bitfield = VoiceBasedChannelTypes.includes(this.type) ? PermissionFlagsBits.ManageChannels | PermissionFlagsBits.Connect : PermissionFlagsBits.ViewChannel | PermissionFlagsBits.ManageChannels;
      return permissions.has(bitfield, false);
    }
    get viewable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has(PermissionFlagsBits.ViewChannel, false);
    }
    async delete(reason) {
      await this.guild.channels.delete(this.id, reason);
      return this;
    }
  }
  module.exports = GuildChannel;
});

// node_modules/discord.js/src/util/Util.js
var require_Util = __commonJS((exports, module) => {
  var flatten = function(obj, ...props) {
    if (!isObject(obj))
      return obj;
    const objProps = Object.keys(obj).filter((key) => !key.startsWith("_")).map((key) => ({ [key]: true }));
    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);
    const out = {};
    for (let [prop, newProp] of Object.entries(props)) {
      if (!newProp)
        continue;
      newProp = newProp === true ? prop : newProp;
      const element = obj[prop];
      const elemIsObj = isObject(element);
      const valueOf = elemIsObj && typeof element.valueOf === "function" ? element.valueOf() : null;
      const hasToJSON = elemIsObj && typeof element.toJSON === "function";
      if (element instanceof Collection)
        out[newProp] = Array.from(element.keys());
      else if (valueOf instanceof Collection)
        out[newProp] = Array.from(valueOf.keys());
      else if (Array.isArray(element))
        out[newProp] = element.map((elm) => elm.toJSON?.() ?? flatten(elm));
      else if (typeof valueOf !== "object")
        out[newProp] = valueOf;
      else if (hasToJSON)
        out[newProp] = element.toJSON();
      else if (typeof element === "object")
        out[newProp] = flatten(element);
      else if (!elemIsObj)
        out[newProp] = element;
    }
    return out;
  };
  async function fetchRecommendedShardCount(token, { guildsPerShard = 1000, multipleOf = 1 } = {}) {
    if (!token)
      throw new DiscordjsError(ErrorCodes.TokenMissing);
    const response = await fetch2(RouteBases.api + Routes.gatewayBot(), {
      method: "GET",
      headers: { Authorization: `Bot ${token.replace(/^Bot\s*/i, "")}` }
    });
    if (!response.ok) {
      if (response.status === 401)
        throw new DiscordjsError(ErrorCodes.TokenInvalid);
      throw response;
    }
    const { shards } = await response.json();
    return Math.ceil(shards * (1000 / guildsPerShard) / multipleOf) * multipleOf;
  }
  var parseEmoji = function(text) {
    if (text.includes("%"))
      text = decodeURIComponent(text);
    if (!text.includes(":"))
      return { animated: false, name: text, id: undefined };
    const match = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
    return match && { animated: Boolean(match[1]), name: match[2], id: match[3] };
  };
  var resolvePartialEmoji = function(emoji) {
    if (!emoji)
      return null;
    if (typeof emoji === "string")
      return /^\d{17,19}$/.test(emoji) ? { id: emoji } : parseEmoji(emoji);
    const { id, name, animated } = emoji;
    if (!id && !name)
      return null;
    return { id, name, animated: Boolean(animated) };
  };
  var makeError = function(obj) {
    const err = new Error(obj.message);
    err.name = obj.name;
    err.stack = obj.stack;
    return err;
  };
  var makePlainError = function(err) {
    return {
      name: err.name,
      message: err.message,
      stack: err.stack
    };
  };
  var getSortableGroupTypes = function(type) {
    switch (type) {
      case ChannelType.GuildText:
      case ChannelType.GuildAnnouncement:
      case ChannelType.GuildForum:
      case ChannelType.GuildMedia:
        return TextSortableGroupTypes;
      case ChannelType.GuildVoice:
      case ChannelType.GuildStageVoice:
        return VoiceSortableGroupTypes;
      case ChannelType.GuildCategory:
        return CategorySortableGroupTypes;
      default:
        return [type];
    }
  };
  var moveElementInArray = function(array, element, newIndex, offset = false) {
    const index = array.indexOf(element);
    newIndex = (offset ? index : 0) + newIndex;
    if (newIndex > -1 && newIndex < array.length) {
      const removedElement = array.splice(index, 1)[0];
      array.splice(newIndex, 0, removedElement);
    }
    return array.indexOf(element);
  };
  var verifyString = function(data, error = Error, errorMessage = `Expected a string, got ${data} instead.`, allowEmpty = true) {
    if (typeof data !== "string")
      throw new error(errorMessage);
    if (!allowEmpty && data.length === 0)
      throw new error(errorMessage);
    return data;
  };
  var resolveColor = function(color) {
    if (typeof color === "string") {
      if (color === "Random")
        return Math.floor(Math.random() * (16777215 + 1));
      if (color === "Default")
        return 0;
      if (/^#?[\da-f]{6}$/i.test(color))
        return parseInt(color.replace("#", ""), 16);
      color = Colors[color];
    } else if (Array.isArray(color)) {
      color = (color[0] << 16) + (color[1] << 8) + color[2];
    }
    if (color < 0 || color > 16777215)
      throw new DiscordjsRangeError(ErrorCodes.ColorRange);
    if (typeof color !== "number" || Number.isNaN(color))
      throw new DiscordjsTypeError(ErrorCodes.ColorConvert);
    return color;
  };
  var discordSort = function(collection) {
    const isGuildChannel = collection.first() instanceof GuildChannel;
    return collection.sorted(isGuildChannel ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id)) : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id)));
  };
  async function setPosition(item, position, relative, sorted, client, route, reason) {
    let updatedItems = [...sorted.values()];
    moveElementInArray(updatedItems, item, position, relative);
    updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));
    await client.rest.patch(route, { body: updatedItems, reason });
    return updatedItems;
  }
  var basename = function(path, ext) {
    const res = parse(path);
    return ext && res.ext.startsWith(ext) ? res.name : res.base.split("?")[0];
  };
  var cleanContent = function(str, channel) {
    return str.replaceAll(/<(?:(?<type>@[!&]?|#)|(?:\/(?<commandName>[-_\p{L}\p{N}\p{sc=Deva}\p{sc=Thai} ]+):)|(?:a?:(?<emojiName>[\w]+):))(?<id>\d{17,19})>/gu, (match, type, commandName, emojiName, id) => {
      if (commandName)
        return `/${commandName}`;
      if (emojiName)
        return `:${emojiName}:`;
      switch (type) {
        case "@":
        case "@!": {
          const member = channel.guild?.members.cache.get(id);
          if (member) {
            return `@${member.displayName}`;
          }
          const user = channel.client.users.cache.get(id);
          return user ? `@${user.displayName}` : match;
        }
        case "@&": {
          if (channel.type === ChannelType.DM)
            return match;
          const role = channel.guild.roles.cache.get(id);
          return role ? `@${role.name}` : match;
        }
        case "#": {
          const mentionedChannel = channel.client.channels.cache.get(id);
          return mentionedChannel ? `#${mentionedChannel.name}` : match;
        }
        default: {
          return match;
        }
      }
    });
  };
  var cleanCodeBlockContent = function(text) {
    return text.replaceAll("```", "`\u200B``");
  };
  var parseWebhookURL = function(url) {
    const matches = url.match(/https?:\/\/(?:ptb\.|canary\.)?discord\.com\/api(?:\/v\d{1,2})?\/webhooks\/(\d{17,19})\/([\w-]{68})/i);
    if (!matches || matches.length <= 2)
      return null;
    const [, id, token] = matches;
    return {
      id,
      token
    };
  };
  var transformResolved = function({ client, guild, channel }, { members, users, channels, roles, messages, attachments } = {}) {
    const result = {};
    if (members) {
      result.members = new Collection;
      for (const [id, member] of Object.entries(members)) {
        const user = users[id];
        result.members.set(id, guild?.members._add({ user, ...member }) ?? member);
      }
    }
    if (users) {
      result.users = new Collection;
      for (const user of Object.values(users)) {
        result.users.set(user.id, client.users._add(user));
      }
    }
    if (roles) {
      result.roles = new Collection;
      for (const role of Object.values(roles)) {
        result.roles.set(role.id, guild?.roles._add(role) ?? role);
      }
    }
    if (channels) {
      result.channels = new Collection;
      for (const apiChannel of Object.values(channels)) {
        result.channels.set(apiChannel.id, client.channels._add(apiChannel, guild) ?? apiChannel);
      }
    }
    if (messages) {
      result.messages = new Collection;
      for (const message of Object.values(messages)) {
        result.messages.set(message.id, channel?.messages?._add(message) ?? message);
      }
    }
    if (attachments) {
      result.attachments = new Collection;
      for (const attachment of Object.values(attachments)) {
        const patched = new Attachment(attachment);
        result.attachments.set(attachment.id, patched);
      }
    }
    return result;
  };
  var { parse } = __require("node:path");
  var { Collection } = require_dist7();
  var { ChannelType, RouteBases, Routes } = require_v106();
  var { fetch: fetch2 } = require_undici();
  var Colors = require_Colors();
  var { DiscordjsError, DiscordjsRangeError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var isObject = (d) => typeof d === "object" && d !== null;
  var TextSortableGroupTypes = [
    ChannelType.GuildText,
    ChannelType.GuildAnnouncement,
    ChannelType.GuildForum,
    ChannelType.GuildMedia
  ];
  var VoiceSortableGroupTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
  var CategorySortableGroupTypes = [ChannelType.GuildCategory];
  module.exports = {
    flatten,
    fetchRecommendedShardCount,
    parseEmoji,
    resolvePartialEmoji,
    makeError,
    makePlainError,
    getSortableGroupTypes,
    moveElementInArray,
    verifyString,
    resolveColor,
    discordSort,
    setPosition,
    basename,
    cleanContent,
    cleanCodeBlockContent,
    parseWebhookURL,
    transformResolved
  };
  var Attachment = require_Attachment();
  var GuildChannel = require_GuildChannel();
});

// node_modules/discord.js/src/client/BaseClient.js
var require_BaseClient = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var { REST } = require_dist6();
  var { Routes } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var Options = require_Options();
  var { flatten } = require_Util();

  class BaseClient extends EventEmitter {
    constructor(options = {}) {
      super({ captureRejections: true });
      if (typeof options !== "object" || options === null) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      }
      const defaultOptions = Options.createDefault();
      this.options = {
        ...defaultOptions,
        ...options,
        presence: {
          ...defaultOptions.presence,
          ...options.presence
        },
        sweepers: {
          ...defaultOptions.sweepers,
          ...options.sweepers
        },
        ws: {
          ...defaultOptions.ws,
          ...options.ws
        },
        rest: {
          ...defaultOptions.rest,
          ...options.rest,
          userAgentAppendix: options.rest?.userAgentAppendix ? `${Options.userAgentAppendix} ${options.rest.userAgentAppendix}` : undefined
        }
      };
      this.rest = new REST(this.options.rest);
    }
    destroy() {
      this.rest.clearHashSweeper();
      this.rest.clearHandlerSweeper();
    }
    async deleteWebhook(id, { token, reason } = {}) {
      await this.rest.delete(Routes.webhook(id, token), { auth: !token, reason });
    }
    incrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners - 1);
      }
    }
    toJSON(...props) {
      return flatten(this, ...props);
    }
  }
  module.exports = BaseClient;
});

// node_modules/discord.js/src/util/Enums.js
var require_Enums = __commonJS((exports, module) => {
  var createEnum = function(keys) {
    const obj = {};
    for (const [index, key] of keys.entries()) {
      if (key === null)
        continue;
      obj[key] = index;
      obj[index] = key;
    }
    return obj;
  };
  module.exports = { createEnum };
});

// node_modules/discord.js/src/util/Partials.js
var require_Partials = __commonJS((exports, module) => {
  var { createEnum } = require_Enums();
  module.exports = createEnum([
    "User",
    "Channel",
    "GuildMember",
    "Message",
    "Reaction",
    "GuildScheduledEvent",
    "ThreadMember"
  ]);
});

// node_modules/discord.js/src/client/actions/Action.js
var require_Action = __commonJS((exports, module) => {
  var Partials = require_Partials();

  class GenericAction {
    constructor(client) {
      this.client = client;
    }
    handle(data) {
      return data;
    }
    getPayload(data, manager, id, partialType, cache) {
      return this.client.options.partials.includes(partialType) ? manager._add(data, cache) : manager.cache.get(id);
    }
    getChannel(data) {
      const payloadData = {};
      const id = data.channel_id ?? data.id;
      if ("recipients" in data) {
        payloadData.recipients = data.recipients;
      } else {
        const recipient = data.author ?? data.user ?? { id: data.user_id };
        if (recipient.id !== this.client.user.id)
          payloadData.recipients = [recipient];
      }
      if (id !== undefined)
        payloadData.id = id;
      if ("guild_id" in data)
        payloadData.guild_id = data.guild_id;
      if ("last_message_id" in data)
        payloadData.last_message_id = data.last_message_id;
      return data[this.client.actions.injectedChannel] ?? this.getPayload(payloadData, this.client.channels, id, Partials.Channel);
    }
    getMessage(data, channel, cache) {
      const id = data.message_id ?? data.id;
      return data[this.client.actions.injectedMessage] ?? this.getPayload({
        id,
        channel_id: channel.id,
        guild_id: data.guild_id ?? channel.guild?.id
      }, channel.messages, id, Partials.Message, cache);
    }
    getReaction(data, message, user) {
      const id = data.emoji.id ?? decodeURIComponent(data.emoji.name);
      return this.getPayload({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user?.id === this.client.user.id
      }, message.reactions, id, Partials.Reaction);
    }
    getMember(data, guild) {
      return this.getPayload(data, guild.members, data.user.id, Partials.GuildMember);
    }
    getUser(data) {
      const id = data.user_id;
      return data[this.client.actions.injectedUser] ?? this.getPayload({ id }, this.client.users, id, Partials.User);
    }
    getUserFromMember(data) {
      if (data.guild_id && data.member?.user) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (guild) {
          return guild.members._add(data.member).user;
        } else {
          return this.client.users._add(data.member.user);
        }
      }
      return this.getUser(data);
    }
    getScheduledEvent(data, guild) {
      const id = data.guild_scheduled_event_id ?? data.id;
      return this.getPayload({ id, guild_id: data.guild_id ?? guild.id }, guild.scheduledEvents, id, Partials.GuildScheduledEvent);
    }
    getThreadMember(id, manager) {
      return this.getPayload({ user_id: id }, manager, id, Partials.ThreadMember, false);
    }
  }
  module.exports = GenericAction;
});

// node_modules/discord.js/src/util/Events.js
var require_Events = __commonJS((exports, module) => {
  module.exports = {
    ApplicationCommandPermissionsUpdate: "applicationCommandPermissionsUpdate",
    AutoModerationActionExecution: "autoModerationActionExecution",
    AutoModerationRuleCreate: "autoModerationRuleCreate",
    AutoModerationRuleDelete: "autoModerationRuleDelete",
    AutoModerationRuleUpdate: "autoModerationRuleUpdate",
    CacheSweep: "cacheSweep",
    ChannelCreate: "channelCreate",
    ChannelDelete: "channelDelete",
    ChannelPinsUpdate: "channelPinsUpdate",
    ChannelUpdate: "channelUpdate",
    ClientReady: "ready",
    Debug: "debug",
    Error: "error",
    GuildAuditLogEntryCreate: "guildAuditLogEntryCreate",
    GuildAvailable: "guildAvailable",
    GuildBanAdd: "guildBanAdd",
    GuildBanRemove: "guildBanRemove",
    GuildCreate: "guildCreate",
    GuildDelete: "guildDelete",
    GuildEmojiCreate: "emojiCreate",
    GuildEmojiDelete: "emojiDelete",
    GuildEmojiUpdate: "emojiUpdate",
    GuildIntegrationsUpdate: "guildIntegrationsUpdate",
    GuildMemberAdd: "guildMemberAdd",
    GuildMemberAvailable: "guildMemberAvailable",
    GuildMemberRemove: "guildMemberRemove",
    GuildMembersChunk: "guildMembersChunk",
    GuildMemberUpdate: "guildMemberUpdate",
    GuildRoleCreate: "roleCreate",
    GuildRoleDelete: "roleDelete",
    GuildRoleUpdate: "roleUpdate",
    GuildScheduledEventCreate: "guildScheduledEventCreate",
    GuildScheduledEventDelete: "guildScheduledEventDelete",
    GuildScheduledEventUpdate: "guildScheduledEventUpdate",
    GuildScheduledEventUserAdd: "guildScheduledEventUserAdd",
    GuildScheduledEventUserRemove: "guildScheduledEventUserRemove",
    GuildStickerCreate: "stickerCreate",
    GuildStickerDelete: "stickerDelete",
    GuildStickerUpdate: "stickerUpdate",
    GuildUnavailable: "guildUnavailable",
    GuildUpdate: "guildUpdate",
    InteractionCreate: "interactionCreate",
    Invalidated: "invalidated",
    InviteCreate: "inviteCreate",
    InviteDelete: "inviteDelete",
    MessageBulkDelete: "messageDeleteBulk",
    MessageCreate: "messageCreate",
    MessageDelete: "messageDelete",
    MessageReactionAdd: "messageReactionAdd",
    MessageReactionRemove: "messageReactionRemove",
    MessageReactionRemoveAll: "messageReactionRemoveAll",
    MessageReactionRemoveEmoji: "messageReactionRemoveEmoji",
    MessageUpdate: "messageUpdate",
    PresenceUpdate: "presenceUpdate",
    Raw: "raw",
    ShardDisconnect: "shardDisconnect",
    ShardError: "shardError",
    ShardReady: "shardReady",
    ShardReconnecting: "shardReconnecting",
    ShardResume: "shardResume",
    StageInstanceCreate: "stageInstanceCreate",
    StageInstanceDelete: "stageInstanceDelete",
    StageInstanceUpdate: "stageInstanceUpdate",
    ThreadCreate: "threadCreate",
    ThreadDelete: "threadDelete",
    ThreadListSync: "threadListSync",
    ThreadMembersUpdate: "threadMembersUpdate",
    ThreadMemberUpdate: "threadMemberUpdate",
    ThreadUpdate: "threadUpdate",
    TypingStart: "typingStart",
    UserUpdate: "userUpdate",
    VoiceServerUpdate: "voiceServerUpdate",
    VoiceStateUpdate: "voiceStateUpdate",
    Warn: "warn",
    WebhooksUpdate: "webhookUpdate"
  };
});

// node_modules/discord.js/src/client/actions/ApplicationCommandPermissionsUpdate.js
var require_ApplicationCommandPermissionsUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ApplicationCommandPermissionsUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      client.emit(Events.ApplicationCommandPermissionsUpdate, {
        permissions: data.permissions,
        id: data.id,
        guildId: data.guild_id,
        applicationId: data.application_id
      });
    }
  }
  module.exports = ApplicationCommandPermissionsUpdateAction;
});

// node_modules/discord.js/src/structures/AutoModerationActionExecution.js
var require_AutoModerationActionExecution = __commonJS((exports, module) => {
  var { _transformAPIAutoModerationAction } = require_Transformers();

  class AutoModerationActionExecution {
    constructor(data, guild) {
      this.guild = guild;
      this.action = _transformAPIAutoModerationAction(data.action);
      this.ruleId = data.rule_id;
      this.ruleTriggerType = data.rule_trigger_type;
      this.userId = data.user_id;
      this.channelId = data.channel_id ?? null;
      this.messageId = data.message_id ?? null;
      this.alertSystemMessageId = data.alert_system_message_id ?? null;
      this.content = data.content;
      this.matchedKeyword = data.matched_keyword ?? null;
      this.matchedContent = data.matched_content ?? null;
    }
    get autoModerationRule() {
      return this.guild.autoModerationRules.cache.get(this.ruleId) ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get user() {
      return this.guild.client.users.cache.get(this.userId) ?? null;
    }
    get member() {
      return this.guild.members.cache.get(this.userId) ?? null;
    }
  }
  module.exports = AutoModerationActionExecution;
});

// node_modules/discord.js/src/client/actions/AutoModerationActionExecution.js
var require_AutoModerationActionExecution2 = __commonJS((exports, module) => {
  var Action = require_Action();
  var AutoModerationActionExecution = require_AutoModerationActionExecution();
  var Events = require_Events();

  class AutoModerationActionExecutionAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        client.emit(Events.AutoModerationActionExecution, new AutoModerationActionExecution(data, guild));
      }
      return {};
    }
  }
  module.exports = AutoModerationActionExecutionAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleCreate.js
var require_AutoModerationRuleCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleCreateAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const autoModerationRule = guild.autoModerationRules._add(data);
        client.emit(Events.AutoModerationRuleCreate, autoModerationRule);
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleCreateAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleDelete.js
var require_AutoModerationRuleDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleDeleteAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const autoModerationRule = guild.autoModerationRules.cache.get(data.id);
        if (autoModerationRule) {
          guild.autoModerationRules.cache.delete(autoModerationRule.id);
          client.emit(Events.AutoModerationRuleDelete, autoModerationRule);
        }
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleDeleteAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleUpdate.js
var require_AutoModerationRuleUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleUpdateAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldAutoModerationRule = guild.autoModerationRules.cache.get(data.id)?._clone() ?? null;
        const newAutoModerationRule = guild.autoModerationRules._add(data);
        client.emit(Events.AutoModerationRuleUpdate, oldAutoModerationRule, newAutoModerationRule);
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleUpdateAction;
});

// node_modules/discord.js/src/client/actions/ChannelCreate.js
var require_ChannelCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ChannelCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const existing = client.channels.cache.has(data.id);
      const channel = client.channels._add(data);
      if (!existing && channel) {
        client.emit(Events.ChannelCreate, channel);
      }
      return { channel };
    }
  }
  module.exports = ChannelCreateAction;
});

// node_modules/discord.js/src/client/actions/ChannelDelete.js
var require_ChannelDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ChannelDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.id);
      if (channel) {
        client.channels._remove(channel.id);
        client.emit(Events.ChannelDelete, channel);
      }
    }
  }
  module.exports = ChannelDeleteAction;
});

// node_modules/discord.js/src/managers/CategoryChannelChildManager.js
var require_CategoryChannelChildManager = __commonJS((exports, module) => {
  var DataManager = require_DataManager();
  var GuildChannel = require_GuildChannel();

  class CategoryChannelChildManager extends DataManager {
    constructor(channel) {
      super(channel.client, GuildChannel);
      this.channel = channel;
    }
    get cache() {
      return this.guild.channels.cache.filter((channel) => channel.parentId === this.channel.id);
    }
    get guild() {
      return this.channel.guild;
    }
    create(options) {
      return this.guild.channels.create({
        ...options,
        parent: this.channel.id
      });
    }
  }
  module.exports = CategoryChannelChildManager;
});

// node_modules/discord.js/src/structures/CategoryChannel.js
var require_CategoryChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var CategoryChannelChildManager = require_CategoryChannelChildManager();

  class CategoryChannel extends GuildChannel {
    get children() {
      return new CategoryChannelChildManager(this);
    }
  }
  module.exports = CategoryChannel;
});

// node_modules/discord.js/src/structures/interfaces/Collector.js
var require_Collector = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { Collection } = require_dist7();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { flatten } = require_Util();

  class Collector extends EventEmitter {
    constructor(client, options = {}) {
      super();
      Object.defineProperty(this, "client", { value: client });
      this.filter = options.filter ?? (() => true);
      this.options = options;
      this.collected = new Collection;
      this.ended = false;
      this._timeout = null;
      this._idletimeout = null;
      this._endReason = null;
      if (typeof this.filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.filter", "function");
      }
      this.handleCollect = this.handleCollect.bind(this);
      this.handleDispose = this.handleDispose.bind(this);
      if (options.time)
        this._timeout = setTimeout2(() => this.stop("time"), options.time).unref();
      if (options.idle)
        this._idletimeout = setTimeout2(() => this.stop("idle"), options.idle).unref();
      this.lastCollectedTimestamp = null;
    }
    get lastCollectedAt() {
      return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);
    }
    async handleCollect(...args) {
      const collectedId = await this.collect(...args);
      if (collectedId) {
        const filterResult = await this.filter(...args, this.collected);
        if (filterResult) {
          this.collected.set(collectedId, args[0]);
          this.emit("collect", ...args);
          this.lastCollectedTimestamp = Date.now();
          if (this._idletimeout) {
            clearTimeout2(this._idletimeout);
            this._idletimeout = setTimeout2(() => this.stop("idle"), this.options.idle).unref();
          }
        } else {
          this.emit("ignore", ...args);
        }
      }
      this.checkEnd();
    }
    async handleDispose(...args) {
      if (!this.options.dispose)
        return;
      const dispose = this.dispose(...args);
      if (!dispose || !await this.filter(...args) || !this.collected.has(dispose))
        return;
      this.collected.delete(dispose);
      this.emit("dispose", ...args);
      this.checkEnd();
    }
    get next() {
      return new Promise((resolve, reject) => {
        if (this.ended) {
          reject(this.collected);
          return;
        }
        const cleanup = () => {
          this.removeListener("collect", onCollect);
          this.removeListener("end", onEnd);
        };
        const onCollect = (item) => {
          cleanup();
          resolve(item);
        };
        const onEnd = () => {
          cleanup();
          reject(this.collected);
        };
        this.on("collect", onCollect);
        this.on("end", onEnd);
      });
    }
    stop(reason = "user") {
      if (this.ended)
        return;
      if (this._timeout) {
        clearTimeout2(this._timeout);
        this._timeout = null;
      }
      if (this._idletimeout) {
        clearTimeout2(this._idletimeout);
        this._idletimeout = null;
      }
      this._endReason = reason;
      this.ended = true;
      this.emit("end", this.collected, reason);
    }
    resetTimer({ time, idle } = {}) {
      if (this._timeout) {
        clearTimeout2(this._timeout);
        this._timeout = setTimeout2(() => this.stop("time"), time ?? this.options.time).unref();
      }
      if (this._idletimeout) {
        clearTimeout2(this._idletimeout);
        this._idletimeout = setTimeout2(() => this.stop("idle"), idle ?? this.options.idle).unref();
      }
    }
    checkEnd() {
      const reason = this.endReason;
      if (reason)
        this.stop(reason);
      return Boolean(reason);
    }
    async* [Symbol.asyncIterator]() {
      const queue = [];
      const onCollect = (...item) => queue.push(item);
      this.on("collect", onCollect);
      try {
        while (queue.length || !this.ended) {
          if (queue.length) {
            yield queue.shift();
          } else {
            await new Promise((resolve) => {
              const tick = () => {
                this.removeListener("collect", tick);
                this.removeListener("end", tick);
                return resolve();
              };
              this.on("collect", tick);
              this.on("end", tick);
            });
          }
        }
      } finally {
        this.removeListener("collect", onCollect);
      }
    }
    toJSON() {
      return flatten(this);
    }
    get endReason() {
      return this._endReason;
    }
    collect() {
    }
    dispose() {
    }
  }
  module.exports = Collector;
});

// node_modules/discord.js/src/structures/InteractionCollector.js
var require_InteractionCollector = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var Collector = require_Collector();
  var Events = require_Events();

  class InteractionCollector extends Collector {
    constructor(client, options = {}) {
      super(client, options);
      this.messageId = options.message?.id ?? options.interactionResponse?.interaction.message?.id ?? null;
      this.messageInteractionId = options.interactionResponse?.id ?? null;
      this.channelId = options.interactionResponse?.interaction.channelId ?? options.message?.channelId ?? options.message?.channel_id ?? this.client.channels.resolveId(options.channel);
      this.guildId = options.interactionResponse?.interaction.guildId ?? options.message?.guildId ?? options.message?.guild_id ?? this.client.guilds.resolveId(options.channel?.guild) ?? this.client.guilds.resolveId(options.guild);
      this.interactionType = options.interactionType ?? null;
      this.componentType = options.componentType ?? null;
      this.users = new Collection;
      this.total = 0;
      this.client.incrementMaxListeners();
      const bulkDeleteListener = (messages) => {
        if (messages.has(this.messageId))
          this.stop("messageDelete");
      };
      if (this.messageId || this.messageInteractionId) {
        this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
        this.client.on(Events.MessageDelete, this._handleMessageDeletion);
        this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      }
      if (this.channelId) {
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      }
      if (this.guildId) {
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      }
      this.client.on(Events.InteractionCreate, this.handleCollect);
      this.once("end", () => {
        this.client.removeListener(Events.InteractionCreate, this.handleCollect);
        this.client.removeListener(Events.MessageDelete, this._handleMessageDeletion);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
      this.on("collect", (interaction) => {
        this.total++;
        this.users.set(interaction.user.id, interaction.user);
      });
    }
    collect(interaction) {
      if (this.interactionType && interaction.type !== this.interactionType)
        return null;
      if (this.componentType && interaction.componentType !== this.componentType)
        return null;
      if (this.messageId && interaction.message?.id !== this.messageId)
        return null;
      if (this.messageInteractionId && interaction.message?.interaction?.id && interaction.message.interaction.id !== this.messageInteractionId) {
        return null;
      }
      if (this.channelId && interaction.channelId !== this.channelId)
        return null;
      if (this.guildId && interaction.guildId !== this.guildId)
        return null;
      return interaction.id;
    }
    dispose(interaction) {
      if (this.type && interaction.type !== this.type)
        return null;
      if (this.componentType && interaction.componentType !== this.componentType)
        return null;
      if (this.messageId && interaction.message?.id !== this.messageId)
        return null;
      if (this.messageInteractionId && interaction.message?.interaction?.id && interaction.message.interaction.id !== this.messageInteractionId) {
        return null;
      }
      if (this.channelId && interaction.channelId !== this.channelId)
        return null;
      if (this.guildId && interaction.guildId !== this.guildId)
        return null;
      return interaction.id;
    }
    empty() {
      this.total = 0;
      this.collected.clear();
      this.users.clear();
      this.checkEnd();
    }
    get endReason() {
      if (this.options.max && this.total >= this.options.max)
        return "limit";
      if (this.options.maxComponents && this.collected.size >= this.options.maxComponents)
        return "componentLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return super.endReason;
    }
    _handleMessageDeletion(message) {
      if (message.id === this.messageId) {
        this.stop("messageDelete");
      }
      if (message.interaction?.id === this.messageInteractionId) {
        this.stop("messageDelete");
      }
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.channelId || channel.threads?.cache.has(this.channelId)) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.channelId) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.guildId) {
        this.stop("guildDelete");
      }
    }
  }
  module.exports = InteractionCollector;
});

// node_modules/discord.js/src/structures/MessageCollector.js
var require_MessageCollector = __commonJS((exports, module) => {
  var Collector = require_Collector();
  var Events = require_Events();

  class MessageCollector extends Collector {
    constructor(channel, options = {}) {
      super(channel.client, options);
      this.channel = channel;
      this.received = 0;
      const bulkDeleteListener = (messages) => {
        for (const message of messages.values())
          this.handleDispose(message);
      };
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this.client.incrementMaxListeners();
      this.client.on(Events.MessageCreate, this.handleCollect);
      this.client.on(Events.MessageDelete, this.handleDispose);
      this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
      this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events.MessageCreate, this.handleCollect);
        this.client.removeListener(Events.MessageDelete, this.handleDispose);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
    }
    collect(message) {
      if (message.channelId !== this.channel.id)
        return null;
      this.received++;
      return message.id;
    }
    dispose(message) {
      return message.channelId === this.channel.id ? message.id : null;
    }
    get endReason() {
      if (this.options.max && this.collected.size >= this.options.max)
        return "limit";
      if (this.options.maxProcessed && this.received === this.options.maxProcessed)
        return "processedLimit";
      return super.endReason;
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.channel.id || channel.id === this.channel.parentId) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.channel.id) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.channel.guild?.id) {
        this.stop("guildDelete");
      }
    }
  }
  module.exports = MessageCollector;
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports, module) => {
  var isArray = Array.isArray;
  module.exports = isArray;
});

// node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports, module) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module.exports = freeGlobal;
});

// node_modules/lodash/_root.js
var require__root = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
});

// node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports, module) => {
  var root = require__root();
  var Symbol2 = root.Symbol;
  module.exports = Symbol2;
});

// node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports, module) => {
  var getRawTag = function(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  };
  var Symbol2 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module.exports = getRawTag;
});

// node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports, module) => {
  var objectToString = function(value) {
    return nativeObjectToString.call(value);
  };
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  module.exports = objectToString;
});

// node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports, module) => {
  var baseGetTag = function(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  };
  var Symbol2 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module.exports = baseGetTag;
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports, module) => {
  var isObjectLike = function(value) {
    return value != null && typeof value == "object";
  };
  module.exports = isObjectLike;
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS((exports, module) => {
  var isSymbol = function(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  };
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var symbolTag = "[object Symbol]";
  module.exports = isSymbol;
});

// node_modules/lodash/_isKey.js
var require__isKey = __commonJS((exports, module) => {
  var isKey = function(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  };
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  module.exports = isKey;
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports, module) => {
  var isObject = function(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  };
  module.exports = isObject;
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports, module) => {
  var isFunction = function(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  };
  var baseGetTag = require__baseGetTag();
  var isObject = require_isObject();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  module.exports = isFunction;
});

// node_modules/lodash/_coreJsData.js
var require__coreJsData = __commonJS((exports, module) => {
  var root = require__root();
  var coreJsData = root["__core-js_shared__"];
  module.exports = coreJsData;
});

// node_modules/lodash/_isMasked.js
var require__isMasked = __commonJS((exports, module) => {
  var isMasked = function(func) {
    return !!maskSrcKey && maskSrcKey in func;
  };
  var coreJsData = require__coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  module.exports = isMasked;
});

// node_modules/lodash/_toSource.js
var require__toSource = __commonJS((exports, module) => {
  var toSource = function(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  };
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  module.exports = toSource;
});

// node_modules/lodash/_baseIsNative.js
var require__baseIsNative = __commonJS((exports, module) => {
  var baseIsNative = function(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  };
  var isFunction = require_isFunction();
  var isMasked = require__isMasked();
  var isObject = require_isObject();
  var toSource = require__toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  module.exports = baseIsNative;
});

// node_modules/lodash/_getValue.js
var require__getValue = __commonJS((exports, module) => {
  var getValue = function(object, key) {
    return object == null ? undefined : object[key];
  };
  module.exports = getValue;
});

// node_modules/lodash/_getNative.js
var require__getNative = __commonJS((exports, module) => {
  var getNative = function(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  };
  var baseIsNative = require__baseIsNative();
  var getValue = require__getValue();
  module.exports = getNative;
});

// node_modules/lodash/_nativeCreate.js
var require__nativeCreate = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var nativeCreate = getNative(Object, "create");
  module.exports = nativeCreate;
});

// node_modules/lodash/_hashClear.js
var require__hashClear = __commonJS((exports, module) => {
  var hashClear = function() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  };
  var nativeCreate = require__nativeCreate();
  module.exports = hashClear;
});

// node_modules/lodash/_hashDelete.js
var require__hashDelete = __commonJS((exports, module) => {
  var hashDelete = function(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  };
  module.exports = hashDelete;
});

// node_modules/lodash/_hashGet.js
var require__hashGet = __commonJS((exports, module) => {
  var hashGet = function(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  };
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = hashGet;
});

// node_modules/lodash/_hashHas.js
var require__hashHas = __commonJS((exports, module) => {
  var hashHas = function(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  };
  var nativeCreate = require__nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = hashHas;
});

// node_modules/lodash/_hashSet.js
var require__hashSet = __commonJS((exports, module) => {
  var hashSet = function(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  };
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  module.exports = hashSet;
});

// node_modules/lodash/_Hash.js
var require__Hash = __commonJS((exports, module) => {
  var Hash = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var hashClear = require__hashClear();
  var hashDelete = require__hashDelete();
  var hashGet = require__hashGet();
  var hashHas = require__hashHas();
  var hashSet = require__hashSet();
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module.exports = Hash;
});

// node_modules/lodash/_listCacheClear.js
var require__listCacheClear = __commonJS((exports, module) => {
  var listCacheClear = function() {
    this.__data__ = [];
    this.size = 0;
  };
  module.exports = listCacheClear;
});

// node_modules/lodash/eq.js
var require_eq = __commonJS((exports, module) => {
  var eq = function(value, other) {
    return value === other || value !== value && other !== other;
  };
  module.exports = eq;
});

// node_modules/lodash/_assocIndexOf.js
var require__assocIndexOf = __commonJS((exports, module) => {
  var assocIndexOf = function(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  };
  var eq = require_eq();
  module.exports = assocIndexOf;
});

// node_modules/lodash/_listCacheDelete.js
var require__listCacheDelete = __commonJS((exports, module) => {
  var listCacheDelete = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  };
  var assocIndexOf = require__assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  module.exports = listCacheDelete;
});

// node_modules/lodash/_listCacheGet.js
var require__listCacheGet = __commonJS((exports, module) => {
  var listCacheGet = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheGet;
});

// node_modules/lodash/_listCacheHas.js
var require__listCacheHas = __commonJS((exports, module) => {
  var listCacheHas = function(key) {
    return assocIndexOf(this.__data__, key) > -1;
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheHas;
});

// node_modules/lodash/_listCacheSet.js
var require__listCacheSet = __commonJS((exports, module) => {
  var listCacheSet = function(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheSet;
});

// node_modules/lodash/_ListCache.js
var require__ListCache = __commonJS((exports, module) => {
  var ListCache = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var listCacheClear = require__listCacheClear();
  var listCacheDelete = require__listCacheDelete();
  var listCacheGet = require__listCacheGet();
  var listCacheHas = require__listCacheHas();
  var listCacheSet = require__listCacheSet();
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
});

// node_modules/lodash/_Map.js
var require__Map = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Map2 = getNative(root, "Map");
  module.exports = Map2;
});

// node_modules/lodash/_mapCacheClear.js
var require__mapCacheClear = __commonJS((exports, module) => {
  var mapCacheClear = function() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  };
  var Hash = require__Hash();
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  module.exports = mapCacheClear;
});

// node_modules/lodash/_isKeyable.js
var require__isKeyable = __commonJS((exports, module) => {
  var isKeyable = function(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  };
  module.exports = isKeyable;
});

// node_modules/lodash/_getMapData.js
var require__getMapData = __commonJS((exports, module) => {
  var getMapData = function(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  };
  var isKeyable = require__isKeyable();
  module.exports = getMapData;
});

// node_modules/lodash/_mapCacheDelete.js
var require__mapCacheDelete = __commonJS((exports, module) => {
  var mapCacheDelete = function(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheDelete;
});

// node_modules/lodash/_mapCacheGet.js
var require__mapCacheGet = __commonJS((exports, module) => {
  var mapCacheGet = function(key) {
    return getMapData(this, key).get(key);
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheGet;
});

// node_modules/lodash/_mapCacheHas.js
var require__mapCacheHas = __commonJS((exports, module) => {
  var mapCacheHas = function(key) {
    return getMapData(this, key).has(key);
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheHas;
});

// node_modules/lodash/_mapCacheSet.js
var require__mapCacheSet = __commonJS((exports, module) => {
  var mapCacheSet = function(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheSet;
});

// node_modules/lodash/_MapCache.js
var require__MapCache = __commonJS((exports, module) => {
  var MapCache = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var mapCacheClear = require__mapCacheClear();
  var mapCacheDelete = require__mapCacheDelete();
  var mapCacheGet = require__mapCacheGet();
  var mapCacheHas = require__mapCacheHas();
  var mapCacheSet = require__mapCacheSet();
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS((exports, module) => {
  var memoize = function(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  };
  var MapCache = require__MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  memoize.Cache = MapCache;
  module.exports = memoize;
});

// node_modules/lodash/_memoizeCapped.js
var require__memoizeCapped = __commonJS((exports, module) => {
  var memoizeCapped = function(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  };
  var memoize = require_memoize();
  var MAX_MEMOIZE_SIZE = 500;
  module.exports = memoizeCapped;
});

// node_modules/lodash/_stringToPath.js
var require__stringToPath = __commonJS((exports, module) => {
  var memoizeCapped = require__memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  module.exports = stringToPath;
});

// node_modules/lodash/_arrayMap.js
var require__arrayMap = __commonJS((exports, module) => {
  var arrayMap = function(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  };
  module.exports = arrayMap;
});

// node_modules/lodash/_baseToString.js
var require__baseToString = __commonJS((exports, module) => {
  var baseToString = function(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  };
  var Symbol2 = require__Symbol();
  var arrayMap = require__arrayMap();
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  module.exports = baseToString;
});

// node_modules/lodash/toString.js
var require_toString = __commonJS((exports, module) => {
  var toString = function(value) {
    return value == null ? "" : baseToString(value);
  };
  var baseToString = require__baseToString();
  module.exports = toString;
});

// node_modules/lodash/_castPath.js
var require__castPath = __commonJS((exports, module) => {
  var castPath = function(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  };
  var isArray = require_isArray();
  var isKey = require__isKey();
  var stringToPath = require__stringToPath();
  var toString = require_toString();
  module.exports = castPath;
});

// node_modules/lodash/_toKey.js
var require__toKey = __commonJS((exports, module) => {
  var toKey = function(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  };
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  module.exports = toKey;
});

// node_modules/lodash/_baseGet.js
var require__baseGet = __commonJS((exports, module) => {
  var baseGet = function(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
  };
  var castPath = require__castPath();
  var toKey = require__toKey();
  module.exports = baseGet;
});

// node_modules/lodash/get.js
var require_get = __commonJS((exports, module) => {
  var get = function(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  };
  var baseGet = require__baseGet();
  module.exports = get;
});

// node_modules/fast-deep-equal/es6/index.js
var require_es6 = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a instanceof Map && b instanceof Map) {
        if (a.size !== b.size)
          return false;
        for (i of a.entries())
          if (!b.has(i[0]))
            return false;
        for (i of a.entries())
          if (!equal(i[1], b.get(i[0])))
            return false;
        return true;
      }
      if (a instanceof Set && b instanceof Set) {
        if (a.size !== b.size)
          return false;
        for (i of a.entries())
          if (!b.has(i[0]))
            return false;
        return true;
      }
      if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (a[i] !== b[i])
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/lodash/_setCacheAdd.js
var require__setCacheAdd = __commonJS((exports, module) => {
  var setCacheAdd = function(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  };
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  module.exports = setCacheAdd;
});

// node_modules/lodash/_setCacheHas.js
var require__setCacheHas = __commonJS((exports, module) => {
  var setCacheHas = function(value) {
    return this.__data__.has(value);
  };
  module.exports = setCacheHas;
});

// node_modules/lodash/_SetCache.js
var require__SetCache = __commonJS((exports, module) => {
  var SetCache = function(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  };
  var MapCache = require__MapCache();
  var setCacheAdd = require__setCacheAdd();
  var setCacheHas = require__setCacheHas();
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module.exports = SetCache;
});

// node_modules/lodash/_baseFindIndex.js
var require__baseFindIndex = __commonJS((exports, module) => {
  var baseFindIndex = function(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  };
  module.exports = baseFindIndex;
});

// node_modules/lodash/_baseIsNaN.js
var require__baseIsNaN = __commonJS((exports, module) => {
  var baseIsNaN = function(value) {
    return value !== value;
  };
  module.exports = baseIsNaN;
});

// node_modules/lodash/_strictIndexOf.js
var require__strictIndexOf = __commonJS((exports, module) => {
  var strictIndexOf = function(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  };
  module.exports = strictIndexOf;
});

// node_modules/lodash/_baseIndexOf.js
var require__baseIndexOf = __commonJS((exports, module) => {
  var baseIndexOf = function(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  };
  var baseFindIndex = require__baseFindIndex();
  var baseIsNaN = require__baseIsNaN();
  var strictIndexOf = require__strictIndexOf();
  module.exports = baseIndexOf;
});

// node_modules/lodash/_arrayIncludes.js
var require__arrayIncludes = __commonJS((exports, module) => {
  var arrayIncludes = function(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  };
  var baseIndexOf = require__baseIndexOf();
  module.exports = arrayIncludes;
});

// node_modules/lodash/_arrayIncludesWith.js
var require__arrayIncludesWith = __commonJS((exports, module) => {
  var arrayIncludesWith = function(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  };
  module.exports = arrayIncludesWith;
});

// node_modules/lodash/_cacheHas.js
var require__cacheHas = __commonJS((exports, module) => {
  var cacheHas = function(cache, key) {
    return cache.has(key);
  };
  module.exports = cacheHas;
});

// node_modules/lodash/_Set.js
var require__Set = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Set2 = getNative(root, "Set");
  module.exports = Set2;
});

// node_modules/lodash/noop.js
var require_noop = __commonJS((exports, module) => {
  var noop = function() {
  };
  module.exports = noop;
});

// node_modules/lodash/_setToArray.js
var require__setToArray = __commonJS((exports, module) => {
  var setToArray = function(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  };
  module.exports = setToArray;
});

// node_modules/lodash/_createSet.js
var require__createSet = __commonJS((exports, module) => {
  var Set2 = require__Set();
  var noop = require_noop();
  var setToArray = require__setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  module.exports = createSet;
});

// node_modules/lodash/_baseUniq.js
var require__baseUniq = __commonJS((exports, module) => {
  var baseUniq = function(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache;
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  };
  var SetCache = require__SetCache();
  var arrayIncludes = require__arrayIncludes();
  var arrayIncludesWith = require__arrayIncludesWith();
  var cacheHas = require__cacheHas();
  var createSet = require__createSet();
  var setToArray = require__setToArray();
  var LARGE_ARRAY_SIZE = 200;
  module.exports = baseUniq;
});

// node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS((exports, module) => {
  var uniqWith = function(array, comparator) {
    comparator = typeof comparator == "function" ? comparator : undefined;
    return array && array.length ? baseUniq(array, undefined, comparator) : [];
  };
  var baseUniq = require__baseUniq();
  module.exports = uniqWith;
});

// node_modules/@sapphire/shapeshift/dist/cjs/index.cjs
var require_cjs2 = __commonJS((exports) => {
  var _interopDefault = function(e3) {
    return e3 && e3.__esModule ? e3 : { default: e3 };
  };
  var setGlobalValidationEnabled = function(enabled) {
    validationEnabled = enabled;
  };
  var getGlobalValidationEnabled = function() {
    return validationEnabled;
  };
  var getValue = function(valueOrFn) {
    return typeof valueOrFn === "function" ? valueOrFn() : valueOrFn;
  };
  var i = function() {
    throw new Error("setTimeout has not been defined");
  };
  var u = function() {
    throw new Error("clearTimeout has not been defined");
  };
  var c = function(e3) {
    if (t === setTimeout)
      return setTimeout(e3, 0);
    if ((t === i || !t) && setTimeout)
      return t = setTimeout, setTimeout(e3, 0);
    try {
      return t(e3, 0);
    } catch (n3) {
      try {
        return t.call(null, e3, 0);
      } catch (n4) {
        return t.call(this || r, e3, 0);
      }
    }
  };
  var h = function() {
    f && l && (f = false, l.length ? s = l.concat(s) : a = -1, s.length && d());
  };
  var d = function() {
    if (!f) {
      var e3 = c(h);
      f = true;
      for (var t3 = s.length;t3; ) {
        for (l = s, s = [];++a < t3; )
          l && l[a].run();
        a = -1, t3 = s.length;
      }
      l = null, f = false, function(e4) {
        if (n === clearTimeout)
          return clearTimeout(e4);
        if ((n === u || !n) && clearTimeout)
          return n = clearTimeout, clearTimeout(e4);
        try {
          n(e4);
        } catch (t4) {
          try {
            return n.call(null, e4);
          } catch (t5) {
            return n.call(this || r, e4);
          }
        }
      }(e3);
    }
  };
  var m = function(e3, t3) {
    (this || r).fun = e3, (this || r).array = t3;
  };
  var p = function() {
  };
  var c$1 = function(e3) {
    return e3.call.bind(e3);
  };
  var O = function(e3, t3) {
    if (typeof e3 != "object")
      return false;
    try {
      return t3(e3), true;
    } catch (e4) {
      return false;
    }
  };
  var S = function(e3) {
    return l$1 && y ? b(e3) !== undefined : B(e3) || k(e3) || E(e3) || D(e3) || U(e3) || P(e3) || x(e3) || I(e3) || M(e3) || z(e3) || F(e3);
  };
  var B = function(e3) {
    return l$1 && y ? b(e3) === "Uint8Array" : m2(e3) === "[object Uint8Array]" || u$1(e3) && e3.buffer !== undefined;
  };
  var k = function(e3) {
    return l$1 && y ? b(e3) === "Uint8ClampedArray" : m2(e3) === "[object Uint8ClampedArray]";
  };
  var E = function(e3) {
    return l$1 && y ? b(e3) === "Uint16Array" : m2(e3) === "[object Uint16Array]";
  };
  var D = function(e3) {
    return l$1 && y ? b(e3) === "Uint32Array" : m2(e3) === "[object Uint32Array]";
  };
  var U = function(e3) {
    return l$1 && y ? b(e3) === "Int8Array" : m2(e3) === "[object Int8Array]";
  };
  var P = function(e3) {
    return l$1 && y ? b(e3) === "Int16Array" : m2(e3) === "[object Int16Array]";
  };
  var x = function(e3) {
    return l$1 && y ? b(e3) === "Int32Array" : m2(e3) === "[object Int32Array]";
  };
  var I = function(e3) {
    return l$1 && y ? b(e3) === "Float32Array" : m2(e3) === "[object Float32Array]";
  };
  var M = function(e3) {
    return l$1 && y ? b(e3) === "Float64Array" : m2(e3) === "[object Float64Array]";
  };
  var z = function(e3) {
    return l$1 && y ? b(e3) === "BigInt64Array" : m2(e3) === "[object BigInt64Array]";
  };
  var F = function(e3) {
    return l$1 && y ? b(e3) === "BigUint64Array" : m2(e3) === "[object BigUint64Array]";
  };
  var T2 = function(e3) {
    return m2(e3) === "[object Map]";
  };
  var N = function(e3) {
    return m2(e3) === "[object Set]";
  };
  var W = function(e3) {
    return m2(e3) === "[object WeakMap]";
  };
  var $ = function(e3) {
    return m2(e3) === "[object WeakSet]";
  };
  var C = function(e3) {
    return m2(e3) === "[object ArrayBuffer]";
  };
  var V = function(e3) {
    return typeof ArrayBuffer != "undefined" && (C.working ? C(e3) : e3 instanceof ArrayBuffer);
  };
  var G = function(e3) {
    return m2(e3) === "[object DataView]";
  };
  var R = function(e3) {
    return typeof DataView != "undefined" && (G.working ? G(e3) : e3 instanceof DataView);
  };
  var J = function(e3) {
    return m2(e3) === "[object SharedArrayBuffer]";
  };
  var _ = function(e3) {
    return typeof SharedArrayBuffer != "undefined" && (J.working ? J(e3) : e3 instanceof SharedArrayBuffer);
  };
  var H = function(e3) {
    return O(e3, h2);
  };
  var Z = function(e3) {
    return O(e3, j);
  };
  var q = function(e3) {
    return O(e3, A);
  };
  var K = function(e3) {
    return s2 && O(e3, w);
  };
  var L = function(e3) {
    return p2 && O(e3, v);
  };
  var oe = function(e3, t3) {
    var r3 = { seen: [], stylize: fe };
    return arguments.length >= 3 && (r3.depth = arguments[2]), arguments.length >= 4 && (r3.colors = arguments[3]), ye(t3) ? r3.showHidden = t3 : t3 && X._extend(r3, t3), be(r3.showHidden) && (r3.showHidden = false), be(r3.depth) && (r3.depth = 2), be(r3.colors) && (r3.colors = false), be(r3.customInspect) && (r3.customInspect = true), r3.colors && (r3.stylize = ue), ae(r3, e3, r3.depth);
  };
  var ue = function(e3, t3) {
    var r3 = oe.styles[t3];
    return r3 ? "\x1B[" + oe.colors[r3][0] + "m" + e3 + "\x1B[" + oe.colors[r3][1] + "m" : e3;
  };
  var fe = function(e3, t3) {
    return e3;
  };
  var ae = function(e3, t3, r3) {
    if (e3.customInspect && t3 && we(t3.inspect) && t3.inspect !== X.inspect && (!t3.constructor || t3.constructor.prototype !== t3)) {
      var n3 = t3.inspect(r3, e3);
      return ge(n3) || (n3 = ae(e3, n3, r3)), n3;
    }
    var i3 = function(e4, t4) {
      if (be(t4))
        return e4.stylize("undefined", "undefined");
      if (ge(t4)) {
        var r4 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e4.stylize(r4, "string");
      }
      if (de(t4))
        return e4.stylize("" + t4, "number");
      if (ye(t4))
        return e4.stylize("" + t4, "boolean");
      if (le(t4))
        return e4.stylize("null", "null");
    }(e3, t3);
    if (i3)
      return i3;
    var o3 = Object.keys(t3), u3 = function(e4) {
      var t4 = {};
      return e4.forEach(function(e5, r4) {
        t4[e5] = true;
      }), t4;
    }(o3);
    if (e3.showHidden && (o3 = Object.getOwnPropertyNames(t3)), Ae(t3) && (o3.indexOf("message") >= 0 || o3.indexOf("description") >= 0))
      return ce(t3);
    if (o3.length === 0) {
      if (we(t3)) {
        var f3 = t3.name ? ": " + t3.name : "";
        return e3.stylize("[Function" + f3 + "]", "special");
      }
      if (me(t3))
        return e3.stylize(RegExp.prototype.toString.call(t3), "regexp");
      if (je(t3))
        return e3.stylize(Date.prototype.toString.call(t3), "date");
      if (Ae(t3))
        return ce(t3);
    }
    var a3, c3 = "", s4 = false, p3 = ["{", "}"];
    (pe(t3) && (s4 = true, p3 = ["[", "]"]), we(t3)) && (c3 = " [Function" + (t3.name ? ": " + t3.name : "") + "]");
    return me(t3) && (c3 = " " + RegExp.prototype.toString.call(t3)), je(t3) && (c3 = " " + Date.prototype.toUTCString.call(t3)), Ae(t3) && (c3 = " " + ce(t3)), o3.length !== 0 || s4 && t3.length != 0 ? r3 < 0 ? me(t3) ? e3.stylize(RegExp.prototype.toString.call(t3), "regexp") : e3.stylize("[Object]", "special") : (e3.seen.push(t3), a3 = s4 ? function(e4, t4, r4, n4, i4) {
      for (var o4 = [], u4 = 0, f4 = t4.length;u4 < f4; ++u4)
        ke(t4, String(u4)) ? o4.push(se(e4, t4, r4, n4, String(u4), true)) : o4.push("");
      return i4.forEach(function(i5) {
        i5.match(/^\d+$/) || o4.push(se(e4, t4, r4, n4, i5, true));
      }), o4;
    }(e3, t3, r3, u3, o3) : o3.map(function(n4) {
      return se(e3, t3, r3, u3, n4, s4);
    }), e3.seen.pop(), function(e4, t4, r4) {
      var n4 = 0;
      if (e4.reduce(function(e5, t5) {
        return n4++, t5.indexOf("\n") >= 0 && n4++, e5 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60)
        return r4[0] + (t4 === "" ? "" : t4 + "\n ") + " " + e4.join(",\n  ") + " " + r4[1];
      return r4[0] + t4 + " " + e4.join(", ") + " " + r4[1];
    }(a3, c3, p3)) : p3[0] + c3 + p3[1];
  };
  var ce = function(e3) {
    return "[" + Error.prototype.toString.call(e3) + "]";
  };
  var se = function(e3, t3, r3, n3, i3, o3) {
    var u3, f3, a3;
    if ((a3 = Object.getOwnPropertyDescriptor(t3, i3) || { value: t3[i3] }).get ? f3 = a3.set ? e3.stylize("[Getter/Setter]", "special") : e3.stylize("[Getter]", "special") : a3.set && (f3 = e3.stylize("[Setter]", "special")), ke(n3, i3) || (u3 = "[" + i3 + "]"), f3 || (e3.seen.indexOf(a3.value) < 0 ? (f3 = le(r3) ? ae(e3, a3.value, null) : ae(e3, a3.value, r3 - 1)).indexOf("\n") > -1 && (f3 = o3 ? f3.split("\n").map(function(e4) {
      return "  " + e4;
    }).join("\n").substr(2) : "\n" + f3.split("\n").map(function(e4) {
      return "   " + e4;
    }).join("\n")) : f3 = e3.stylize("[Circular]", "special")), be(u3)) {
      if (o3 && i3.match(/^\d+$/))
        return f3;
      (u3 = JSON.stringify("" + i3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u3 = u3.substr(1, u3.length - 2), u3 = e3.stylize(u3, "name")) : (u3 = u3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u3 = e3.stylize(u3, "string"));
    }
    return u3 + ": " + f3;
  };
  var pe = function(e3) {
    return Array.isArray(e3);
  };
  var ye = function(e3) {
    return typeof e3 == "boolean";
  };
  var le = function(e3) {
    return e3 === null;
  };
  var de = function(e3) {
    return typeof e3 == "number";
  };
  var ge = function(e3) {
    return typeof e3 == "string";
  };
  var be = function(e3) {
    return e3 === undefined;
  };
  var me = function(e3) {
    return he(e3) && ve(e3) === "[object RegExp]";
  };
  var he = function(e3) {
    return typeof e3 == "object" && e3 !== null;
  };
  var je = function(e3) {
    return he(e3) && ve(e3) === "[object Date]";
  };
  var Ae = function(e3) {
    return he(e3) && (ve(e3) === "[object Error]" || e3 instanceof Error);
  };
  var we = function(e3) {
    return typeof e3 == "function";
  };
  var ve = function(e3) {
    return Object.prototype.toString.call(e3);
  };
  var Oe = function(e3) {
    return e3 < 10 ? "0" + e3.toString(10) : e3.toString(10);
  };
  var Be = function() {
    var e3 = new Date, t3 = [Oe(e3.getHours()), Oe(e3.getMinutes()), Oe(e3.getSeconds())].join(":");
    return [e3.getDate(), Se[e3.getMonth()], t3].join(" ");
  };
  var ke = function(e3, t3) {
    return Object.prototype.hasOwnProperty.call(e3, t3);
  };
  var De = function(e3, t3) {
    if (!e3) {
      var r3 = new Error("Promise was rejected with a falsy value");
      r3.reason = e3, e3 = r3;
    }
    return t3(e3);
  };
  var whenConstraint = function(key, options, validator) {
    return {
      run(input, parent) {
        if (!parent) {
          return Result.err(new ExpectedConstraintError("s.object(T.when)", "Validator has no parent", parent, "Validator to have a parent"));
        }
        const isKeyArray = Array.isArray(key);
        const value = isKeyArray ? key.map((k2) => get__default.default(parent, k2)) : get__default.default(parent, key);
        const predicate = resolveBooleanIs(options, value, isKeyArray) ? options.then : options.otherwise;
        if (predicate) {
          return predicate(validator).run(input);
        }
        return Result.ok(input);
      }
    };
  };
  var resolveBooleanIs = function(options, value, isKeyArray) {
    if (options.is === undefined) {
      return isKeyArray ? !value.some((val) => !val) : Boolean(value);
    }
    if (typeof options.is === "function") {
      return options.is(value);
    }
    return value === options.is;
  };
  var isUnique = function(input) {
    if (input.length < 2)
      return true;
    const uniqueArray2 = uniqWith__default.default(input, fastDeepEqual__default.default);
    return uniqueArray2.length === input.length;
  };
  var lessThan = function(a3, b2) {
    return a3 < b2;
  };
  var lessThanOrEqual = function(a3, b2) {
    return a3 <= b2;
  };
  var greaterThan = function(a3, b2) {
    return a3 > b2;
  };
  var greaterThanOrEqual = function(a3, b2) {
    return a3 >= b2;
  };
  var equal = function(a3, b2) {
    return a3 === b2;
  };
  var notEqual = function(a3, b2) {
    return a3 !== b2;
  };
  var arrayLengthComparator = function(comparator, name, expected, length) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Array length", input, expected));
      }
    };
  };
  var arrayLengthLessThan = function(value) {
    const expected = `expected.length < ${value}`;
    return arrayLengthComparator(lessThan, "s.array(T).lengthLessThan", expected, value);
  };
  var arrayLengthLessThanOrEqual = function(value) {
    const expected = `expected.length <= ${value}`;
    return arrayLengthComparator(lessThanOrEqual, "s.array(T).lengthLessThanOrEqual", expected, value);
  };
  var arrayLengthGreaterThan = function(value) {
    const expected = `expected.length > ${value}`;
    return arrayLengthComparator(greaterThan, "s.array(T).lengthGreaterThan", expected, value);
  };
  var arrayLengthGreaterThanOrEqual = function(value) {
    const expected = `expected.length >= ${value}`;
    return arrayLengthComparator(greaterThanOrEqual, "s.array(T).lengthGreaterThanOrEqual", expected, value);
  };
  var arrayLengthEqual = function(value) {
    const expected = `expected.length === ${value}`;
    return arrayLengthComparator(equal, "s.array(T).lengthEqual", expected, value);
  };
  var arrayLengthNotEqual = function(value) {
    const expected = `expected.length !== ${value}`;
    return arrayLengthComparator(notEqual, "s.array(T).lengthNotEqual", expected, value);
  };
  var arrayLengthRange = function(start, endBefore) {
    const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRange", "Invalid Array length", input, expected));
      }
    };
  };
  var arrayLengthRangeInclusive = function(start, end) {
    const expected = `expected.length >= ${start} && expected.length <= ${end}`;
    return {
      run(input) {
        return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeInclusive", "Invalid Array length", input, expected));
      }
    };
  };
  var arrayLengthRangeExclusive = function(startAfter, endBefore) {
    const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeExclusive", "Invalid Array length", input, expected));
      }
    };
  };
  var bigintComparator = function(comparator, name, expected, number) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid bigint value", input, expected));
      }
    };
  };
  var bigintLessThan = function(value) {
    const expected = `expected < ${value}n`;
    return bigintComparator(lessThan, "s.bigint.lessThan", expected, value);
  };
  var bigintLessThanOrEqual = function(value) {
    const expected = `expected <= ${value}n`;
    return bigintComparator(lessThanOrEqual, "s.bigint.lessThanOrEqual", expected, value);
  };
  var bigintGreaterThan = function(value) {
    const expected = `expected > ${value}n`;
    return bigintComparator(greaterThan, "s.bigint.greaterThan", expected, value);
  };
  var bigintGreaterThanOrEqual = function(value) {
    const expected = `expected >= ${value}n`;
    return bigintComparator(greaterThanOrEqual, "s.bigint.greaterThanOrEqual", expected, value);
  };
  var bigintEqual = function(value) {
    const expected = `expected === ${value}n`;
    return bigintComparator(equal, "s.bigint.equal", expected, value);
  };
  var bigintNotEqual = function(value) {
    const expected = `expected !== ${value}n`;
    return bigintComparator(notEqual, "s.bigint.notEqual", expected, value);
  };
  var bigintDivisibleBy = function(divider) {
    const expected = `expected % ${divider}n === 0n`;
    return {
      run(input) {
        return input % divider === 0n ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.bigint.divisibleBy", "BigInt is not divisible", input, expected));
      }
    };
  };
  var dateComparator = function(comparator, name, expected, number) {
    return {
      run(input) {
        return comparator(input.getTime(), number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Date value", input, expected));
      }
    };
  };
  var dateLessThan = function(value) {
    const expected = `expected < ${value.toISOString()}`;
    return dateComparator(lessThan, "s.date.lessThan", expected, value.getTime());
  };
  var dateLessThanOrEqual = function(value) {
    const expected = `expected <= ${value.toISOString()}`;
    return dateComparator(lessThanOrEqual, "s.date.lessThanOrEqual", expected, value.getTime());
  };
  var dateGreaterThan = function(value) {
    const expected = `expected > ${value.toISOString()}`;
    return dateComparator(greaterThan, "s.date.greaterThan", expected, value.getTime());
  };
  var dateGreaterThanOrEqual = function(value) {
    const expected = `expected >= ${value.toISOString()}`;
    return dateComparator(greaterThanOrEqual, "s.date.greaterThanOrEqual", expected, value.getTime());
  };
  var dateEqual = function(value) {
    const expected = `expected === ${value.toISOString()}`;
    return dateComparator(equal, "s.date.equal", expected, value.getTime());
  };
  var dateNotEqual = function(value) {
    const expected = `expected !== ${value.toISOString()}`;
    return dateComparator(notEqual, "s.date.notEqual", expected, value.getTime());
  };
  var numberComparator = function(comparator, name, expected, number) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid number value", input, expected));
      }
    };
  };
  var numberLessThan = function(value) {
    const expected = `expected < ${value}`;
    return numberComparator(lessThan, "s.number.lessThan", expected, value);
  };
  var numberLessThanOrEqual = function(value) {
    const expected = `expected <= ${value}`;
    return numberComparator(lessThanOrEqual, "s.number.lessThanOrEqual", expected, value);
  };
  var numberGreaterThan = function(value) {
    const expected = `expected > ${value}`;
    return numberComparator(greaterThan, "s.number.greaterThan", expected, value);
  };
  var numberGreaterThanOrEqual = function(value) {
    const expected = `expected >= ${value}`;
    return numberComparator(greaterThanOrEqual, "s.number.greaterThanOrEqual", expected, value);
  };
  var numberEqual = function(value) {
    const expected = `expected === ${value}`;
    return numberComparator(equal, "s.number.equal", expected, value);
  };
  var numberNotEqual = function(value) {
    const expected = `expected !== ${value}`;
    return numberComparator(notEqual, "s.number.notEqual", expected, value);
  };
  var numberDivisibleBy = function(divider) {
    const expected = `expected % ${divider} === 0`;
    return {
      run(input) {
        return input % divider === 0 ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.divisibleBy", "Number is not divisible", input, expected));
      }
    };
  };
  var validateEmail = function(email) {
    if (!email)
      return false;
    const atIndex = email.indexOf("@");
    if (atIndex === -1)
      return false;
    if (atIndex > 64)
      return false;
    const domainIndex = atIndex + 1;
    if (email.includes("@", domainIndex))
      return false;
    if (email.length - domainIndex > 255)
      return false;
    let dotIndex = email.indexOf(".", domainIndex);
    if (dotIndex === -1)
      return false;
    let lastDotIndex = domainIndex;
    do {
      if (dotIndex - lastDotIndex > 63)
        return false;
      lastDotIndex = dotIndex + 1;
    } while ((dotIndex = email.indexOf(".", lastDotIndex)) !== -1);
    if (email.length - lastDotIndex > 63)
      return false;
    return accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));
  };
  var validateEmailDomain = function(domain) {
    try {
      return new URL(`http://${domain}`).hostname === domain;
    } catch {
      return false;
    }
  };
  var isIPv4 = function(s4) {
    return IPv4Reg.test(s4);
  };
  var isIPv6 = function(s4) {
    return IPv6Reg.test(s4);
  };
  var isIP = function(s4) {
    if (isIPv4(s4))
      return 4;
    if (isIPv6(s4))
      return 6;
    return 0;
  };
  var validatePhoneNumber = function(input) {
    return phoneNumberRegex.test(input);
  };
  var combinedErrorFn = function(...fns) {
    switch (fns.length) {
      case 0:
        return () => null;
      case 1:
        return fns[0];
      case 2: {
        const [fn0, fn1] = fns;
        return (...params) => fn0(...params) || fn1(...params);
      }
      default: {
        return (...params) => {
          for (const fn of fns) {
            const result = fn(...params);
            if (result)
              return result;
          }
          return null;
        };
      }
    }
  };
  var createUrlValidators = function(options) {
    const fns = [];
    if (options?.allowedProtocols?.length)
      fns.push(allowedProtocolsFn(options.allowedProtocols));
    if (options?.allowedDomains?.length)
      fns.push(allowedDomainsFn(options.allowedDomains));
    return combinedErrorFn(...fns);
  };
  var allowedProtocolsFn = function(allowedProtocols) {
    return (input, url) => allowedProtocols.includes(url.protocol) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL protocol", input, allowedProtocols);
  };
  var allowedDomainsFn = function(allowedDomains) {
    return (input, url) => allowedDomains.includes(url.hostname) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL domain", input, allowedDomains);
  };
  var stringLengthComparator = function(comparator, name, expected, length) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid string length", input, expected));
      }
    };
  };
  var stringLengthLessThan = function(length) {
    const expected = `expected.length < ${length}`;
    return stringLengthComparator(lessThan, "s.string.lengthLessThan", expected, length);
  };
  var stringLengthLessThanOrEqual = function(length) {
    const expected = `expected.length <= ${length}`;
    return stringLengthComparator(lessThanOrEqual, "s.string.lengthLessThanOrEqual", expected, length);
  };
  var stringLengthGreaterThan = function(length) {
    const expected = `expected.length > ${length}`;
    return stringLengthComparator(greaterThan, "s.string.lengthGreaterThan", expected, length);
  };
  var stringLengthGreaterThanOrEqual = function(length) {
    const expected = `expected.length >= ${length}`;
    return stringLengthComparator(greaterThanOrEqual, "s.string.lengthGreaterThanOrEqual", expected, length);
  };
  var stringLengthEqual = function(length) {
    const expected = `expected.length === ${length}`;
    return stringLengthComparator(equal, "s.string.lengthEqual", expected, length);
  };
  var stringLengthNotEqual = function(length) {
    const expected = `expected.length !== ${length}`;
    return stringLengthComparator(notEqual, "s.string.lengthNotEqual", expected, length);
  };
  var stringEmail = function() {
    return {
      run(input) {
        return validateEmail(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.email", "Invalid email address", input, "expected to be an email address"));
      }
    };
  };
  var stringRegexValidator = function(type, expected, regex) {
    return {
      run(input) {
        return regex.test(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(type, "Invalid string format", input, expected));
      }
    };
  };
  var stringUrl = function(options) {
    const validatorFn = createUrlValidators(options);
    return {
      run(input) {
        let url;
        try {
          url = new URL(input);
        } catch {
          return Result.err(new ExpectedConstraintError("s.string.url", "Invalid URL", input, "expected to match a URL"));
        }
        const validatorFnResult = validatorFn(input, url);
        if (validatorFnResult === null)
          return Result.ok(input);
        return Result.err(validatorFnResult);
      }
    };
  };
  var stringIp = function(version) {
    const ipVersion = version ? `v${version}` : "";
    const validatorFn = version === 4 ? isIPv4 : version === 6 ? isIPv6 : isIP;
    const name = `s.string.ip${ipVersion}`;
    const message = `Invalid IP${ipVersion} address`;
    const expected = `expected to be an IP${ipVersion} address`;
    return {
      run(input) {
        return validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, message, input, expected));
      }
    };
  };
  var stringRegex = function(regex) {
    return stringRegexValidator("s.string.regex", `expected ${regex}.test(expected) to be true`, regex);
  };
  var stringUuid = function({ version = 4, nullable = false } = {}) {
    version ?? (version = "1-5");
    const regex = new RegExp(`^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${nullable ? "|00000000-0000-0000-0000-000000000000" : ""})\$`, "i");
    const expected = `expected to match UUID${typeof version === "number" ? `v${version}` : ` in range of ${version}`}`;
    return stringRegexValidator("s.string.uuid", expected, regex);
  };
  var stringDate = function() {
    return {
      run(input) {
        const time = Date.parse(input);
        return Number.isNaN(time) ? Result.err(new ExpectedConstraintError("s.string.date", "Invalid date string", input, "expected to be a valid date string (in the ISO 8601 or ECMA-262 format)")) : Result.ok(input);
      }
    };
  };
  var stringPhone = function() {
    return {
      run(input) {
        return validatePhoneNumber(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.phone", "Invalid phone number", input, "expected to be a phone number"));
      }
    };
  };
  var typedArrayByteLengthComparator = function(comparator, name, expected, length) {
    return {
      run(input) {
        return comparator(input.byteLength, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayByteLengthLessThan = function(value) {
    const expected = `expected.byteLength < ${value}`;
    return typedArrayByteLengthComparator(lessThan, "s.typedArray(T).byteLengthLessThan", expected, value);
  };
  var typedArrayByteLengthLessThanOrEqual = function(value) {
    const expected = `expected.byteLength <= ${value}`;
    return typedArrayByteLengthComparator(lessThanOrEqual, "s.typedArray(T).byteLengthLessThanOrEqual", expected, value);
  };
  var typedArrayByteLengthGreaterThan = function(value) {
    const expected = `expected.byteLength > ${value}`;
    return typedArrayByteLengthComparator(greaterThan, "s.typedArray(T).byteLengthGreaterThan", expected, value);
  };
  var typedArrayByteLengthGreaterThanOrEqual = function(value) {
    const expected = `expected.byteLength >= ${value}`;
    return typedArrayByteLengthComparator(greaterThanOrEqual, "s.typedArray(T).byteLengthGreaterThanOrEqual", expected, value);
  };
  var typedArrayByteLengthEqual = function(value) {
    const expected = `expected.byteLength === ${value}`;
    return typedArrayByteLengthComparator(equal, "s.typedArray(T).byteLengthEqual", expected, value);
  };
  var typedArrayByteLengthNotEqual = function(value) {
    const expected = `expected.byteLength !== ${value}`;
    return typedArrayByteLengthComparator(notEqual, "s.typedArray(T).byteLengthNotEqual", expected, value);
  };
  var typedArrayByteLengthRange = function(start, endBefore) {
    const expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;
    return {
      run(input) {
        return input.byteLength >= start && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRange", "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayByteLengthRangeInclusive = function(start, end) {
    const expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;
    return {
      run(input) {
        return input.byteLength >= start && input.byteLength <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRangeInclusive", "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayByteLengthRangeExclusive = function(startAfter, endBefore) {
    const expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;
    return {
      run(input) {
        return input.byteLength > startAfter && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRangeExclusive", "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayLengthComparator = function(comparator, name, expected, length) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array length", input, expected));
      }
    };
  };
  var typedArrayLengthLessThan = function(value) {
    const expected = `expected.length < ${value}`;
    return typedArrayLengthComparator(lessThan, "s.typedArray(T).lengthLessThan", expected, value);
  };
  var typedArrayLengthLessThanOrEqual = function(value) {
    const expected = `expected.length <= ${value}`;
    return typedArrayLengthComparator(lessThanOrEqual, "s.typedArray(T).lengthLessThanOrEqual", expected, value);
  };
  var typedArrayLengthGreaterThan = function(value) {
    const expected = `expected.length > ${value}`;
    return typedArrayLengthComparator(greaterThan, "s.typedArray(T).lengthGreaterThan", expected, value);
  };
  var typedArrayLengthGreaterThanOrEqual = function(value) {
    const expected = `expected.length >= ${value}`;
    return typedArrayLengthComparator(greaterThanOrEqual, "s.typedArray(T).lengthGreaterThanOrEqual", expected, value);
  };
  var typedArrayLengthEqual = function(value) {
    const expected = `expected.length === ${value}`;
    return typedArrayLengthComparator(equal, "s.typedArray(T).lengthEqual", expected, value);
  };
  var typedArrayLengthNotEqual = function(value) {
    const expected = `expected.length !== ${value}`;
    return typedArrayLengthComparator(notEqual, "s.typedArray(T).lengthNotEqual", expected, value);
  };
  var typedArrayLengthRange = function(start, endBefore) {
    const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRange", "Invalid Typed Array length", input, expected));
      }
    };
  };
  var typedArrayLengthRangeInclusive = function(start, end) {
    const expected = `expected.length >= ${start} && expected.length <= ${end}`;
    return {
      run(input) {
        return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeInclusive", "Invalid Typed Array length", input, expected));
      }
    };
  };
  var typedArrayLengthRangeExclusive = function(startAfter, endBefore) {
    const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeExclusive", "Invalid Typed Array length", input, expected));
      }
    };
  };
  var get = require_get();
  var fastDeepEqual = require_es6();
  var uniqWith = require_uniqWith();
  var get__default = _interopDefault(get);
  var fastDeepEqual__default = _interopDefault(fastDeepEqual);
  var uniqWith__default = _interopDefault(uniqWith);
  var __defProp2 = Object.defineProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var validationEnabled = true;
  __name(setGlobalValidationEnabled, "setGlobalValidationEnabled");
  __name(getGlobalValidationEnabled, "getGlobalValidationEnabled");
  var _Result = class _Result2 {
    constructor(success, value, error) {
      this.success = success;
      if (success) {
        this.value = value;
      } else {
        this.error = error;
      }
    }
    isOk() {
      return this.success;
    }
    isErr() {
      return !this.success;
    }
    unwrap() {
      if (this.isOk())
        return this.value;
      throw this.error;
    }
    static ok(value) {
      return new _Result2(true, value);
    }
    static err(error) {
      return new _Result2(false, undefined, error);
    }
  };
  __name(_Result, "Result");
  var Result = _Result;
  __name(getValue, "getValue");
  var e;
  var t;
  var n;
  var r = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : globalThis;
  var o = e = {};
  __name(i, "i");
  __name(u, "u");
  __name(c, "c");
  (function() {
    try {
      t = typeof setTimeout == "function" ? setTimeout : i;
    } catch (e3) {
      t = i;
    }
    try {
      n = typeof clearTimeout == "function" ? clearTimeout : u;
    } catch (e3) {
      n = u;
    }
  })();
  var l;
  var s = [];
  var f = false;
  var a = -1;
  __name(h, "h");
  __name(d, "d");
  __name(m, "m");
  __name(p, "p");
  o.nextTick = function(e3) {
    var t3 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var n3 = 1;n3 < arguments.length; n3++)
        t3[n3 - 1] = arguments[n3];
    s.push(new m(e3, t3)), s.length !== 1 || f || c(d);
  }, m.prototype.run = function() {
    (this || r).fun.apply(null, (this || r).array);
  }, o.title = "browser", o.browser = true, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = p, o.addListener = p, o.once = p, o.off = p, o.removeListener = p, o.removeAllListeners = p, o.emit = p, o.prependListener = p, o.prependOnceListener = p, o.listeners = function(e3) {
    return [];
  }, o.binding = function(e3) {
    throw new Error("process.binding is not supported");
  }, o.cwd = function() {
    return "/";
  }, o.chdir = function(e3) {
    throw new Error("process.chdir is not supported");
  }, o.umask = function() {
    return 0;
  };
  var T = e;
  T.addListener;
  T.argv;
  T.binding;
  T.browser;
  T.chdir;
  T.cwd;
  T.emit;
  T.env;
  T.listeners;
  T.nextTick;
  T.off;
  T.on;
  T.once;
  T.prependListener;
  T.prependOnceListener;
  T.removeAllListeners;
  T.removeListener;
  T.title;
  T.umask;
  T.version;
  T.versions;
  var t2 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
  var e2 = Object.prototype.toString;
  var o2 = __name(function(o3) {
    return !(t2 && o3 && typeof o3 == "object" && (Symbol.toStringTag in o3)) && e2.call(o3) === "[object Arguments]";
  }, "o");
  var n2 = __name(function(t3) {
    return !!o2(t3) || t3 !== null && typeof t3 == "object" && typeof t3.length == "number" && t3.length >= 0 && e2.call(t3) !== "[object Array]" && e2.call(t3.callee) === "[object Function]";
  }, "n");
  var r2 = function() {
    return o2(arguments);
  }();
  o2.isLegacyArguments = n2;
  var l2 = r2 ? o2 : n2;
  var t$1 = Object.prototype.toString;
  var o$1 = Function.prototype.toString;
  var n$1 = /^\s*(?:function)?\*/;
  var e$1 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
  var r$1 = Object.getPrototypeOf;
  var c2 = function() {
    if (!e$1)
      return false;
    try {
      return Function("return function*() {}")();
    } catch (t3) {
    }
  }();
  var u2 = c2 ? r$1(c2) : {};
  var i2 = __name(function(c3) {
    return typeof c3 == "function" && (!!n$1.test(o$1.call(c3)) || (e$1 ? r$1(c3) === u2 : t$1.call(c3) === "[object GeneratorFunction]"));
  }, "i");
  var t$2 = typeof Object.create == "function" ? function(t3, e3) {
    e3 && (t3.super_ = e3, t3.prototype = Object.create(e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }));
  } : function(t3, e3) {
    if (e3) {
      t3.super_ = e3;
      var o3 = __name(function() {
      }, "o");
      o3.prototype = e3.prototype, t3.prototype = new o3, t3.prototype.constructor = t3;
    }
  };
  var i$1 = __name(function(e3) {
    return e3 && typeof e3 == "object" && typeof e3.copy == "function" && typeof e3.fill == "function" && typeof e3.readUInt8 == "function";
  }, "i$1");
  var o$2 = {};
  var u$1 = i$1;
  var f2 = l2;
  var a2 = i2;
  __name(c$1, "c$1");
  var s2 = typeof BigInt != "undefined";
  var p2 = typeof Symbol != "undefined";
  var y = p2 && Symbol.toStringTag !== undefined;
  var l$1 = typeof Uint8Array != "undefined";
  var d2 = typeof ArrayBuffer != "undefined";
  if (l$1 && y)
    var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
  var m2 = c$1(Object.prototype.toString);
  var h2 = c$1(Number.prototype.valueOf);
  var j = c$1(String.prototype.valueOf);
  var A = c$1(Boolean.prototype.valueOf);
  if (s2)
    var w = c$1(BigInt.prototype.valueOf);
  if (p2)
    var v = c$1(Symbol.prototype.valueOf);
  __name(O, "O");
  __name(S, "S");
  __name(B, "B");
  __name(k, "k");
  __name(E, "E");
  __name(D, "D");
  __name(U, "U");
  __name(P, "P");
  __name(x, "x");
  __name(I, "I");
  __name(M, "M");
  __name(z, "z");
  __name(F, "F");
  __name(T2, "T");
  __name(N, "N");
  __name(W, "W");
  __name($, "$");
  __name(C, "C");
  __name(V, "V");
  __name(G, "G");
  __name(R, "R");
  __name(J, "J");
  __name(_, "_");
  __name(H, "H");
  __name(Z, "Z");
  __name(q, "q");
  __name(K, "K");
  __name(L, "L");
  o$2.isArgumentsObject = f2, o$2.isGeneratorFunction = a2, o$2.isPromise = function(e3) {
    return typeof Promise != "undefined" && e3 instanceof Promise || e3 !== null && typeof e3 == "object" && typeof e3.then == "function" && typeof e3.catch == "function";
  }, o$2.isArrayBufferView = function(e3) {
    return d2 && ArrayBuffer.isView ? ArrayBuffer.isView(e3) : S(e3) || R(e3);
  }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T2.working = typeof Map != "undefined" && T2(new Map), o$2.isMap = function(e3) {
    return typeof Map != "undefined" && (T2.working ? T2(e3) : e3 instanceof Map);
  }, N.working = typeof Set != "undefined" && N(new Set), o$2.isSet = function(e3) {
    return typeof Set != "undefined" && (N.working ? N(e3) : e3 instanceof Set);
  }, W.working = typeof WeakMap != "undefined" && W(new WeakMap), o$2.isWeakMap = function(e3) {
    return typeof WeakMap != "undefined" && (W.working ? W(e3) : e3 instanceof WeakMap);
  }, $.working = typeof WeakSet != "undefined" && $(new WeakSet), o$2.isWeakSet = function(e3) {
    return $(e3);
  }, C.working = typeof ArrayBuffer != "undefined" && C(new ArrayBuffer), o$2.isArrayBuffer = V, G.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = typeof SharedArrayBuffer != "undefined" && J(new SharedArrayBuffer), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e3) {
    return m2(e3) === "[object AsyncFunction]";
  }, o$2.isMapIterator = function(e3) {
    return m2(e3) === "[object Map Iterator]";
  }, o$2.isSetIterator = function(e3) {
    return m2(e3) === "[object Set Iterator]";
  }, o$2.isGeneratorObject = function(e3) {
    return m2(e3) === "[object Generator]";
  }, o$2.isWebAssemblyCompiledModule = function(e3) {
    return m2(e3) === "[object WebAssembly.Module]";
  }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function(e3) {
    return H(e3) || Z(e3) || q(e3) || K(e3) || L(e3);
  }, o$2.isAnyArrayBuffer = function(e3) {
    return l$1 && (V(e3) || _(e3));
  }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e3) {
    Object.defineProperty(o$2, e3, { enumerable: false, value: function() {
      throw new Error(e3 + " is not supported in userland");
    } });
  });
  var Q = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : globalThis;
  var X = {};
  var Y = T;
  var ee = Object.getOwnPropertyDescriptors || function(e3) {
    for (var t3 = Object.keys(e3), r3 = {}, n3 = 0;n3 < t3.length; n3++)
      r3[t3[n3]] = Object.getOwnPropertyDescriptor(e3, t3[n3]);
    return r3;
  };
  var te = /%[sdj%]/g;
  X.format = function(e3) {
    if (!ge(e3)) {
      for (var t3 = [], r3 = 0;r3 < arguments.length; r3++)
        t3.push(oe(arguments[r3]));
      return t3.join(" ");
    }
    r3 = 1;
    for (var n3 = arguments, i3 = n3.length, o3 = String(e3).replace(te, function(e4) {
      if (e4 === "%%")
        return "%";
      if (r3 >= i3)
        return e4;
      switch (e4) {
        case "%s":
          return String(n3[r3++]);
        case "%d":
          return Number(n3[r3++]);
        case "%j":
          try {
            return JSON.stringify(n3[r3++]);
          } catch (e5) {
            return "[Circular]";
          }
        default:
          return e4;
      }
    }), u3 = n3[r3];r3 < i3; u3 = n3[++r3])
      le(u3) || !he(u3) ? o3 += " " + u3 : o3 += " " + oe(u3);
    return o3;
  }, X.deprecate = function(e3, t3) {
    if (Y !== undefined && Y.noDeprecation === true)
      return e3;
    if (Y === undefined)
      return function() {
        return X.deprecate(e3, t3).apply(this || Q, arguments);
      };
    var r3 = false;
    return function() {
      if (!r3) {
        if (Y.throwDeprecation)
          throw new Error(t3);
        Y.traceDeprecation ? console.trace(t3) : console.error(t3), r3 = true;
      }
      return e3.apply(this || Q, arguments);
    };
  };
  var re = {};
  var ne = /^$/;
  if (Y.env.NODE_DEBUG) {
    ie = Y.env.NODE_DEBUG;
    ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
  }
  var ie;
  __name(oe, "oe");
  __name(ue, "ue");
  __name(fe, "fe");
  __name(ae, "ae");
  __name(ce, "ce");
  __name(se, "se");
  __name(pe, "pe");
  __name(ye, "ye");
  __name(le, "le");
  __name(de, "de");
  __name(ge, "ge");
  __name(be, "be");
  __name(me, "me");
  __name(he, "he");
  __name(je, "je");
  __name(Ae, "Ae");
  __name(we, "we");
  __name(ve, "ve");
  __name(Oe, "Oe");
  X.debuglog = function(e3) {
    if (e3 = e3.toUpperCase(), !re[e3])
      if (ne.test(e3)) {
        var t3 = Y.pid;
        re[e3] = function() {
          var r3 = X.format.apply(X, arguments);
          console.error("%s %d: %s", e3, t3, r3);
        };
      } else
        re[e3] = function() {
        };
    return re[e3];
  }, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e3) {
    return e3 == null;
  }, X.isNumber = de, X.isString = ge, X.isSymbol = function(e3) {
    return typeof e3 == "symbol";
  }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e3) {
    return e3 === null || typeof e3 == "boolean" || typeof e3 == "number" || typeof e3 == "string" || typeof e3 == "symbol" || e3 === undefined;
  }, X.isBuffer = i$1;
  var Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  __name(Be, "Be");
  __name(ke, "ke");
  X.log = function() {
    console.log("%s - %s", Be(), X.format.apply(X, arguments));
  }, X.inherits = t$2, X._extend = function(e3, t3) {
    if (!t3 || !he(t3))
      return e3;
    for (var r3 = Object.keys(t3), n3 = r3.length;n3--; )
      e3[r3[n3]] = t3[r3[n3]];
    return e3;
  };
  var Ee = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : undefined;
  __name(De, "De");
  X.promisify = function(e3) {
    if (typeof e3 != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (Ee && e3[Ee]) {
      var t3;
      if (typeof (t3 = e3[Ee]) != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(t3, Ee, { value: t3, enumerable: false, writable: false, configurable: true }), t3;
    }
    function t3() {
      for (var t4, r3, n3 = new Promise(function(e4, n4) {
        t4 = e4, r3 = n4;
      }), i3 = [], o3 = 0;o3 < arguments.length; o3++)
        i3.push(arguments[o3]);
      i3.push(function(e4, n4) {
        e4 ? r3(e4) : t4(n4);
      });
      try {
        e3.apply(this || Q, i3);
      } catch (e4) {
        r3(e4);
      }
      return n3;
    }
    __name(t3, "t");
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Ee && Object.defineProperty(t3, Ee, { value: t3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t3, ee(e3));
  }, X.promisify.custom = Ee, X.callbackify = function(e3) {
    if (typeof e3 != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function t3() {
      for (var t4 = [], r3 = 0;r3 < arguments.length; r3++)
        t4.push(arguments[r3]);
      var n3 = t4.pop();
      if (typeof n3 != "function")
        throw new TypeError("The last argument must be of type Function");
      var i3 = this || Q, o3 = __name(function() {
        return n3.apply(i3, arguments);
      }, "o");
      e3.apply(this || Q, t4).then(function(e4) {
        Y.nextTick(o3.bind(null, null, e4));
      }, function(e4) {
        Y.nextTick(De.bind(null, e4, o3));
      });
    }
    __name(t3, "t");
    return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Object.defineProperties(t3, ee(e3)), t3;
  };
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X.types;
  X._extend;
  X.callbackify;
  X.debuglog;
  X.deprecate;
  X.format;
  X.inherits;
  var inspect2 = X.inspect;
  X.isArray;
  X.isBoolean;
  X.isBuffer;
  X.isDate;
  X.isError;
  X.isFunction;
  X.isNull;
  X.isNullOrUndefined;
  X.isNumber;
  X.isObject;
  X.isPrimitive;
  X.isRegExp;
  X.isString;
  X.isSymbol;
  X.isUndefined;
  X.log;
  X.promisify;
  X.types;
  X.TextEncoder = globalThis.TextEncoder;
  X.TextDecoder = globalThis.TextDecoder;
  var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
  var customInspectSymbolStackLess = Symbol.for("nodejs.util.inspect.custom.stack-less");
  var _BaseError = class _BaseError2 extends Error {
    [customInspectSymbol](depth, options) {
      return `${this[customInspectSymbolStackLess](depth, options)}
${this.stack.slice(this.stack.indexOf("\n"))}`;
    }
  };
  __name(_BaseError, "BaseError");
  var BaseError = _BaseError;
  var _BaseConstraintError = class _BaseConstraintError2 extends BaseError {
    constructor(constraint, message, given) {
      super(message);
      this.constraint = constraint;
      this.given = given;
    }
  };
  __name(_BaseConstraintError, "BaseConstraintError");
  var BaseConstraintError = _BaseConstraintError;
  var _ExpectedConstraintError = class _ExpectedConstraintError2 extends BaseConstraintError {
    constructor(constraint, message, given, expected) {
      super(constraint, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        constraint: this.constraint,
        given: this.given,
        expected: this.expected
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const constraint = options.stylize(this.constraint, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedConstraintError: ${constraint}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ExpectedConstraintError", "special")} > ${constraint}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected: ", "string")}${options.stylize(this.expected, "boolean")}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_ExpectedConstraintError, "ExpectedConstraintError");
  var ExpectedConstraintError = _ExpectedConstraintError;
  __name(whenConstraint, "whenConstraint");
  __name(resolveBooleanIs, "resolveBooleanIs");
  var _BaseValidator = class _BaseValidator2 {
    constructor(constraints = []) {
      this.constraints = [];
      this.isValidationEnabled = null;
      this.constraints = constraints;
    }
    setParent(parent) {
      this.parent = parent;
      return this;
    }
    get optional() {
      return new UnionValidator([new LiteralValidator(undefined), this.clone()]);
    }
    get nullable() {
      return new UnionValidator([new LiteralValidator(null), this.clone()]);
    }
    get nullish() {
      return new UnionValidator([new NullishValidator, this.clone()]);
    }
    get array() {
      return new ArrayValidator(this.clone());
    }
    get set() {
      return new SetValidator(this.clone());
    }
    or(...predicates) {
      return new UnionValidator([this.clone(), ...predicates]);
    }
    transform(cb) {
      return this.addConstraint({ run: (input) => Result.ok(cb(input)) });
    }
    reshape(cb) {
      return this.addConstraint({ run: cb });
    }
    default(value) {
      return new DefaultValidator(this.clone(), value);
    }
    when(key, options) {
      return this.addConstraint(whenConstraint(key, options, this));
    }
    describe(description) {
      const clone = this.clone();
      clone.description = description;
      return clone;
    }
    run(value) {
      let result = this.handle(value);
      if (result.isErr())
        return result;
      for (const constraint of this.constraints) {
        result = constraint.run(result.value, this.parent);
        if (result.isErr())
          break;
      }
      return result;
    }
    parse(value) {
      if (!this.shouldRunConstraints) {
        return this.handle(value).unwrap();
      }
      return this.constraints.reduce((v2, constraint) => constraint.run(v2).unwrap(), this.handle(value).unwrap());
    }
    is(value) {
      return this.run(value).isOk();
    }
    setValidationEnabled(isValidationEnabled) {
      const clone = this.clone();
      clone.isValidationEnabled = isValidationEnabled;
      return clone;
    }
    getValidationEnabled() {
      return getValue(this.isValidationEnabled);
    }
    get shouldRunConstraints() {
      return getValue(this.isValidationEnabled) ?? getGlobalValidationEnabled();
    }
    clone() {
      const clone = Reflect.construct(this.constructor, [this.constraints]);
      clone.isValidationEnabled = this.isValidationEnabled;
      return clone;
    }
    addConstraint(constraint) {
      const clone = this.clone();
      clone.constraints = clone.constraints.concat(constraint);
      return clone;
    }
  };
  __name(_BaseValidator, "BaseValidator");
  var BaseValidator = _BaseValidator;
  __name(isUnique, "isUnique");
  __name(lessThan, "lessThan");
  __name(lessThanOrEqual, "lessThanOrEqual");
  __name(greaterThan, "greaterThan");
  __name(greaterThanOrEqual, "greaterThanOrEqual");
  __name(equal, "equal");
  __name(notEqual, "notEqual");
  __name(arrayLengthComparator, "arrayLengthComparator");
  __name(arrayLengthLessThan, "arrayLengthLessThan");
  __name(arrayLengthLessThanOrEqual, "arrayLengthLessThanOrEqual");
  __name(arrayLengthGreaterThan, "arrayLengthGreaterThan");
  __name(arrayLengthGreaterThanOrEqual, "arrayLengthGreaterThanOrEqual");
  __name(arrayLengthEqual, "arrayLengthEqual");
  __name(arrayLengthNotEqual, "arrayLengthNotEqual");
  __name(arrayLengthRange, "arrayLengthRange");
  __name(arrayLengthRangeInclusive, "arrayLengthRangeInclusive");
  __name(arrayLengthRangeExclusive, "arrayLengthRangeExclusive");
  var uniqueArray = {
    run(input) {
      return isUnique(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).unique", "Array values are not unique", input, "Expected all values to be unique"));
    }
  };
  var _CombinedPropertyError = class _CombinedPropertyError2 extends BaseError {
    constructor(errors) {
      super("Received one or more errors");
      this.errors = errors;
    }
    [customInspectSymbolStackLess](depth, options) {
      if (depth < 0) {
        return options.stylize("[CombinedPropertyError]", "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const header = `${options.stylize("CombinedPropertyError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
      const message = options.stylize(this.message, "regexp");
      const errors = this.errors.map(([key, error]) => {
        const property = _CombinedPropertyError2.formatProperty(key, options);
        const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
        return `  input${property}${padding}${body}`;
      }).join("\n\n");
      return `${header}
  ${message}

${errors}`;
    }
    static formatProperty(key, options) {
      if (typeof key === "string")
        return options.stylize(`.${key}`, "symbol");
      if (typeof key === "number")
        return `[${options.stylize(key.toString(), "number")}]`;
      return `[${options.stylize("Symbol", "symbol")}(${key.description})]`;
    }
  };
  __name(_CombinedPropertyError, "CombinedPropertyError");
  var CombinedPropertyError = _CombinedPropertyError;
  var _ValidationError = class _ValidationError2 extends BaseError {
    constructor(validator, message, given) {
      super(message);
      this.validator = validator;
      this.given = given;
    }
    toJSON() {
      return {
        name: this.name,
        validator: this.validator,
        given: this.given
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(_ValidationError, "ValidationError");
  var ValidationError = _ValidationError;
  var _ArrayValidator = class _ArrayValidator2 extends BaseValidator {
    constructor(validator, constraints = []) {
      super(constraints);
      this.validator = validator;
    }
    lengthLessThan(length) {
      return this.addConstraint(arrayLengthLessThan(length));
    }
    lengthLessThanOrEqual(length) {
      return this.addConstraint(arrayLengthLessThanOrEqual(length));
    }
    lengthGreaterThan(length) {
      return this.addConstraint(arrayLengthGreaterThan(length));
    }
    lengthGreaterThanOrEqual(length) {
      return this.addConstraint(arrayLengthGreaterThanOrEqual(length));
    }
    lengthEqual(length) {
      return this.addConstraint(arrayLengthEqual(length));
    }
    lengthNotEqual(length) {
      return this.addConstraint(arrayLengthNotEqual(length));
    }
    lengthRange(start, endBefore) {
      return this.addConstraint(arrayLengthRange(start, endBefore));
    }
    lengthRangeInclusive(startAt, endAt) {
      return this.addConstraint(arrayLengthRangeInclusive(startAt, endAt));
    }
    lengthRangeExclusive(startAfter, endBefore) {
      return this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore));
    }
    get unique() {
      return this.addConstraint(uniqueArray);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.constraints]);
    }
    handle(values) {
      if (!Array.isArray(values)) {
        return Result.err(new ValidationError("s.array(T)", "Expected an array", values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = [];
      for (let i3 = 0;i3 < values.length; i3++) {
        const result = this.validator.run(values[i3]);
        if (result.isOk())
          transformed.push(result.value);
        else
          errors.push([i3, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
    }
  };
  __name(_ArrayValidator, "ArrayValidator");
  var ArrayValidator = _ArrayValidator;
  __name(bigintComparator, "bigintComparator");
  __name(bigintLessThan, "bigintLessThan");
  __name(bigintLessThanOrEqual, "bigintLessThanOrEqual");
  __name(bigintGreaterThan, "bigintGreaterThan");
  __name(bigintGreaterThanOrEqual, "bigintGreaterThanOrEqual");
  __name(bigintEqual, "bigintEqual");
  __name(bigintNotEqual, "bigintNotEqual");
  __name(bigintDivisibleBy, "bigintDivisibleBy");
  var _BigIntValidator = class _BigIntValidator2 extends BaseValidator {
    lessThan(number) {
      return this.addConstraint(bigintLessThan(number));
    }
    lessThanOrEqual(number) {
      return this.addConstraint(bigintLessThanOrEqual(number));
    }
    greaterThan(number) {
      return this.addConstraint(bigintGreaterThan(number));
    }
    greaterThanOrEqual(number) {
      return this.addConstraint(bigintGreaterThanOrEqual(number));
    }
    equal(number) {
      return this.addConstraint(bigintEqual(number));
    }
    notEqual(number) {
      return this.addConstraint(bigintNotEqual(number));
    }
    get positive() {
      return this.greaterThanOrEqual(0n);
    }
    get negative() {
      return this.lessThan(0n);
    }
    divisibleBy(number) {
      return this.addConstraint(bigintDivisibleBy(number));
    }
    get abs() {
      return this.transform((value) => value < 0 ? -value : value);
    }
    intN(bits) {
      return this.transform((value) => BigInt.asIntN(bits, value));
    }
    uintN(bits) {
      return this.transform((value) => BigInt.asUintN(bits, value));
    }
    handle(value) {
      return typeof value === "bigint" ? Result.ok(value) : Result.err(new ValidationError("s.bigint", "Expected a bigint primitive", value));
    }
  };
  __name(_BigIntValidator, "BigIntValidator");
  var BigIntValidator = _BigIntValidator;
  var booleanTrue = {
    run(input) {
      return input ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.boolean.true", "Invalid boolean value", input, "true"));
    }
  };
  var booleanFalse = {
    run(input) {
      return input ? Result.err(new ExpectedConstraintError("s.boolean.false", "Invalid boolean value", input, "false")) : Result.ok(input);
    }
  };
  var _BooleanValidator = class _BooleanValidator2 extends BaseValidator {
    get true() {
      return this.addConstraint(booleanTrue);
    }
    get false() {
      return this.addConstraint(booleanFalse);
    }
    equal(value) {
      return value ? this.true : this.false;
    }
    notEqual(value) {
      return value ? this.false : this.true;
    }
    handle(value) {
      return typeof value === "boolean" ? Result.ok(value) : Result.err(new ValidationError("s.boolean", "Expected a boolean primitive", value));
    }
  };
  __name(_BooleanValidator, "BooleanValidator");
  var BooleanValidator = _BooleanValidator;
  __name(dateComparator, "dateComparator");
  __name(dateLessThan, "dateLessThan");
  __name(dateLessThanOrEqual, "dateLessThanOrEqual");
  __name(dateGreaterThan, "dateGreaterThan");
  __name(dateGreaterThanOrEqual, "dateGreaterThanOrEqual");
  __name(dateEqual, "dateEqual");
  __name(dateNotEqual, "dateNotEqual");
  var dateInvalid = {
    run(input) {
      return Number.isNaN(input.getTime()) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.date.invalid", "Invalid Date value", input, "expected === NaN"));
    }
  };
  var dateValid = {
    run(input) {
      return Number.isNaN(input.getTime()) ? Result.err(new ExpectedConstraintError("s.date.valid", "Invalid Date value", input, "expected !== NaN")) : Result.ok(input);
    }
  };
  var _DateValidator = class _DateValidator2 extends BaseValidator {
    lessThan(date) {
      return this.addConstraint(dateLessThan(new Date(date)));
    }
    lessThanOrEqual(date) {
      return this.addConstraint(dateLessThanOrEqual(new Date(date)));
    }
    greaterThan(date) {
      return this.addConstraint(dateGreaterThan(new Date(date)));
    }
    greaterThanOrEqual(date) {
      return this.addConstraint(dateGreaterThanOrEqual(new Date(date)));
    }
    equal(date) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.invalid : this.addConstraint(dateEqual(resolved));
    }
    notEqual(date) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.valid : this.addConstraint(dateNotEqual(resolved));
    }
    get valid() {
      return this.addConstraint(dateValid);
    }
    get invalid() {
      return this.addConstraint(dateInvalid);
    }
    handle(value) {
      return value instanceof Date ? Result.ok(value) : Result.err(new ValidationError("s.date", "Expected a Date", value));
    }
  };
  __name(_DateValidator, "DateValidator");
  var DateValidator = _DateValidator;
  var _ExpectedValidationError = class _ExpectedValidationError2 extends ValidationError {
    constructor(validator, message, given, expected) {
      super(validator, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        validator: this.validator,
        given: this.given,
        expected: this.expected
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const expected = inspect2(this.expected, newOptions).replace(/\n/g, padding);
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ExpectedValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected:", "string")}${padding}${expected}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_ExpectedValidationError, "ExpectedValidationError");
  var ExpectedValidationError = _ExpectedValidationError;
  var _InstanceValidator = class _InstanceValidator2 extends BaseValidator {
    constructor(expected, constraints = []) {
      super(constraints);
      this.expected = expected;
    }
    handle(value) {
      return value instanceof this.expected ? Result.ok(value) : Result.err(new ExpectedValidationError("s.instance(V)", "Expected", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.constraints]);
    }
  };
  __name(_InstanceValidator, "InstanceValidator");
  var InstanceValidator = _InstanceValidator;
  var _LiteralValidator = class _LiteralValidator2 extends BaseValidator {
    constructor(literal, constraints = []) {
      super(constraints);
      this.expected = literal;
    }
    handle(value) {
      return Object.is(value, this.expected) ? Result.ok(value) : Result.err(new ExpectedValidationError("s.literal(V)", "Expected values to be equals", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.constraints]);
    }
  };
  __name(_LiteralValidator, "LiteralValidator");
  var LiteralValidator = _LiteralValidator;
  var _NeverValidator = class _NeverValidator2 extends BaseValidator {
    handle(value) {
      return Result.err(new ValidationError("s.never", "Expected a value to not be passed", value));
    }
  };
  __name(_NeverValidator, "NeverValidator");
  var NeverValidator = _NeverValidator;
  var _NullishValidator = class _NullishValidator2 extends BaseValidator {
    handle(value) {
      return value === undefined || value === null ? Result.ok(value) : Result.err(new ValidationError("s.nullish", "Expected undefined or null", value));
    }
  };
  __name(_NullishValidator, "NullishValidator");
  var NullishValidator = _NullishValidator;
  __name(numberComparator, "numberComparator");
  __name(numberLessThan, "numberLessThan");
  __name(numberLessThanOrEqual, "numberLessThanOrEqual");
  __name(numberGreaterThan, "numberGreaterThan");
  __name(numberGreaterThanOrEqual, "numberGreaterThanOrEqual");
  __name(numberEqual, "numberEqual");
  __name(numberNotEqual, "numberNotEqual");
  var numberInt = {
    run(input) {
      return Number.isInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.int", "Given value is not an integer", input, "Number.isInteger(expected) to be true"));
    }
  };
  var numberSafeInt = {
    run(input) {
      return Number.isSafeInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.safeInt", "Given value is not a safe integer", input, "Number.isSafeInteger(expected) to be true"));
    }
  };
  var numberFinite = {
    run(input) {
      return Number.isFinite(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.finite", "Given value is not finite", input, "Number.isFinite(expected) to be true"));
    }
  };
  var numberNaN = {
    run(input) {
      return Number.isNaN(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.equal(NaN)", "Invalid number value", input, "expected === NaN"));
    }
  };
  var numberNotNaN = {
    run(input) {
      return Number.isNaN(input) ? Result.err(new ExpectedConstraintError("s.number.notEqual(NaN)", "Invalid number value", input, "expected !== NaN")) : Result.ok(input);
    }
  };
  __name(numberDivisibleBy, "numberDivisibleBy");
  var _NumberValidator = class _NumberValidator2 extends BaseValidator {
    lessThan(number) {
      return this.addConstraint(numberLessThan(number));
    }
    lessThanOrEqual(number) {
      return this.addConstraint(numberLessThanOrEqual(number));
    }
    greaterThan(number) {
      return this.addConstraint(numberGreaterThan(number));
    }
    greaterThanOrEqual(number) {
      return this.addConstraint(numberGreaterThanOrEqual(number));
    }
    equal(number) {
      return Number.isNaN(number) ? this.addConstraint(numberNaN) : this.addConstraint(numberEqual(number));
    }
    notEqual(number) {
      return Number.isNaN(number) ? this.addConstraint(numberNotNaN) : this.addConstraint(numberNotEqual(number));
    }
    get int() {
      return this.addConstraint(numberInt);
    }
    get safeInt() {
      return this.addConstraint(numberSafeInt);
    }
    get finite() {
      return this.addConstraint(numberFinite);
    }
    get positive() {
      return this.greaterThanOrEqual(0);
    }
    get negative() {
      return this.lessThan(0);
    }
    divisibleBy(divider) {
      return this.addConstraint(numberDivisibleBy(divider));
    }
    get abs() {
      return this.transform(Math.abs);
    }
    get sign() {
      return this.transform(Math.sign);
    }
    get trunc() {
      return this.transform(Math.trunc);
    }
    get floor() {
      return this.transform(Math.floor);
    }
    get fround() {
      return this.transform(Math.fround);
    }
    get round() {
      return this.transform(Math.round);
    }
    get ceil() {
      return this.transform(Math.ceil);
    }
    handle(value) {
      return typeof value === "number" ? Result.ok(value) : Result.err(new ValidationError("s.number", "Expected a number primitive", value));
    }
  };
  __name(_NumberValidator, "NumberValidator");
  var NumberValidator = _NumberValidator;
  var _MissingPropertyError = class _MissingPropertyError2 extends BaseError {
    constructor(property) {
      super("A required property is missing");
      this.property = property;
    }
    toJSON() {
      return {
        name: this.name,
        property: this.property
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[MissingPropertyError: ${property}]`, "special");
      }
      const header = `${options.stylize("MissingPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      return `${header}
  ${message}`;
    }
  };
  __name(_MissingPropertyError, "MissingPropertyError");
  var MissingPropertyError = _MissingPropertyError;
  var _UnknownPropertyError = class _UnknownPropertyError2 extends BaseError {
    constructor(property, value) {
      super("Received unexpected property");
      this.property = property;
      this.value = value;
    }
    toJSON() {
      return {
        name: this.name,
        property: this.property,
        value: this.value
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[UnknownPropertyError: ${property}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = inspect2(this.value, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("UnknownPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(_UnknownPropertyError, "UnknownPropertyError");
  var UnknownPropertyError = _UnknownPropertyError;
  var _DefaultValidator = class _DefaultValidator2 extends BaseValidator {
    constructor(validator, value, constraints = []) {
      super(constraints);
      this.validator = validator;
      this.defaultValue = value;
    }
    default(value) {
      const clone = this.clone();
      clone.defaultValue = value;
      return clone;
    }
    handle(value) {
      return typeof value === "undefined" ? Result.ok(getValue(this.defaultValue)) : this.validator["handle"](value);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.constraints]);
    }
  };
  __name(_DefaultValidator, "DefaultValidator");
  var DefaultValidator = _DefaultValidator;
  var _CombinedError = class _CombinedError2 extends BaseError {
    constructor(errors) {
      super("Received one or more errors");
      this.errors = errors;
    }
    [customInspectSymbolStackLess](depth, options) {
      if (depth < 0) {
        return options.stylize("[CombinedError]", "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const header = `${options.stylize("CombinedError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
      const message = options.stylize(this.message, "regexp");
      const errors = this.errors.map((error, i3) => {
        const index = options.stylize((i3 + 1).toString(), "number");
        const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
        return `  ${index} ${body}`;
      }).join("\n\n");
      return `${header}
  ${message}

${errors}`;
    }
  };
  __name(_CombinedError, "CombinedError");
  var CombinedError = _CombinedError;
  var _UnionValidator = class _UnionValidator2 extends BaseValidator {
    constructor(validators, constraints = []) {
      super(constraints);
      this.validators = validators;
    }
    get optional() {
      if (this.validators.length === 0)
        return new _UnionValidator2([new LiteralValidator(undefined)], this.constraints);
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === undefined)
          return this.clone();
        if (validator.expected === null) {
          return new _UnionValidator2([new NullishValidator, ...this.validators.slice(1)], this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new LiteralValidator(undefined), ...this.validators]);
    }
    get required() {
      if (this.validators.length === 0)
        return this.clone();
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === undefined)
          return new _UnionValidator2(this.validators.slice(1), this.constraints);
      } else if (validator instanceof NullishValidator) {
        return new _UnionValidator2([new LiteralValidator(null), ...this.validators.slice(1)], this.constraints);
      }
      return this.clone();
    }
    get nullable() {
      if (this.validators.length === 0)
        return new _UnionValidator2([new LiteralValidator(null)], this.constraints);
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === null)
          return this.clone();
        if (validator.expected === undefined) {
          return new _UnionValidator2([new NullishValidator, ...this.validators.slice(1)], this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new LiteralValidator(null), ...this.validators]);
    }
    get nullish() {
      if (this.validators.length === 0)
        return new _UnionValidator2([new NullishValidator], this.constraints);
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === null || validator.expected === undefined) {
          return new _UnionValidator2([new NullishValidator, ...this.validators.slice(1)], this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new _UnionValidator2([new NullishValidator, ...this.validators]);
    }
    or(...predicates) {
      return new _UnionValidator2([...this.validators, ...predicates]);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validators, this.constraints]);
    }
    handle(value) {
      const errors = [];
      for (const validator of this.validators) {
        const result = validator.run(value);
        if (result.isOk())
          return result;
        errors.push(result.error);
      }
      return Result.err(new CombinedError(errors));
    }
  };
  __name(_UnionValidator, "UnionValidator");
  var UnionValidator = _UnionValidator;
  var _ObjectValidator = class _ObjectValidator2 extends BaseValidator {
    constructor(shape, strategy = 0, constraints = []) {
      super(constraints);
      this.keys = [];
      this.requiredKeys = new Map;
      this.possiblyUndefinedKeys = new Map;
      this.possiblyUndefinedKeysWithDefaults = new Map;
      this.shape = shape;
      this.strategy = strategy;
      switch (this.strategy) {
        case 0:
          this.handleStrategy = (value) => this.handleIgnoreStrategy(value);
          break;
        case 1: {
          this.handleStrategy = (value) => this.handleStrictStrategy(value);
          break;
        }
        case 2:
          this.handleStrategy = (value) => this.handlePassthroughStrategy(value);
          break;
      }
      const shapeEntries = Object.entries(shape);
      this.keys = shapeEntries.map(([key]) => key);
      for (const [key, validator] of shapeEntries) {
        if (validator instanceof UnionValidator) {
          const [possiblyLiteralOrNullishPredicate] = validator["validators"];
          if (possiblyLiteralOrNullishPredicate instanceof NullishValidator) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else if (possiblyLiteralOrNullishPredicate instanceof LiteralValidator) {
            if (possiblyLiteralOrNullishPredicate.expected === undefined) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof DefaultValidator) {
            this.possiblyUndefinedKeysWithDefaults.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        } else if (validator instanceof NullishValidator) {
          this.possiblyUndefinedKeys.set(key, validator);
        } else if (validator instanceof LiteralValidator) {
          if (validator.expected === undefined) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        } else if (validator instanceof DefaultValidator) {
          this.possiblyUndefinedKeysWithDefaults.set(key, validator);
        } else {
          this.requiredKeys.set(key, validator);
        }
      }
    }
    get strict() {
      return Reflect.construct(this.constructor, [this.shape, 1, this.constraints]);
    }
    get ignore() {
      return Reflect.construct(this.constructor, [this.shape, 0, this.constraints]);
    }
    get passthrough() {
      return Reflect.construct(this.constructor, [this.shape, 2, this.constraints]);
    }
    get partial() {
      const shape = Object.fromEntries(this.keys.map((key) => [key, this.shape[key].optional]));
      return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
    }
    get required() {
      const shape = Object.fromEntries(this.keys.map((key) => {
        let validator = this.shape[key];
        if (validator instanceof UnionValidator)
          validator = validator.required;
        return [key, validator];
      }));
      return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
    }
    extend(schema) {
      const shape = { ...this.shape, ...schema instanceof _ObjectValidator2 ? schema.shape : schema };
      return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
    }
    pick(keys) {
      const shape = Object.fromEntries(keys.filter((key) => this.keys.includes(key)).map((key) => [key, this.shape[key]]));
      return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
    }
    omit(keys) {
      const shape = Object.fromEntries(this.keys.filter((key) => !keys.includes(key)).map((key) => [key, this.shape[key]]));
      return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
    }
    handle(value) {
      const typeOfValue = typeof value;
      if (typeOfValue !== "object") {
        return Result.err(new ValidationError("s.object(T)", `Expected the value to be an object, but received ${typeOfValue} instead`, value));
      }
      if (value === null) {
        return Result.err(new ValidationError("s.object(T)", "Expected the value to not be null", value));
      }
      if (Array.isArray(value)) {
        return Result.err(new ValidationError("s.object(T)", "Expected the value to not be an array", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      for (const predicate of Object.values(this.shape)) {
        predicate.setParent(this.parent ?? value);
      }
      return this.handleStrategy(value);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.shape, this.strategy, this.constraints]);
    }
    handleIgnoreStrategy(value) {
      const errors = [];
      const finalObject = {};
      const inputEntries = new Map(Object.entries(value));
      const runPredicate = __name((key, predicate) => {
        const result = predicate.run(value[key]);
        if (result.isOk()) {
          finalObject[key] = result.value;
        } else {
          const error = result.error;
          errors.push([key, error]);
        }
      }, "runPredicate");
      for (const [key, predicate] of this.requiredKeys) {
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        } else {
          errors.push([key, new MissingPropertyError(key)]);
        }
      }
      for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
        inputEntries.delete(key);
        runPredicate(key, validator);
      }
      if (inputEntries.size === 0) {
        return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));
      }
      const checkInputEntriesInsteadOfSchemaKeys = this.possiblyUndefinedKeys.size > inputEntries.size;
      if (checkInputEntriesInsteadOfSchemaKeys) {
        for (const [key] of inputEntries) {
          const predicate = this.possiblyUndefinedKeys.get(key);
          if (predicate) {
            runPredicate(key, predicate);
          }
        }
      } else {
        for (const [key, predicate] of this.possiblyUndefinedKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          }
        }
      }
      return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));
    }
    handleStrictStrategy(value) {
      const errors = [];
      const finalResult = {};
      const inputEntries = new Map(Object.entries(value));
      const runPredicate = __name((key, predicate) => {
        const result = predicate.run(value[key]);
        if (result.isOk()) {
          finalResult[key] = result.value;
        } else {
          const error = result.error;
          errors.push([key, error]);
        }
      }, "runPredicate");
      for (const [key, predicate] of this.requiredKeys) {
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        } else {
          errors.push([key, new MissingPropertyError(key)]);
        }
      }
      for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
        inputEntries.delete(key);
        runPredicate(key, validator);
      }
      for (const [key, predicate] of this.possiblyUndefinedKeys) {
        if (inputEntries.size === 0) {
          break;
        }
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        }
      }
      if (inputEntries.size !== 0) {
        for (const [key, value2] of inputEntries.entries()) {
          errors.push([key, new UnknownPropertyError(key, value2)]);
        }
      }
      return errors.length === 0 ? Result.ok(finalResult) : Result.err(new CombinedPropertyError(errors));
    }
    handlePassthroughStrategy(value) {
      const result = this.handleIgnoreStrategy(value);
      return result.isErr() ? result : Result.ok({ ...value, ...result.value });
    }
  };
  __name(_ObjectValidator, "ObjectValidator");
  var ObjectValidator = _ObjectValidator;
  var _PassthroughValidator = class _PassthroughValidator2 extends BaseValidator {
    handle(value) {
      return Result.ok(value);
    }
  };
  __name(_PassthroughValidator, "PassthroughValidator");
  var PassthroughValidator = _PassthroughValidator;
  var _RecordValidator = class _RecordValidator2 extends BaseValidator {
    constructor(validator, constraints = []) {
      super(constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.constraints]);
    }
    handle(value) {
      if (typeof value !== "object") {
        return Result.err(new ValidationError("s.record(T)", "Expected an object", value));
      }
      if (value === null) {
        return Result.err(new ValidationError("s.record(T)", "Expected the value to not be null", value));
      }
      if (Array.isArray(value)) {
        return Result.err(new ValidationError("s.record(T)", "Expected the value to not be an array", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      const errors = [];
      const transformed = {};
      for (const [key, val] of Object.entries(value)) {
        const result = this.validator.run(val);
        if (result.isOk())
          transformed[key] = result.value;
        else
          errors.push([key, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
    }
  };
  __name(_RecordValidator, "RecordValidator");
  var RecordValidator = _RecordValidator;
  var _SetValidator = class _SetValidator2 extends BaseValidator {
    constructor(validator, constraints = []) {
      super(constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.constraints]);
    }
    handle(values) {
      if (!(values instanceof Set)) {
        return Result.err(new ValidationError("s.set(T)", "Expected a set", values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = new Set;
      for (const value of values) {
        const result = this.validator.run(value);
        if (result.isOk())
          transformed.add(result.value);
        else
          errors.push(result.error);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedError(errors));
    }
  };
  __name(_SetValidator, "SetValidator");
  var SetValidator = _SetValidator;
  var accountRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]$/i;
  __name(validateEmail, "validateEmail");
  __name(validateEmailDomain, "validateEmailDomain");
  var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
  var IPv4Reg = new RegExp(`^${v4Str}\$`);
  var v6Seg = "(?:[0-9a-fA-F]{1,4})";
  var IPv6Reg = new RegExp(`^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?\$`);
  __name(isIPv4, "isIPv4");
  __name(isIPv6, "isIPv6");
  __name(isIP, "isIP");
  var phoneNumberRegex = /^((?:\+|0{0,2})\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}$/;
  __name(validatePhoneNumber, "validatePhoneNumber");
  var _MultiplePossibilitiesConstraintError = class _MultiplePossibilitiesConstraintError2 extends BaseConstraintError {
    constructor(constraint, message, given, expected) {
      super(constraint, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        constraint: this.constraint,
        given: this.given,
        expected: this.expected
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const constraint = options.stylize(this.constraint, "string");
      if (depth < 0) {
        return options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const verticalLine = options.stylize("|", "undefined");
      const padding = `
  ${verticalLine} `;
      const given = inspect2(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("MultiplePossibilitiesConstraintError", "special")} > ${constraint}`;
      const message = options.stylize(this.message, "regexp");
      const expectedPadding = `
  ${verticalLine} - `;
      const expectedBlock = `
  ${options.stylize("Expected any of the following:", "string")}${expectedPadding}${this.expected.map((possible) => options.stylize(possible, "boolean")).join(expectedPadding)}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(_MultiplePossibilitiesConstraintError, "MultiplePossibilitiesConstraintError");
  var MultiplePossibilitiesConstraintError = _MultiplePossibilitiesConstraintError;
  __name(combinedErrorFn, "combinedErrorFn");
  __name(createUrlValidators, "createUrlValidators");
  __name(allowedProtocolsFn, "allowedProtocolsFn");
  __name(allowedDomainsFn, "allowedDomainsFn");
  __name(stringLengthComparator, "stringLengthComparator");
  __name(stringLengthLessThan, "stringLengthLessThan");
  __name(stringLengthLessThanOrEqual, "stringLengthLessThanOrEqual");
  __name(stringLengthGreaterThan, "stringLengthGreaterThan");
  __name(stringLengthGreaterThanOrEqual, "stringLengthGreaterThanOrEqual");
  __name(stringLengthEqual, "stringLengthEqual");
  __name(stringLengthNotEqual, "stringLengthNotEqual");
  __name(stringEmail, "stringEmail");
  __name(stringRegexValidator, "stringRegexValidator");
  __name(stringUrl, "stringUrl");
  __name(stringIp, "stringIp");
  __name(stringRegex, "stringRegex");
  __name(stringUuid, "stringUuid");
  __name(stringDate, "stringDate");
  __name(stringPhone, "stringPhone");
  var _StringValidator = class _StringValidator2 extends BaseValidator {
    lengthLessThan(length) {
      return this.addConstraint(stringLengthLessThan(length));
    }
    lengthLessThanOrEqual(length) {
      return this.addConstraint(stringLengthLessThanOrEqual(length));
    }
    lengthGreaterThan(length) {
      return this.addConstraint(stringLengthGreaterThan(length));
    }
    lengthGreaterThanOrEqual(length) {
      return this.addConstraint(stringLengthGreaterThanOrEqual(length));
    }
    lengthEqual(length) {
      return this.addConstraint(stringLengthEqual(length));
    }
    lengthNotEqual(length) {
      return this.addConstraint(stringLengthNotEqual(length));
    }
    get email() {
      return this.addConstraint(stringEmail());
    }
    url(options) {
      return this.addConstraint(stringUrl(options));
    }
    uuid(options) {
      return this.addConstraint(stringUuid(options));
    }
    regex(regex) {
      return this.addConstraint(stringRegex(regex));
    }
    get date() {
      return this.addConstraint(stringDate());
    }
    get ipv4() {
      return this.ip(4);
    }
    get ipv6() {
      return this.ip(6);
    }
    ip(version) {
      return this.addConstraint(stringIp(version));
    }
    phone() {
      return this.addConstraint(stringPhone());
    }
    handle(value) {
      return typeof value === "string" ? Result.ok(value) : Result.err(new ValidationError("s.string", "Expected a string primitive", value));
    }
  };
  __name(_StringValidator, "StringValidator");
  var StringValidator = _StringValidator;
  var _TupleValidator = class _TupleValidator2 extends BaseValidator {
    constructor(validators, constraints = []) {
      super(constraints);
      this.validators = [];
      this.validators = validators;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validators, this.constraints]);
    }
    handle(values) {
      if (!Array.isArray(values)) {
        return Result.err(new ValidationError("s.tuple(T)", "Expected an array", values));
      }
      if (values.length !== this.validators.length) {
        return Result.err(new ValidationError("s.tuple(T)", `Expected an array of length ${this.validators.length}`, values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = [];
      for (let i3 = 0;i3 < values.length; i3++) {
        const result = this.validators[i3].run(values[i3]);
        if (result.isOk())
          transformed.push(result.value);
        else
          errors.push([i3, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
    }
  };
  __name(_TupleValidator, "TupleValidator");
  var TupleValidator = _TupleValidator;
  var _MapValidator = class _MapValidator2 extends BaseValidator {
    constructor(keyValidator, valueValidator, constraints = []) {
      super(constraints);
      this.keyValidator = keyValidator;
      this.valueValidator = valueValidator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.constraints]);
    }
    handle(value) {
      if (!(value instanceof Map)) {
        return Result.err(new ValidationError("s.map(K, V)", "Expected a map", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      const errors = [];
      const transformed = new Map;
      for (const [key, val] of value.entries()) {
        const keyResult = this.keyValidator.run(key);
        const valueResult = this.valueValidator.run(val);
        const { length } = errors;
        if (keyResult.isErr())
          errors.push([key, keyResult.error]);
        if (valueResult.isErr())
          errors.push([key, valueResult.error]);
        if (errors.length === length)
          transformed.set(keyResult.value, valueResult.value);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
    }
  };
  __name(_MapValidator, "MapValidator");
  var MapValidator = _MapValidator;
  var _LazyValidator = class _LazyValidator2 extends BaseValidator {
    constructor(validator, constraints = []) {
      super(constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.constraints]);
    }
    handle(values) {
      return this.validator(values).run(values);
    }
  };
  __name(_LazyValidator, "LazyValidator");
  var LazyValidator = _LazyValidator;
  var _UnknownEnumValueError = class _UnknownEnumValueError2 extends BaseError {
    constructor(value, keys, enumMappings) {
      super("Expected the value to be one of the following enum values:");
      this.value = value;
      this.enumKeys = keys;
      this.enumMappings = enumMappings;
    }
    toJSON() {
      return {
        name: this.name,
        value: this.value,
        enumKeys: this.enumKeys,
        enumMappings: [...this.enumMappings.entries()]
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const value = options.stylize(this.value.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[UnknownEnumValueError: ${value}]`, "special");
      }
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const pairs = this.enumKeys.map((key) => {
        const enumValue = this.enumMappings.get(key);
        return `${options.stylize(key, "string")} or ${options.stylize(enumValue.toString(), typeof enumValue === "number" ? "number" : "string")}`;
      }).join(padding);
      const header = `${options.stylize("UnknownEnumValueError", "special")} > ${value}`;
      const message = options.stylize(this.message, "regexp");
      const pairsBlock = `${padding}${pairs}`;
      return `${header}
  ${message}
${pairsBlock}`;
    }
  };
  __name(_UnknownEnumValueError, "UnknownEnumValueError");
  var UnknownEnumValueError = _UnknownEnumValueError;
  var _NativeEnumValidator = class _NativeEnumValidator2 extends BaseValidator {
    constructor(enumShape) {
      super();
      this.hasNumericElements = false;
      this.enumMapping = new Map;
      this.enumShape = enumShape;
      this.enumKeys = Object.keys(enumShape).filter((key) => {
        return typeof enumShape[enumShape[key]] !== "number";
      });
      for (const key of this.enumKeys) {
        const enumValue = enumShape[key];
        this.enumMapping.set(key, enumValue);
        this.enumMapping.set(enumValue, enumValue);
        if (typeof enumValue === "number") {
          this.hasNumericElements = true;
          this.enumMapping.set(`${enumValue}`, enumValue);
        }
      }
    }
    handle(value) {
      const typeOfValue = typeof value;
      if (typeOfValue === "number") {
        if (!this.hasNumericElements) {
          return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string", value));
        }
      } else if (typeOfValue !== "string") {
        return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string or number", value));
      }
      const casted = value;
      const possibleEnumValue = this.enumMapping.get(casted);
      return typeof possibleEnumValue === "undefined" ? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping)) : Result.ok(possibleEnumValue);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.enumShape]);
    }
  };
  __name(_NativeEnumValidator, "NativeEnumValidator");
  var NativeEnumValidator = _NativeEnumValidator;
  __name(typedArrayByteLengthComparator, "typedArrayByteLengthComparator");
  __name(typedArrayByteLengthLessThan, "typedArrayByteLengthLessThan");
  __name(typedArrayByteLengthLessThanOrEqual, "typedArrayByteLengthLessThanOrEqual");
  __name(typedArrayByteLengthGreaterThan, "typedArrayByteLengthGreaterThan");
  __name(typedArrayByteLengthGreaterThanOrEqual, "typedArrayByteLengthGreaterThanOrEqual");
  __name(typedArrayByteLengthEqual, "typedArrayByteLengthEqual");
  __name(typedArrayByteLengthNotEqual, "typedArrayByteLengthNotEqual");
  __name(typedArrayByteLengthRange, "typedArrayByteLengthRange");
  __name(typedArrayByteLengthRangeInclusive, "typedArrayByteLengthRangeInclusive");
  __name(typedArrayByteLengthRangeExclusive, "typedArrayByteLengthRangeExclusive");
  __name(typedArrayLengthComparator, "typedArrayLengthComparator");
  __name(typedArrayLengthLessThan, "typedArrayLengthLessThan");
  __name(typedArrayLengthLessThanOrEqual, "typedArrayLengthLessThanOrEqual");
  __name(typedArrayLengthGreaterThan, "typedArrayLengthGreaterThan");
  __name(typedArrayLengthGreaterThanOrEqual, "typedArrayLengthGreaterThanOrEqual");
  __name(typedArrayLengthEqual, "typedArrayLengthEqual");
  __name(typedArrayLengthNotEqual, "typedArrayLengthNotEqual");
  __name(typedArrayLengthRange, "typedArrayLengthRange");
  __name(typedArrayLengthRangeInclusive, "typedArrayLengthRangeInclusive");
  __name(typedArrayLengthRangeExclusive, "typedArrayLengthRangeExclusive");
  var vowels = ["a", "e", "i", "o", "u"];
  var aOrAn = __name((word) => {
    return `${vowels.includes(word[0].toLowerCase()) ? "an" : "a"} ${word}`;
  }, "aOrAn");
  var TypedArrays = {
    Int8Array: (x2) => x2 instanceof Int8Array,
    Uint8Array: (x2) => x2 instanceof Uint8Array,
    Uint8ClampedArray: (x2) => x2 instanceof Uint8ClampedArray,
    Int16Array: (x2) => x2 instanceof Int16Array,
    Uint16Array: (x2) => x2 instanceof Uint16Array,
    Int32Array: (x2) => x2 instanceof Int32Array,
    Uint32Array: (x2) => x2 instanceof Uint32Array,
    Float32Array: (x2) => x2 instanceof Float32Array,
    Float64Array: (x2) => x2 instanceof Float64Array,
    BigInt64Array: (x2) => x2 instanceof BigInt64Array,
    BigUint64Array: (x2) => x2 instanceof BigUint64Array,
    TypedArray: (x2) => ArrayBuffer.isView(x2) && !(x2 instanceof DataView)
  };
  var _TypedArrayValidator = class _TypedArrayValidator2 extends BaseValidator {
    constructor(type, constraints = []) {
      super(constraints);
      this.type = type;
    }
    byteLengthLessThan(length) {
      return this.addConstraint(typedArrayByteLengthLessThan(length));
    }
    byteLengthLessThanOrEqual(length) {
      return this.addConstraint(typedArrayByteLengthLessThanOrEqual(length));
    }
    byteLengthGreaterThan(length) {
      return this.addConstraint(typedArrayByteLengthGreaterThan(length));
    }
    byteLengthGreaterThanOrEqual(length) {
      return this.addConstraint(typedArrayByteLengthGreaterThanOrEqual(length));
    }
    byteLengthEqual(length) {
      return this.addConstraint(typedArrayByteLengthEqual(length));
    }
    byteLengthNotEqual(length) {
      return this.addConstraint(typedArrayByteLengthNotEqual(length));
    }
    byteLengthRange(start, endBefore) {
      return this.addConstraint(typedArrayByteLengthRange(start, endBefore));
    }
    byteLengthRangeInclusive(startAt, endAt) {
      return this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt));
    }
    byteLengthRangeExclusive(startAfter, endBefore) {
      return this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore));
    }
    lengthLessThan(length) {
      return this.addConstraint(typedArrayLengthLessThan(length));
    }
    lengthLessThanOrEqual(length) {
      return this.addConstraint(typedArrayLengthLessThanOrEqual(length));
    }
    lengthGreaterThan(length) {
      return this.addConstraint(typedArrayLengthGreaterThan(length));
    }
    lengthGreaterThanOrEqual(length) {
      return this.addConstraint(typedArrayLengthGreaterThanOrEqual(length));
    }
    lengthEqual(length) {
      return this.addConstraint(typedArrayLengthEqual(length));
    }
    lengthNotEqual(length) {
      return this.addConstraint(typedArrayLengthNotEqual(length));
    }
    lengthRange(start, endBefore) {
      return this.addConstraint(typedArrayLengthRange(start, endBefore));
    }
    lengthRangeInclusive(startAt, endAt) {
      return this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt));
    }
    lengthRangeExclusive(startAfter, endBefore) {
      return this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.type, this.constraints]);
    }
    handle(value) {
      return TypedArrays[this.type](value) ? Result.ok(value) : Result.err(new ValidationError("s.typedArray", `Expected ${aOrAn(this.type)}`, value));
    }
  };
  __name(_TypedArrayValidator, "TypedArrayValidator");
  var TypedArrayValidator = _TypedArrayValidator;
  var _Shapes = class _Shapes2 {
    get string() {
      return new StringValidator;
    }
    get number() {
      return new NumberValidator;
    }
    get bigint() {
      return new BigIntValidator;
    }
    get boolean() {
      return new BooleanValidator;
    }
    get date() {
      return new DateValidator;
    }
    object(shape) {
      return new ObjectValidator(shape);
    }
    get undefined() {
      return this.literal(undefined);
    }
    get null() {
      return this.literal(null);
    }
    get nullish() {
      return new NullishValidator;
    }
    get any() {
      return new PassthroughValidator;
    }
    get unknown() {
      return new PassthroughValidator;
    }
    get never() {
      return new NeverValidator;
    }
    enum(...values) {
      return this.union(...values.map((value) => this.literal(value)));
    }
    nativeEnum(enumShape) {
      return new NativeEnumValidator(enumShape);
    }
    literal(value) {
      if (value instanceof Date)
        return this.date.equal(value);
      return new LiteralValidator(value);
    }
    instance(expected) {
      return new InstanceValidator(expected);
    }
    union(...validators) {
      return new UnionValidator(validators);
    }
    array(validator) {
      return new ArrayValidator(validator);
    }
    typedArray(type = "TypedArray") {
      return new TypedArrayValidator(type);
    }
    get int8Array() {
      return this.typedArray("Int8Array");
    }
    get uint8Array() {
      return this.typedArray("Uint8Array");
    }
    get uint8ClampedArray() {
      return this.typedArray("Uint8ClampedArray");
    }
    get int16Array() {
      return this.typedArray("Int16Array");
    }
    get uint16Array() {
      return this.typedArray("Uint16Array");
    }
    get int32Array() {
      return this.typedArray("Int32Array");
    }
    get uint32Array() {
      return this.typedArray("Uint32Array");
    }
    get float32Array() {
      return this.typedArray("Float32Array");
    }
    get float64Array() {
      return this.typedArray("Float64Array");
    }
    get bigInt64Array() {
      return this.typedArray("BigInt64Array");
    }
    get bigUint64Array() {
      return this.typedArray("BigUint64Array");
    }
    tuple(validators) {
      return new TupleValidator(validators);
    }
    set(validator) {
      return new SetValidator(validator);
    }
    record(validator) {
      return new RecordValidator(validator);
    }
    map(keyValidator, valueValidator) {
      return new MapValidator(keyValidator, valueValidator);
    }
    lazy(validator) {
      return new LazyValidator(validator);
    }
  };
  __name(_Shapes, "Shapes");
  var Shapes = _Shapes;
  var s3 = new Shapes;
  exports.BaseError = BaseError;
  exports.CombinedError = CombinedError;
  exports.CombinedPropertyError = CombinedPropertyError;
  exports.ExpectedConstraintError = ExpectedConstraintError;
  exports.ExpectedValidationError = ExpectedValidationError;
  exports.MissingPropertyError = MissingPropertyError;
  exports.MultiplePossibilitiesConstraintError = MultiplePossibilitiesConstraintError;
  exports.Result = Result;
  exports.UnknownEnumValueError = UnknownEnumValueError;
  exports.UnknownPropertyError = UnknownPropertyError;
  exports.ValidationError = ValidationError;
  exports.customInspectSymbol = customInspectSymbol;
  exports.customInspectSymbolStackLess = customInspectSymbolStackLess;
  exports.getGlobalValidationEnabled = getGlobalValidationEnabled;
  exports.s = s3;
  exports.setGlobalValidationEnabled = setGlobalValidationEnabled;
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/ts-mixer/dist/cjs/util.js
var require_util8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flatten = exports.unique = exports.hardMixProtos = exports.nearestCommonProto = exports.protoChain = exports.copyProps = undefined;
  var copyProps = (dest, src, exclude = []) => {
    const props = Object.getOwnPropertyDescriptors(src);
    for (let prop of exclude)
      delete props[prop];
    Object.defineProperties(dest, props);
  };
  exports.copyProps = copyProps;
  var protoChain = (obj, currentChain = [obj]) => {
    const proto = Object.getPrototypeOf(obj);
    if (proto === null)
      return currentChain;
    return (0, exports.protoChain)(proto, [...currentChain, proto]);
  };
  exports.protoChain = protoChain;
  var nearestCommonProto = (...objs) => {
    if (objs.length === 0)
      return;
    let commonProto = undefined;
    const protoChains = objs.map((obj) => (0, exports.protoChain)(obj));
    while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
      const protos = protoChains.map((protoChain2) => protoChain2.pop());
      const potentialCommonProto = protos[0];
      if (protos.every((proto) => proto === potentialCommonProto))
        commonProto = potentialCommonProto;
      else
        break;
    }
    return commonProto;
  };
  exports.nearestCommonProto = nearestCommonProto;
  var hardMixProtos = (ingredients, constructor, exclude = []) => {
    var _a;
    const base = (_a = (0, exports.nearestCommonProto)(...ingredients)) !== null && _a !== undefined ? _a : Object.prototype;
    const mixedProto = Object.create(base);
    const visitedProtos = (0, exports.protoChain)(base);
    for (let prototype of ingredients) {
      let protos = (0, exports.protoChain)(prototype);
      for (let i = protos.length - 1;i >= 0; i--) {
        let newProto = protos[i];
        if (visitedProtos.indexOf(newProto) === -1) {
          (0, exports.copyProps)(mixedProto, newProto, ["constructor", ...exclude]);
          visitedProtos.push(newProto);
        }
      }
    }
    mixedProto.constructor = constructor;
    return mixedProto;
  };
  exports.hardMixProtos = hardMixProtos;
  var unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
  exports.unique = unique;
  var flatten = (arr) => arr.length === 0 ? [] : arr.length === 1 ? arr[0] : arr.reduce((a1, a2) => [...a1, ...a2]);
  exports.flatten = flatten;
});

// node_modules/ts-mixer/dist/cjs/proxy.js
var require_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.softMixProtos = exports.proxyMix = exports.getIngredientWithProp = undefined;
  var util_1 = require_util8();
  var getIngredientWithProp = (prop, ingredients) => {
    const protoChains = ingredients.map((ingredient) => (0, util_1.protoChain)(ingredient));
    let protoDepth = 0;
    let protosAreLeftToSearch = true;
    while (protosAreLeftToSearch) {
      protosAreLeftToSearch = false;
      for (let i = ingredients.length - 1;i >= 0; i--) {
        const searchTarget = protoChains[i][protoDepth];
        if (searchTarget !== undefined && searchTarget !== null) {
          protosAreLeftToSearch = true;
          if (Object.getOwnPropertyDescriptor(searchTarget, prop) != null) {
            return protoChains[i][0];
          }
        }
      }
      protoDepth++;
    }
    return;
  };
  exports.getIngredientWithProp = getIngredientWithProp;
  var proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
    getPrototypeOf() {
      return prototype;
    },
    setPrototypeOf() {
      throw Error("Cannot set prototype of Proxies created by ts-mixer");
    },
    getOwnPropertyDescriptor(_, prop) {
      return Object.getOwnPropertyDescriptor((0, exports.getIngredientWithProp)(prop, ingredients) || {}, prop);
    },
    defineProperty() {
      throw new Error("Cannot define new properties on Proxies created by ts-mixer");
    },
    has(_, prop) {
      return (0, exports.getIngredientWithProp)(prop, ingredients) !== undefined || prototype[prop] !== undefined;
    },
    get(_, prop) {
      return ((0, exports.getIngredientWithProp)(prop, ingredients) || prototype)[prop];
    },
    set(_, prop, val) {
      const ingredientWithProp = (0, exports.getIngredientWithProp)(prop, ingredients);
      if (ingredientWithProp === undefined)
        throw new Error("Cannot set new properties on Proxies created by ts-mixer");
      ingredientWithProp[prop] = val;
      return true;
    },
    deleteProperty() {
      throw new Error("Cannot delete properties on Proxies created by ts-mixer");
    },
    ownKeys() {
      return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
    }
  });
  exports.proxyMix = proxyMix;
  var softMixProtos = (ingredients, constructor) => (0, exports.proxyMix)([...ingredients, { constructor }]);
  exports.softMixProtos = softMixProtos;
});

// node_modules/ts-mixer/dist/cjs/settings.js
var require_settings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.settings = undefined;
  exports.settings = {
    initFunction: null,
    staticsStrategy: "copy",
    prototypeStrategy: "copy",
    decoratorInheritance: "deep"
  };
});

// node_modules/ts-mixer/dist/cjs/mixin-tracking.js
var require_mixin_tracking = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMixin = exports.registerMixins = exports.getMixinsForClass = undefined;
  var util_1 = require_util8();
  var mixins = new Map;
  var getMixinsForClass = (clazz) => mixins.get(clazz);
  exports.getMixinsForClass = getMixinsForClass;
  var registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
  exports.registerMixins = registerMixins;
  var hasMixin = (instance, mixin) => {
    if (instance instanceof mixin)
      return true;
    const constructor = instance.constructor;
    const visited = new Set;
    let frontier = new Set;
    frontier.add(constructor);
    while (frontier.size > 0) {
      if (frontier.has(mixin))
        return true;
      frontier.forEach((item) => visited.add(item));
      const newFrontier = new Set;
      frontier.forEach((item) => {
        var _a;
        const itemConstituents = (_a = mixins.get(item)) !== null && _a !== undefined ? _a : (0, util_1.protoChain)(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
        if (itemConstituents)
          itemConstituents.forEach((constituent) => {
            if (!visited.has(constituent) && !frontier.has(constituent))
              newFrontier.add(constituent);
          });
      });
      frontier = newFrontier;
    }
    return false;
  };
  exports.hasMixin = hasMixin;
});

// node_modules/ts-mixer/dist/cjs/decorator.js
var require_decorator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decorate = exports.getDecoratorsForClass = exports.directDecoratorSearch = exports.deepDecoratorSearch = undefined;
  var util_1 = require_util8();
  var mixin_tracking_1 = require_mixin_tracking();
  var mergeObjectsOfDecorators = (o1, o2) => {
    var _a, _b;
    const allKeys = (0, util_1.unique)([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
    const mergedObject = {};
    for (let key of allKeys)
      mergedObject[key] = (0, util_1.unique)([...(_a = o1 === null || o1 === undefined ? undefined : o1[key]) !== null && _a !== undefined ? _a : [], ...(_b = o2 === null || o2 === undefined ? undefined : o2[key]) !== null && _b !== undefined ? _b : []]);
    return mergedObject;
  };
  var mergePropertyAndMethodDecorators = (d1, d2) => {
    var _a, _b, _c, _d;
    return {
      property: mergeObjectsOfDecorators((_a = d1 === null || d1 === undefined ? undefined : d1.property) !== null && _a !== undefined ? _a : {}, (_b = d2 === null || d2 === undefined ? undefined : d2.property) !== null && _b !== undefined ? _b : {}),
      method: mergeObjectsOfDecorators((_c = d1 === null || d1 === undefined ? undefined : d1.method) !== null && _c !== undefined ? _c : {}, (_d = d2 === null || d2 === undefined ? undefined : d2.method) !== null && _d !== undefined ? _d : {})
    };
  };
  var mergeDecorators = (d1, d2) => {
    var _a, _b, _c, _d, _e, _f;
    return {
      class: (0, util_1.unique)([...(_a = d1 === null || d1 === undefined ? undefined : d1.class) !== null && _a !== undefined ? _a : [], ...(_b = d2 === null || d2 === undefined ? undefined : d2.class) !== null && _b !== undefined ? _b : []]),
      static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === undefined ? undefined : d1.static) !== null && _c !== undefined ? _c : {}, (_d = d2 === null || d2 === undefined ? undefined : d2.static) !== null && _d !== undefined ? _d : {}),
      instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === undefined ? undefined : d1.instance) !== null && _e !== undefined ? _e : {}, (_f = d2 === null || d2 === undefined ? undefined : d2.instance) !== null && _f !== undefined ? _f : {})
    };
  };
  var decorators = new Map;
  var findAllConstituentClasses = (...classes) => {
    var _a;
    const allClasses = new Set;
    const frontier = new Set([...classes]);
    while (frontier.size > 0) {
      for (let clazz of frontier) {
        const protoChainClasses = (0, util_1.protoChain)(clazz.prototype).map((proto) => proto.constructor);
        const mixinClasses = (_a = (0, mixin_tracking_1.getMixinsForClass)(clazz)) !== null && _a !== undefined ? _a : [];
        const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
        const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
        for (let newClass of newClasses)
          frontier.add(newClass);
        allClasses.add(clazz);
        frontier.delete(clazz);
      }
    }
    return [...allClasses];
  };
  var deepDecoratorSearch = (...classes) => {
    const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
    if (decoratorsForClassChain.length == 0)
      return {};
    if (decoratorsForClassChain.length == 1)
      return decoratorsForClassChain[0];
    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
  };
  exports.deepDecoratorSearch = deepDecoratorSearch;
  var directDecoratorSearch = (...classes) => {
    const classDecorators = classes.map((clazz) => (0, exports.getDecoratorsForClass)(clazz));
    if (classDecorators.length === 0)
      return {};
    if (classDecorators.length === 1)
      return classDecorators[0];
    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
  };
  exports.directDecoratorSearch = directDecoratorSearch;
  var getDecoratorsForClass = (clazz) => {
    let decoratorsForClass = decorators.get(clazz);
    if (!decoratorsForClass) {
      decoratorsForClass = {};
      decorators.set(clazz, decoratorsForClass);
    }
    return decoratorsForClass;
  };
  exports.getDecoratorsForClass = getDecoratorsForClass;
  var decorateClass = (decorator) => (clazz) => {
    const decoratorsForClass = (0, exports.getDecoratorsForClass)(clazz);
    let classDecorators = decoratorsForClass.class;
    if (!classDecorators) {
      classDecorators = [];
      decoratorsForClass.class = classDecorators;
    }
    classDecorators.push(decorator);
    return decorator(clazz);
  };
  var decorateMember = (decorator) => (object, key, ...otherArgs) => {
    var _a, _b, _c;
    const decoratorTargetType = typeof object === "function" ? "static" : "instance";
    const decoratorType = typeof object[key] === "function" ? "method" : "property";
    const clazz = decoratorTargetType === "static" ? object : object.constructor;
    const decoratorsForClass = (0, exports.getDecoratorsForClass)(clazz);
    const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === undefined ? undefined : decoratorsForClass[decoratorTargetType]) !== null && _a !== undefined ? _a : {};
    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
    let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === undefined ? undefined : decoratorsForTargetType[decoratorType]) !== null && _b !== undefined ? _b : {};
    decoratorsForTargetType[decoratorType] = decoratorsForType;
    let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === undefined ? undefined : decoratorsForType[key]) !== null && _c !== undefined ? _c : [];
    decoratorsForType[key] = decoratorsForKey;
    decoratorsForKey.push(decorator);
    return decorator(object, key, ...otherArgs);
  };
  var decorate = (decorator) => (...args) => {
    if (args.length === 1)
      return decorateClass(decorator)(args[0]);
    return decorateMember(decorator)(...args);
  };
  exports.decorate = decorate;
});

// node_modules/ts-mixer/dist/cjs/mixins.js
var require_mixins = __commonJS((exports) => {
  var Mixin = function(...constructors) {
    var _a, _b, _c;
    const prototypes = constructors.map((constructor) => constructor.prototype);
    const initFunctionName = settings_1.settings.initFunction;
    if (initFunctionName !== null) {
      const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
      const combinedInitFunction = function(...args) {
        for (let initFunction of initFunctions)
          initFunction.apply(this, args);
      };
      const extraProto = { [initFunctionName]: combinedInitFunction };
      prototypes.push(extraProto);
    }
    function MixedClass(...args) {
      for (const constructor of constructors)
        (0, util_1.copyProps)(this, new constructor(...args));
      if (initFunctionName !== null && typeof this[initFunctionName] === "function")
        this[initFunctionName].apply(this, args);
    }
    MixedClass.prototype = settings_1.settings.prototypeStrategy === "copy" ? (0, util_1.hardMixProtos)(prototypes, MixedClass) : (0, proxy_1.softMixProtos)(prototypes, MixedClass);
    Object.setPrototypeOf(MixedClass, settings_1.settings.staticsStrategy === "copy" ? (0, util_1.hardMixProtos)(constructors, null, ["prototype"]) : (0, proxy_1.proxyMix)(constructors, Function.prototype));
    let DecoratedMixedClass = MixedClass;
    if (settings_1.settings.decoratorInheritance !== "none") {
      const classDecorators = settings_1.settings.decoratorInheritance === "deep" ? (0, decorator_1.deepDecoratorSearch)(...constructors) : (0, decorator_1.directDecoratorSearch)(...constructors);
      for (let decorator of (_a = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.class) !== null && _a !== undefined ? _a : []) {
        const result = decorator(DecoratedMixedClass);
        if (result) {
          DecoratedMixedClass = result;
        }
      }
      applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.static) !== null && _b !== undefined ? _b : {}, DecoratedMixedClass);
      applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.instance) !== null && _c !== undefined ? _c : {}, DecoratedMixedClass.prototype);
    }
    (0, mixin_tracking_1.registerMixins)(DecoratedMixedClass, constructors);
    return DecoratedMixedClass;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mix = exports.Mixin = undefined;
  var proxy_1 = require_proxy();
  var settings_1 = require_settings();
  var util_1 = require_util8();
  var decorator_1 = require_decorator();
  var mixin_tracking_1 = require_mixin_tracking();
  exports.Mixin = Mixin;
  var applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
    const propDecorators = propAndMethodDecorators.property;
    const methodDecorators = propAndMethodDecorators.method;
    if (propDecorators)
      for (let key in propDecorators)
        for (let decorator of propDecorators[key])
          decorator(target, key);
    if (methodDecorators)
      for (let key in methodDecorators)
        for (let decorator of methodDecorators[key])
          decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
  };
  var mix = (...ingredients) => (decoratedClass) => {
    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
    Object.defineProperty(mixedClass, "name", {
      value: decoratedClass.name,
      writable: false
    });
    return mixedClass;
  };
  exports.mix = mix;
});

// node_modules/ts-mixer/dist/cjs/index.js
var require_cjs3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMixin = exports.decorate = exports.settings = exports.mix = exports.Mixin = undefined;
  var mixins_1 = require_mixins();
  Object.defineProperty(exports, "Mixin", { enumerable: true, get: function() {
    return mixins_1.Mixin;
  } });
  Object.defineProperty(exports, "mix", { enumerable: true, get: function() {
    return mixins_1.mix;
  } });
  var settings_1 = require_settings();
  Object.defineProperty(exports, "settings", { enumerable: true, get: function() {
    return settings_1.settings;
  } });
  var decorator_1 = require_decorator();
  Object.defineProperty(exports, "decorate", { enumerable: true, get: function() {
    return decorator_1.decorate;
  } });
  var mixin_tracking_1 = require_mixin_tracking();
  Object.defineProperty(exports, "hasMixin", { enumerable: true, get: function() {
    return mixin_tracking_1.hasMixin;
  } });
});

// node_modules/@discordjs/builders/dist/index.js
var require_dist9 = __commonJS((exports, module) => {
  var enableValidators = function() {
    return validate = true;
  };
  var disableValidators = function() {
    return validate = false;
  };
  var isValidationEnabled = function() {
    return validate;
  };
  var validateFieldLength = function(amountAdding, fields) {
    fieldLengthPredicate.parse((fields?.length ?? 0) + amountAdding);
  };
  var normalizeArray = function(arr) {
    if (Array.isArray(arr[0]))
      return arr[0];
    return arr;
  };
  var validateRequiredSelectMenuParameters = function(options, customId) {
    customIdValidator.parse(customId);
    optionsValidator.parse(options);
  };
  var validateRequiredSelectMenuOptionParameters = function(label, value) {
    labelValueDescriptionValidator.parse(label);
    labelValueDescriptionValidator.parse(value);
  };
  var validateRequiredButtonParameters = function(style, label, emoji, customId, url) {
    if (url && customId) {
      throw new RangeError("URL and custom id are mutually exclusive");
    }
    if (!label && !emoji) {
      throw new RangeError("Buttons must have a label and/or an emoji");
    }
    if (style === import_v10.ButtonStyle.Link) {
      if (!url) {
        throw new RangeError("Link buttons must have a url");
      }
    } else if (url) {
      throw new RangeError("Non-link buttons cannot have a url");
    }
  };
  var validateRequiredParameters = function(customId, style, label) {
    customIdValidator.parse(customId);
    textInputStyleValidator.parse(style);
    labelValidator.parse(label);
  };
  var createComponentBuilder = function(data) {
    if (data instanceof ComponentBuilder) {
      return data;
    }
    switch (data.type) {
      case import_v1010.ComponentType.ActionRow:
        return new ActionRowBuilder(data);
      case import_v1010.ComponentType.Button:
        return new ButtonBuilder(data);
      case import_v1010.ComponentType.StringSelect:
        return new StringSelectMenuBuilder(data);
      case import_v1010.ComponentType.TextInput:
        return new TextInputBuilder(data);
      case import_v1010.ComponentType.UserSelect:
        return new UserSelectMenuBuilder(data);
      case import_v1010.ComponentType.RoleSelect:
        return new RoleSelectMenuBuilder(data);
      case import_v1010.ComponentType.MentionableSelect:
        return new MentionableSelectMenuBuilder(data);
      case import_v1010.ComponentType.ChannelSelect:
        return new ChannelSelectMenuBuilder(data);
      default:
        throw new Error(`Cannot properly serialize component type: ${data.type}`);
    }
  };
  var validateRequiredParameters2 = function(customId, title, components) {
    customIdValidator.parse(customId);
    titleValidator.parse(title);
    componentsValidator.parse(components);
  };
  var validateName = function(name) {
    namePredicate.parse(name);
  };
  var validateDescription = function(description) {
    descriptionPredicate2.parse(description);
  };
  var validateLocale = function(locale) {
    return localePredicate.parse(locale);
  };
  var validateMaxOptionsLength = function(options) {
    maxArrayLengthPredicate.parse(options);
  };
  var validateRequiredParameters3 = function(name, description, options) {
    validateName(name);
    validateDescription(description);
    validateMaxOptionsLength(options);
  };
  var validateDefaultPermission = function(value) {
    booleanPredicate.parse(value);
  };
  var validateRequired = function(required) {
    booleanPredicate.parse(required);
  };
  var validateChoicesLength = function(amountAdding, choices) {
    choicesLengthPredicate.parse((choices?.length ?? 0) + amountAdding);
  };
  var assertReturnOfBuilder = function(input, ExpectedInstanceOf) {
    import_shapeshift5.s.instance(ExpectedInstanceOf).parse(input);
  };
  var validateLocalizationMap = function(value) {
    localizationMapPredicate.parse(value);
  };
  var validateDMPermission = function(value) {
    dmPermissionPredicate.parse(value);
  };
  var validateDefaultMemberPermissions = function(permissions) {
    return memberPermissionPredicate.parse(permissions);
  };
  var validateNSFW = function(value) {
    booleanPredicate.parse(value);
  };
  var validateDefaultPermission2 = function(value) {
    booleanPredicate3.parse(value);
  };
  var validateName2 = function(name) {
    namePredicate2.parse(name);
  };
  var validateType = function(type) {
    typePredicate.parse(type);
  };
  var validateRequiredParameters4 = function(name, type) {
    validateName2(name);
    validateType(type);
  };
  var validateDMPermission2 = function(value) {
    dmPermissionPredicate2.parse(value);
  };
  var validateDefaultMemberPermissions2 = function(permissions) {
    return memberPermissionPredicate2.parse(permissions);
  };
  var embedLength = function(data) {
    return (data.title?.length ?? 0) + (data.description?.length ?? 0) + (data.fields?.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0) ?? 0) + (data.footer?.text.length ?? 0) + (data.author?.name.length ?? 0);
  };
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? undefined : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator;i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp2(target, key, result);
    return result;
  };
  var src_exports = {};
  __export2(src_exports, {
    ActionRowBuilder: () => ActionRowBuilder,
    ApplicationCommandNumericOptionMinMaxValueMixin: () => ApplicationCommandNumericOptionMinMaxValueMixin,
    ApplicationCommandOptionBase: () => ApplicationCommandOptionBase,
    ApplicationCommandOptionChannelTypesMixin: () => ApplicationCommandOptionChannelTypesMixin,
    ApplicationCommandOptionWithChoicesAndAutocompleteMixin: () => ApplicationCommandOptionWithChoicesAndAutocompleteMixin,
    BaseSelectMenuBuilder: () => BaseSelectMenuBuilder,
    ButtonBuilder: () => ButtonBuilder,
    ChannelSelectMenuBuilder: () => ChannelSelectMenuBuilder,
    ComponentAssertions: () => Assertions_exports2,
    ComponentBuilder: () => ComponentBuilder,
    ContextMenuCommandAssertions: () => Assertions_exports6,
    ContextMenuCommandBuilder: () => ContextMenuCommandBuilder,
    EmbedAssertions: () => Assertions_exports,
    EmbedBuilder: () => EmbedBuilder,
    MentionableSelectMenuBuilder: () => MentionableSelectMenuBuilder,
    ModalAssertions: () => Assertions_exports4,
    ModalBuilder: () => ModalBuilder,
    RoleSelectMenuBuilder: () => RoleSelectMenuBuilder,
    SelectMenuBuilder: () => StringSelectMenuBuilder,
    SelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
    SharedNameAndDescription: () => SharedNameAndDescription,
    SharedSlashCommandOptions: () => SharedSlashCommandOptions,
    SlashCommandAssertions: () => Assertions_exports5,
    SlashCommandAttachmentOption: () => SlashCommandAttachmentOption,
    SlashCommandBooleanOption: () => SlashCommandBooleanOption,
    SlashCommandBuilder: () => SlashCommandBuilder,
    SlashCommandChannelOption: () => SlashCommandChannelOption,
    SlashCommandIntegerOption: () => SlashCommandIntegerOption,
    SlashCommandMentionableOption: () => SlashCommandMentionableOption,
    SlashCommandNumberOption: () => SlashCommandNumberOption,
    SlashCommandRoleOption: () => SlashCommandRoleOption,
    SlashCommandStringOption: () => SlashCommandStringOption,
    SlashCommandSubcommandBuilder: () => SlashCommandSubcommandBuilder,
    SlashCommandSubcommandGroupBuilder: () => SlashCommandSubcommandGroupBuilder,
    SlashCommandUserOption: () => SlashCommandUserOption,
    StringSelectMenuBuilder: () => StringSelectMenuBuilder,
    StringSelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
    TextInputAssertions: () => Assertions_exports3,
    TextInputBuilder: () => TextInputBuilder,
    UserSelectMenuBuilder: () => UserSelectMenuBuilder,
    createComponentBuilder: () => createComponentBuilder,
    disableValidators: () => disableValidators,
    embedLength: () => embedLength,
    enableValidators: () => enableValidators,
    isValidationEnabled: () => isValidationEnabled,
    normalizeArray: () => normalizeArray,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Assertions_exports = {};
  __export2(Assertions_exports, {
    RGBPredicate: () => RGBPredicate,
    authorNamePredicate: () => authorNamePredicate,
    colorPredicate: () => colorPredicate,
    descriptionPredicate: () => descriptionPredicate,
    embedAuthorPredicate: () => embedAuthorPredicate,
    embedFieldPredicate: () => embedFieldPredicate,
    embedFieldsArrayPredicate: () => embedFieldsArrayPredicate,
    embedFooterPredicate: () => embedFooterPredicate,
    fieldInlinePredicate: () => fieldInlinePredicate,
    fieldLengthPredicate: () => fieldLengthPredicate,
    fieldNamePredicate: () => fieldNamePredicate,
    fieldValuePredicate: () => fieldValuePredicate,
    footerTextPredicate: () => footerTextPredicate,
    imageURLPredicate: () => imageURLPredicate,
    timestampPredicate: () => timestampPredicate,
    titlePredicate: () => titlePredicate,
    urlPredicate: () => urlPredicate,
    validateFieldLength: () => validateFieldLength
  });
  var import_shapeshift = require_cjs2();
  var validate = true;
  __name(enableValidators, "enableValidators");
  __name(disableValidators, "disableValidators");
  __name(isValidationEnabled, "isValidationEnabled");
  var fieldNamePredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(256).setValidationEnabled(isValidationEnabled);
  var fieldValuePredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(1024).setValidationEnabled(isValidationEnabled);
  var fieldInlinePredicate = import_shapeshift.s.boolean.optional;
  var embedFieldPredicate = import_shapeshift.s.object({
    name: fieldNamePredicate,
    value: fieldValuePredicate,
    inline: fieldInlinePredicate
  }).setValidationEnabled(isValidationEnabled);
  var embedFieldsArrayPredicate = embedFieldPredicate.array.setValidationEnabled(isValidationEnabled);
  var fieldLengthPredicate = import_shapeshift.s.number.lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateFieldLength, "validateFieldLength");
  var authorNamePredicate = fieldNamePredicate.nullable.setValidationEnabled(isValidationEnabled);
  var imageURLPredicate = import_shapeshift.s.string.url({
    allowedProtocols: ["http:", "https:", "attachment:"]
  }).nullish.setValidationEnabled(isValidationEnabled);
  var urlPredicate = import_shapeshift.s.string.url({
    allowedProtocols: ["http:", "https:"]
  }).nullish.setValidationEnabled(isValidationEnabled);
  var embedAuthorPredicate = import_shapeshift.s.object({
    name: authorNamePredicate,
    iconURL: imageURLPredicate,
    url: urlPredicate
  }).setValidationEnabled(isValidationEnabled);
  var RGBPredicate = import_shapeshift.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(255).setValidationEnabled(isValidationEnabled);
  var colorPredicate = import_shapeshift.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(16777215).or(import_shapeshift.s.tuple([RGBPredicate, RGBPredicate, RGBPredicate])).nullable.setValidationEnabled(isValidationEnabled);
  var descriptionPredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(4096).nullable.setValidationEnabled(isValidationEnabled);
  var footerTextPredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(2048).nullable.setValidationEnabled(isValidationEnabled);
  var embedFooterPredicate = import_shapeshift.s.object({
    text: footerTextPredicate,
    iconURL: imageURLPredicate
  }).setValidationEnabled(isValidationEnabled);
  var timestampPredicate = import_shapeshift.s.union(import_shapeshift.s.number, import_shapeshift.s.date).nullable.setValidationEnabled(isValidationEnabled);
  var titlePredicate = fieldNamePredicate.nullable.setValidationEnabled(isValidationEnabled);
  __name(normalizeArray, "normalizeArray");
  var EmbedBuilder = class {
    static {
      __name(this, "EmbedBuilder");
    }
    data;
    constructor(data = {}) {
      this.data = { ...data };
      if (data.timestamp)
        this.data.timestamp = new Date(data.timestamp).toISOString();
    }
    addFields(...fields) {
      const normalizedFields = normalizeArray(fields);
      validateFieldLength(normalizedFields.length, this.data.fields);
      embedFieldsArrayPredicate.parse(normalizedFields);
      if (this.data.fields)
        this.data.fields.push(...normalizedFields);
      else
        this.data.fields = normalizedFields;
      return this;
    }
    spliceFields(index, deleteCount, ...fields) {
      validateFieldLength(fields.length - deleteCount, this.data.fields);
      embedFieldsArrayPredicate.parse(fields);
      if (this.data.fields)
        this.data.fields.splice(index, deleteCount, ...fields);
      else
        this.data.fields = fields;
      return this;
    }
    setFields(...fields) {
      this.spliceFields(0, this.data.fields?.length ?? 0, ...normalizeArray(fields));
      return this;
    }
    setAuthor(options) {
      if (options === null) {
        this.data.author = undefined;
        return this;
      }
      embedAuthorPredicate.parse(options);
      this.data.author = { name: options.name, url: options.url, icon_url: options.iconURL };
      return this;
    }
    setColor(color) {
      colorPredicate.parse(color);
      if (Array.isArray(color)) {
        const [red, green, blue] = color;
        this.data.color = (red << 16) + (green << 8) + blue;
        return this;
      }
      this.data.color = color ?? undefined;
      return this;
    }
    setDescription(description) {
      descriptionPredicate.parse(description);
      this.data.description = description ?? undefined;
      return this;
    }
    setFooter(options) {
      if (options === null) {
        this.data.footer = undefined;
        return this;
      }
      embedFooterPredicate.parse(options);
      this.data.footer = { text: options.text, icon_url: options.iconURL };
      return this;
    }
    setImage(url) {
      imageURLPredicate.parse(url);
      this.data.image = url ? { url } : undefined;
      return this;
    }
    setThumbnail(url) {
      imageURLPredicate.parse(url);
      this.data.thumbnail = url ? { url } : undefined;
      return this;
    }
    setTimestamp(timestamp = Date.now()) {
      timestampPredicate.parse(timestamp);
      this.data.timestamp = timestamp ? new Date(timestamp).toISOString() : undefined;
      return this;
    }
    setTitle(title) {
      titlePredicate.parse(title);
      this.data.title = title ?? undefined;
      return this;
    }
    setURL(url) {
      urlPredicate.parse(url);
      this.data.url = url ?? undefined;
      return this;
    }
    toJSON() {
      return { ...this.data };
    }
  };
  __reExport(src_exports, require_dist8(), module.exports);
  var Assertions_exports2 = {};
  __export2(Assertions_exports2, {
    buttonLabelValidator: () => buttonLabelValidator,
    buttonStyleValidator: () => buttonStyleValidator,
    channelTypesValidator: () => channelTypesValidator,
    customIdValidator: () => customIdValidator,
    defaultValidator: () => defaultValidator,
    disabledValidator: () => disabledValidator,
    emojiValidator: () => emojiValidator,
    jsonOptionValidator: () => jsonOptionValidator,
    labelValueDescriptionValidator: () => labelValueDescriptionValidator,
    minMaxValidator: () => minMaxValidator,
    optionValidator: () => optionValidator,
    optionsLengthValidator: () => optionsLengthValidator,
    optionsValidator: () => optionsValidator,
    placeholderValidator: () => placeholderValidator,
    urlValidator: () => urlValidator,
    validateRequiredButtonParameters: () => validateRequiredButtonParameters,
    validateRequiredSelectMenuOptionParameters: () => validateRequiredSelectMenuOptionParameters,
    validateRequiredSelectMenuParameters: () => validateRequiredSelectMenuParameters
  });
  var import_shapeshift2 = require_cjs2();
  var import_v10 = require_v106();
  var StringSelectMenuOptionBuilder = class {
    constructor(data = {}) {
      this.data = data;
    }
    static {
      __name(this, "StringSelectMenuOptionBuilder");
    }
    setLabel(label) {
      this.data.label = labelValueDescriptionValidator.parse(label);
      return this;
    }
    setValue(value) {
      this.data.value = labelValueDescriptionValidator.parse(value);
      return this;
    }
    setDescription(description) {
      this.data.description = labelValueDescriptionValidator.parse(description);
      return this;
    }
    setDefault(isDefault = true) {
      this.data.default = defaultValidator.parse(isDefault);
      return this;
    }
    setEmoji(emoji) {
      this.data.emoji = emojiValidator.parse(emoji);
      return this;
    }
    toJSON() {
      validateRequiredSelectMenuOptionParameters(this.data.label, this.data.value);
      return {
        ...this.data
      };
    }
  };
  var customIdValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var emojiValidator = import_shapeshift2.s.object({
    id: import_shapeshift2.s.string,
    name: import_shapeshift2.s.string,
    animated: import_shapeshift2.s.boolean
  }).partial.strict.setValidationEnabled(isValidationEnabled);
  var disabledValidator = import_shapeshift2.s.boolean;
  var buttonLabelValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(80).setValidationEnabled(isValidationEnabled);
  var buttonStyleValidator = import_shapeshift2.s.nativeEnum(import_v10.ButtonStyle);
  var placeholderValidator = import_shapeshift2.s.string.lengthLessThanOrEqual(150).setValidationEnabled(isValidationEnabled);
  var minMaxValidator = import_shapeshift2.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  var labelValueDescriptionValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var jsonOptionValidator = import_shapeshift2.s.object({
    label: labelValueDescriptionValidator,
    value: labelValueDescriptionValidator,
    description: labelValueDescriptionValidator.optional,
    emoji: emojiValidator.optional,
    default: import_shapeshift2.s.boolean.optional
  }).setValidationEnabled(isValidationEnabled);
  var optionValidator = import_shapeshift2.s.instance(StringSelectMenuOptionBuilder).setValidationEnabled(isValidationEnabled);
  var optionsValidator = optionValidator.array.lengthGreaterThanOrEqual(0).setValidationEnabled(isValidationEnabled);
  var optionsLengthValidator = import_shapeshift2.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredSelectMenuParameters, "validateRequiredSelectMenuParameters");
  var defaultValidator = import_shapeshift2.s.boolean;
  __name(validateRequiredSelectMenuOptionParameters, "validateRequiredSelectMenuOptionParameters");
  var channelTypesValidator = import_shapeshift2.s.nativeEnum(import_v10.ChannelType).array.setValidationEnabled(isValidationEnabled);
  var urlValidator = import_shapeshift2.s.string.url({
    allowedProtocols: ["http:", "https:", "discord:"]
  }).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredButtonParameters, "validateRequiredButtonParameters");
  var import_v1011 = require_v106();
  var ComponentBuilder = class {
    static {
      __name(this, "ComponentBuilder");
    }
    data;
    constructor(data) {
      this.data = data;
    }
  };
  var import_v1010 = require_v106();
  var import_v102 = require_v106();
  var ButtonBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ButtonBuilder");
    }
    constructor(data) {
      super({ type: import_v102.ComponentType.Button, ...data });
    }
    setStyle(style) {
      this.data.style = buttonStyleValidator.parse(style);
      return this;
    }
    setURL(url) {
      this.data.url = urlValidator.parse(url);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setEmoji(emoji) {
      this.data.emoji = emojiValidator.parse(emoji);
      return this;
    }
    setDisabled(disabled = true) {
      this.data.disabled = disabledValidator.parse(disabled);
      return this;
    }
    setLabel(label) {
      this.data.label = buttonLabelValidator.parse(label);
      return this;
    }
    toJSON() {
      validateRequiredButtonParameters(this.data.style, this.data.label, this.data.emoji, this.data.custom_id, this.data.url);
      return {
        ...this.data
      };
    }
  };
  var import_v103 = require_v106();
  var BaseSelectMenuBuilder = class extends ComponentBuilder {
    static {
      __name(this, "BaseSelectMenuBuilder");
    }
    setPlaceholder(placeholder) {
      this.data.placeholder = placeholderValidator.parse(placeholder);
      return this;
    }
    setMinValues(minValues) {
      this.data.min_values = minMaxValidator.parse(minValues);
      return this;
    }
    setMaxValues(maxValues) {
      this.data.max_values = minMaxValidator.parse(maxValues);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setDisabled(disabled = true) {
      this.data.disabled = disabledValidator.parse(disabled);
      return this;
    }
    toJSON() {
      customIdValidator.parse(this.data.custom_id);
      return {
        ...this.data
      };
    }
  };
  var ChannelSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "ChannelSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v103.ComponentType.ChannelSelect });
    }
    addChannelTypes(...types) {
      const normalizedTypes = normalizeArray(types);
      this.data.channel_types ??= [];
      this.data.channel_types.push(...channelTypesValidator.parse(normalizedTypes));
      return this;
    }
    setChannelTypes(...types) {
      const normalizedTypes = normalizeArray(types);
      this.data.channel_types ??= [];
      this.data.channel_types.splice(0, this.data.channel_types.length, ...channelTypesValidator.parse(normalizedTypes));
      return this;
    }
    addDefaultChannels(...channels) {
      const normalizedValues = normalizeArray(channels);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v103.SelectMenuDefaultValueType.Channel
      })));
      return this;
    }
    setDefaultChannels(...channels) {
      const normalizedValues = normalizeArray(channels);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v103.SelectMenuDefaultValueType.Channel
      }));
      return this;
    }
    toJSON() {
      customIdValidator.parse(this.data.custom_id);
      return {
        ...this.data
      };
    }
  };
  var import_v104 = require_v106();
  var MentionableSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "MentionableSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v104.ComponentType.MentionableSelect });
    }
    addDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v104.SelectMenuDefaultValueType.Role
      })));
      return this;
    }
    addDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v104.SelectMenuDefaultValueType.User
      })));
      return this;
    }
    addDefaultValues(...values) {
      const normalizedValues = normalizeArray(values);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues);
      return this;
    }
    setDefaultValues(...values) {
      const normalizedValues = normalizeArray(values);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.slice();
      return this;
    }
  };
  var import_v105 = require_v106();
  var RoleSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "RoleSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v105.ComponentType.RoleSelect });
    }
    addDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v105.SelectMenuDefaultValueType.Role
      })));
      return this;
    }
    setDefaultRoles(...roles) {
      const normalizedValues = normalizeArray(roles);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v105.SelectMenuDefaultValueType.Role
      }));
      return this;
    }
  };
  var import_v106 = require_v106();
  var StringSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "StringSelectMenuBuilder");
    }
    options;
    constructor(data) {
      const { options, ...initData } = data ?? {};
      super({ ...initData, type: import_v106.ComponentType.StringSelect });
      this.options = options?.map((option) => new StringSelectMenuOptionBuilder(option)) ?? [];
    }
    addOptions(...options) {
      const normalizedOptions = normalizeArray(options);
      optionsLengthValidator.parse(this.options.length + normalizedOptions.length);
      this.options.push(...normalizedOptions.map((normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))));
      return this;
    }
    setOptions(...options) {
      return this.spliceOptions(0, this.options.length, ...options);
    }
    spliceOptions(index, deleteCount, ...options) {
      const normalizedOptions = normalizeArray(options);
      const clone = [...this.options];
      clone.splice(index, deleteCount, ...normalizedOptions.map((normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))));
      optionsLengthValidator.parse(clone.length);
      this.options.splice(0, this.options.length, ...clone);
      return this;
    }
    toJSON() {
      validateRequiredSelectMenuParameters(this.options, this.data.custom_id);
      return {
        ...this.data,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  var import_v107 = require_v106();
  var UserSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "UserSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v107.ComponentType.UserSelect });
    }
    addDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse((this.data.default_values?.length ?? 0) + normalizedValues.length);
      this.data.default_values ??= [];
      this.data.default_values.push(...normalizedValues.map((id) => ({
        id,
        type: import_v107.SelectMenuDefaultValueType.User
      })));
      return this;
    }
    setDefaultUsers(...users) {
      const normalizedValues = normalizeArray(users);
      optionsLengthValidator.parse(normalizedValues.length);
      this.data.default_values = normalizedValues.map((id) => ({
        id,
        type: import_v107.SelectMenuDefaultValueType.User
      }));
      return this;
    }
  };
  var import_util = require_dist();
  var import_v109 = require_v106();
  var import_fast_deep_equal = __toESM2(require_fast_deep_equal());
  var Assertions_exports3 = {};
  __export2(Assertions_exports3, {
    labelValidator: () => labelValidator,
    maxLengthValidator: () => maxLengthValidator,
    minLengthValidator: () => minLengthValidator,
    placeholderValidator: () => placeholderValidator2,
    requiredValidator: () => requiredValidator,
    textInputStyleValidator: () => textInputStyleValidator,
    validateRequiredParameters: () => validateRequiredParameters,
    valueValidator: () => valueValidator
  });
  var import_shapeshift3 = require_cjs2();
  var import_v108 = require_v106();
  var textInputStyleValidator = import_shapeshift3.s.nativeEnum(import_v108.TextInputStyle);
  var minLengthValidator = import_shapeshift3.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var maxLengthValidator = import_shapeshift3.s.number.int.greaterThanOrEqual(1).lessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var requiredValidator = import_shapeshift3.s.boolean;
  var valueValidator = import_shapeshift3.s.string.lengthLessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var placeholderValidator2 = import_shapeshift3.s.string.lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var labelValidator = import_shapeshift3.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredParameters, "validateRequiredParameters");
  var TextInputBuilder = class extends ComponentBuilder {
    static {
      __name(this, "TextInputBuilder");
    }
    constructor(data) {
      super({ type: import_v109.ComponentType.TextInput, ...data });
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setLabel(label) {
      this.data.label = labelValidator.parse(label);
      return this;
    }
    setStyle(style) {
      this.data.style = textInputStyleValidator.parse(style);
      return this;
    }
    setMinLength(minLength) {
      this.data.min_length = minLengthValidator.parse(minLength);
      return this;
    }
    setMaxLength(maxLength) {
      this.data.max_length = maxLengthValidator.parse(maxLength);
      return this;
    }
    setPlaceholder(placeholder) {
      this.data.placeholder = placeholderValidator2.parse(placeholder);
      return this;
    }
    setValue(value) {
      this.data.value = valueValidator.parse(value);
      return this;
    }
    setRequired(required = true) {
      this.data.required = requiredValidator.parse(required);
      return this;
    }
    toJSON() {
      validateRequiredParameters(this.data.custom_id, this.data.style, this.data.label);
      return {
        ...this.data
      };
    }
    equals(other) {
      if ((0, import_util.isJSONEncodable)(other)) {
        return (0, import_fast_deep_equal.default)(other.toJSON(), this.data);
      }
      return (0, import_fast_deep_equal.default)(other, this.data);
    }
  };
  __name(createComponentBuilder, "createComponentBuilder");
  var ActionRowBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ActionRowBuilder");
    }
    components;
    constructor({ components, ...data } = {}) {
      super({ type: import_v1011.ComponentType.ActionRow, ...data });
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    addComponents(...components) {
      this.components.push(...normalizeArray(components));
      return this;
    }
    setComponents(...components) {
      this.components.splice(0, this.components.length, ...normalizeArray(components));
      return this;
    }
    toJSON() {
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var Assertions_exports4 = {};
  __export2(Assertions_exports4, {
    componentsValidator: () => componentsValidator,
    titleValidator: () => titleValidator,
    validateRequiredParameters: () => validateRequiredParameters2
  });
  var import_shapeshift4 = require_cjs2();
  var titleValidator = import_shapeshift4.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
  var componentsValidator = import_shapeshift4.s.instance(ActionRowBuilder).array.lengthGreaterThanOrEqual(1).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredParameters2, "validateRequiredParameters");
  var ModalBuilder = class {
    static {
      __name(this, "ModalBuilder");
    }
    data;
    components = [];
    constructor({ components, ...data } = {}) {
      this.data = { ...data };
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    setTitle(title) {
      this.data.title = titleValidator.parse(title);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    addComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => component instanceof ActionRowBuilder ? component : new ActionRowBuilder(component)));
      return this;
    }
    setComponents(...components) {
      this.components.splice(0, this.components.length, ...normalizeArray(components));
      return this;
    }
    toJSON() {
      validateRequiredParameters2(this.data.custom_id, this.data.title, this.components);
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var Assertions_exports5 = {};
  __export2(Assertions_exports5, {
    assertReturnOfBuilder: () => assertReturnOfBuilder,
    localizationMapPredicate: () => localizationMapPredicate,
    validateChoicesLength: () => validateChoicesLength,
    validateDMPermission: () => validateDMPermission,
    validateDefaultMemberPermissions: () => validateDefaultMemberPermissions,
    validateDefaultPermission: () => validateDefaultPermission,
    validateDescription: () => validateDescription,
    validateLocale: () => validateLocale,
    validateLocalizationMap: () => validateLocalizationMap,
    validateMaxOptionsLength: () => validateMaxOptionsLength,
    validateNSFW: () => validateNSFW,
    validateName: () => validateName,
    validateRequired: () => validateRequired,
    validateRequiredParameters: () => validateRequiredParameters3
  });
  var import_shapeshift5 = require_cjs2();
  var import_v1012 = require_v106();
  var namePredicate = import_shapeshift5.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^[\p{Ll}\p{Lm}\p{Lo}\p{N}\p{sc=Devanagari}\p{sc=Thai}_-]+$/u).setValidationEnabled(isValidationEnabled);
  __name(validateName, "validateName");
  var descriptionPredicate2 = import_shapeshift5.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var localePredicate = import_shapeshift5.s.nativeEnum(import_v1012.Locale);
  __name(validateDescription, "validateDescription");
  var maxArrayLengthPredicate = import_shapeshift5.s.unknown.array.lengthLessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateLocale, "validateLocale");
  __name(validateMaxOptionsLength, "validateMaxOptionsLength");
  __name(validateRequiredParameters3, "validateRequiredParameters");
  var booleanPredicate = import_shapeshift5.s.boolean;
  __name(validateDefaultPermission, "validateDefaultPermission");
  __name(validateRequired, "validateRequired");
  var choicesLengthPredicate = import_shapeshift5.s.number.lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateChoicesLength, "validateChoicesLength");
  __name(assertReturnOfBuilder, "assertReturnOfBuilder");
  var localizationMapPredicate = import_shapeshift5.s.object(Object.fromEntries(Object.values(import_v1012.Locale).map((locale) => [locale, import_shapeshift5.s.string.nullish]))).strict.nullish.setValidationEnabled(isValidationEnabled);
  __name(validateLocalizationMap, "validateLocalizationMap");
  var dmPermissionPredicate = import_shapeshift5.s.boolean.nullish;
  __name(validateDMPermission, "validateDMPermission");
  var memberPermissionPredicate = import_shapeshift5.s.union(import_shapeshift5.s.bigint.transform((value) => value.toString()), import_shapeshift5.s.number.safeInt.transform((value) => value.toString()), import_shapeshift5.s.string.regex(/^\d+$/)).nullish;
  __name(validateDefaultMemberPermissions, "validateDefaultMemberPermissions");
  __name(validateNSFW, "validateNSFW");
  var import_ts_mixer6 = require_cjs3();
  var import_v1024 = require_v106();
  var import_ts_mixer5 = require_cjs3();
  var SharedNameAndDescription = class {
    static {
      __name(this, "SharedNameAndDescription");
    }
    name;
    name_localizations;
    description;
    description_localizations;
    setName(name) {
      validateName(name);
      Reflect.set(this, "name", name);
      return this;
    }
    setDescription(description) {
      validateDescription(description);
      Reflect.set(this, "description", description);
      return this;
    }
    setNameLocalization(locale, localizedName) {
      if (!this.name_localizations) {
        Reflect.set(this, "name_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedName === null) {
        this.name_localizations[parsedLocale] = null;
        return this;
      }
      validateName(localizedName);
      this.name_localizations[parsedLocale] = localizedName;
      return this;
    }
    setNameLocalizations(localizedNames) {
      if (localizedNames === null) {
        Reflect.set(this, "name_localizations", null);
        return this;
      }
      Reflect.set(this, "name_localizations", {});
      for (const args of Object.entries(localizedNames)) {
        this.setNameLocalization(...args);
      }
      return this;
    }
    setDescriptionLocalization(locale, localizedDescription) {
      if (!this.description_localizations) {
        Reflect.set(this, "description_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedDescription === null) {
        this.description_localizations[parsedLocale] = null;
        return this;
      }
      validateDescription(localizedDescription);
      this.description_localizations[parsedLocale] = localizedDescription;
      return this;
    }
    setDescriptionLocalizations(localizedDescriptions) {
      if (localizedDescriptions === null) {
        Reflect.set(this, "description_localizations", null);
        return this;
      }
      Reflect.set(this, "description_localizations", {});
      for (const args of Object.entries(localizedDescriptions)) {
        this.setDescriptionLocalization(...args);
      }
      return this;
    }
  };
  var import_v1013 = require_v106();
  var ApplicationCommandOptionBase = class extends SharedNameAndDescription {
    static {
      __name(this, "ApplicationCommandOptionBase");
    }
    required = false;
    setRequired(required) {
      validateRequired(required);
      Reflect.set(this, "required", required);
      return this;
    }
    runRequiredValidations() {
      validateRequiredParameters3(this.name, this.description, []);
      validateLocalizationMap(this.name_localizations);
      validateLocalizationMap(this.description_localizations);
      validateRequired(this.required);
    }
  };
  var SlashCommandAttachmentOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandAttachmentOption");
    }
    type = import_v1013.ApplicationCommandOptionType.Attachment;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_v1014 = require_v106();
  var SlashCommandBooleanOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandBooleanOption");
    }
    type = import_v1014.ApplicationCommandOptionType.Boolean;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_v1016 = require_v106();
  var import_ts_mixer = require_cjs3();
  var import_shapeshift6 = require_cjs2();
  var import_v1015 = require_v106();
  var allowedChannelTypes = [
    import_v1015.ChannelType.GuildText,
    import_v1015.ChannelType.GuildVoice,
    import_v1015.ChannelType.GuildCategory,
    import_v1015.ChannelType.GuildAnnouncement,
    import_v1015.ChannelType.AnnouncementThread,
    import_v1015.ChannelType.PublicThread,
    import_v1015.ChannelType.PrivateThread,
    import_v1015.ChannelType.GuildStageVoice,
    import_v1015.ChannelType.GuildForum,
    import_v1015.ChannelType.GuildMedia
  ];
  var channelTypesPredicate = import_shapeshift6.s.array(import_shapeshift6.s.union(...allowedChannelTypes.map((type) => import_shapeshift6.s.literal(type))));
  var ApplicationCommandOptionChannelTypesMixin = class {
    static {
      __name(this, "ApplicationCommandOptionChannelTypesMixin");
    }
    channel_types;
    addChannelTypes(...channelTypes) {
      if (this.channel_types === undefined) {
        Reflect.set(this, "channel_types", []);
      }
      this.channel_types.push(...channelTypesPredicate.parse(channelTypes));
      return this;
    }
  };
  var SlashCommandChannelOption = class extends ApplicationCommandOptionBase {
    type = import_v1016.ApplicationCommandOptionType.Channel;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  __name(SlashCommandChannelOption, "SlashCommandChannelOption");
  SlashCommandChannelOption = __decorateClass([
    (0, import_ts_mixer.mix)(ApplicationCommandOptionChannelTypesMixin)
  ], SlashCommandChannelOption);
  var import_shapeshift8 = require_cjs2();
  var import_v1018 = require_v106();
  var import_ts_mixer2 = require_cjs3();
  var ApplicationCommandNumericOptionMinMaxValueMixin = class {
    static {
      __name(this, "ApplicationCommandNumericOptionMinMaxValueMixin");
    }
    max_value;
    min_value;
  };
  var import_shapeshift7 = require_cjs2();
  var import_v1017 = require_v106();
  var stringPredicate = import_shapeshift7.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100);
  var numberPredicate = import_shapeshift7.s.number.greaterThan(Number.NEGATIVE_INFINITY).lessThan(Number.POSITIVE_INFINITY);
  var choicesPredicate = import_shapeshift7.s.object({
    name: stringPredicate,
    name_localizations: localizationMapPredicate,
    value: import_shapeshift7.s.union(stringPredicate, numberPredicate)
  }).array;
  var booleanPredicate2 = import_shapeshift7.s.boolean;
  var ApplicationCommandOptionWithChoicesAndAutocompleteMixin = class {
    static {
      __name(this, "ApplicationCommandOptionWithChoicesAndAutocompleteMixin");
    }
    choices;
    autocomplete;
    type;
    addChoices(...choices) {
      if (choices.length > 0 && this.autocomplete) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      choicesPredicate.parse(choices);
      if (this.choices === undefined) {
        Reflect.set(this, "choices", []);
      }
      validateChoicesLength(choices.length, this.choices);
      for (const { name, name_localizations, value } of choices) {
        if (this.type === import_v1017.ApplicationCommandOptionType.String) {
          stringPredicate.parse(value);
        } else {
          numberPredicate.parse(value);
        }
        this.choices.push({ name, name_localizations, value });
      }
      return this;
    }
    setChoices(...choices) {
      if (choices.length > 0 && this.autocomplete) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      choicesPredicate.parse(choices);
      Reflect.set(this, "choices", []);
      this.addChoices(...choices);
      return this;
    }
    setAutocomplete(autocomplete) {
      booleanPredicate2.parse(autocomplete);
      if (autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      Reflect.set(this, "autocomplete", autocomplete);
      return this;
    }
  };
  var numberValidator = import_shapeshift8.s.number.int;
  var SlashCommandIntegerOption = class extends ApplicationCommandOptionBase {
    type = import_v1018.ApplicationCommandOptionType.Integer;
    setMaxValue(max) {
      numberValidator.parse(max);
      Reflect.set(this, "max_value", max);
      return this;
    }
    setMinValue(min) {
      numberValidator.parse(min);
      Reflect.set(this, "min_value", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandIntegerOption, "SlashCommandIntegerOption");
  SlashCommandIntegerOption = __decorateClass([
    (0, import_ts_mixer2.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
  ], SlashCommandIntegerOption);
  var import_v1019 = require_v106();
  var SlashCommandMentionableOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandMentionableOption");
    }
    type = import_v1019.ApplicationCommandOptionType.Mentionable;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_shapeshift9 = require_cjs2();
  var import_v1020 = require_v106();
  var import_ts_mixer3 = require_cjs3();
  var numberValidator2 = import_shapeshift9.s.number;
  var SlashCommandNumberOption = class extends ApplicationCommandOptionBase {
    type = import_v1020.ApplicationCommandOptionType.Number;
    setMaxValue(max) {
      numberValidator2.parse(max);
      Reflect.set(this, "max_value", max);
      return this;
    }
    setMinValue(min) {
      numberValidator2.parse(min);
      Reflect.set(this, "min_value", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandNumberOption, "SlashCommandNumberOption");
  SlashCommandNumberOption = __decorateClass([
    (0, import_ts_mixer3.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
  ], SlashCommandNumberOption);
  var import_v1021 = require_v106();
  var SlashCommandRoleOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandRoleOption");
    }
    type = import_v1021.ApplicationCommandOptionType.Role;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_shapeshift10 = require_cjs2();
  var import_v1022 = require_v106();
  var import_ts_mixer4 = require_cjs3();
  var minLengthValidator2 = import_shapeshift10.s.number.greaterThanOrEqual(0).lessThanOrEqual(6000);
  var maxLengthValidator2 = import_shapeshift10.s.number.greaterThanOrEqual(1).lessThanOrEqual(6000);
  var SlashCommandStringOption = class extends ApplicationCommandOptionBase {
    type = import_v1022.ApplicationCommandOptionType.String;
    max_length;
    min_length;
    setMaxLength(max) {
      maxLengthValidator2.parse(max);
      Reflect.set(this, "max_length", max);
      return this;
    }
    setMinLength(min) {
      minLengthValidator2.parse(min);
      Reflect.set(this, "min_length", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandStringOption, "SlashCommandStringOption");
  SlashCommandStringOption = __decorateClass([
    (0, import_ts_mixer4.mix)(ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
  ], SlashCommandStringOption);
  var import_v1023 = require_v106();
  var SlashCommandUserOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandUserOption");
    }
    type = import_v1023.ApplicationCommandOptionType.User;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var SharedSlashCommandOptions = class {
    static {
      __name(this, "SharedSlashCommandOptions");
    }
    options;
    addBooleanOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandBooleanOption);
    }
    addUserOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandUserOption);
    }
    addChannelOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandChannelOption);
    }
    addRoleOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandRoleOption);
    }
    addAttachmentOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandAttachmentOption);
    }
    addMentionableOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandMentionableOption);
    }
    addStringOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandStringOption);
    }
    addIntegerOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandIntegerOption);
    }
    addNumberOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandNumberOption);
    }
    _sharedAddOptionMethod(input, Instance) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new Instance) : input;
      assertReturnOfBuilder(result, Instance);
      options.push(result);
      return this;
    }
  };
  var SlashCommandSubcommandGroupBuilder = class {
    name = undefined;
    description = undefined;
    options = [];
    addSubcommand(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder) : input;
      assertReturnOfBuilder(result, SlashCommandSubcommandBuilder);
      options.push(result);
      return this;
    }
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      return {
        type: import_v1024.ApplicationCommandOptionType.SubcommandGroup,
        name: this.name,
        name_localizations: this.name_localizations,
        description: this.description,
        description_localizations: this.description_localizations,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandSubcommandGroupBuilder, "SlashCommandSubcommandGroupBuilder");
  SlashCommandSubcommandGroupBuilder = __decorateClass([
    (0, import_ts_mixer5.mix)(SharedNameAndDescription)
  ], SlashCommandSubcommandGroupBuilder);
  var SlashCommandSubcommandBuilder = class {
    name = undefined;
    description = undefined;
    options = [];
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      return {
        type: import_v1024.ApplicationCommandOptionType.Subcommand,
        name: this.name,
        name_localizations: this.name_localizations,
        description: this.description,
        description_localizations: this.description_localizations,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandSubcommandBuilder, "SlashCommandSubcommandBuilder");
  SlashCommandSubcommandBuilder = __decorateClass([
    (0, import_ts_mixer5.mix)(SharedNameAndDescription, SharedSlashCommandOptions)
  ], SlashCommandSubcommandBuilder);
  var SlashCommandBuilder = class {
    name = undefined;
    name_localizations;
    description = undefined;
    description_localizations;
    options = [];
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    nsfw = undefined;
    setDefaultPermission(value) {
      validateDefaultPermission(value);
      Reflect.set(this, "default_permission", value);
      return this;
    }
    setDefaultMemberPermissions(permissions) {
      const permissionValue = validateDefaultMemberPermissions(permissions);
      Reflect.set(this, "default_member_permissions", permissionValue);
      return this;
    }
    setDMPermission(enabled) {
      validateDMPermission(enabled);
      Reflect.set(this, "dm_permission", enabled);
      return this;
    }
    setNSFW(nsfw = true) {
      validateNSFW(nsfw);
      Reflect.set(this, "nsfw", nsfw);
      return this;
    }
    addSubcommandGroup(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandGroupBuilder) : input;
      assertReturnOfBuilder(result, SlashCommandSubcommandGroupBuilder);
      options.push(result);
      return this;
    }
    addSubcommand(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder) : input;
      assertReturnOfBuilder(result, SlashCommandSubcommandBuilder);
      options.push(result);
      return this;
    }
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      validateLocalizationMap(this.name_localizations);
      validateLocalizationMap(this.description_localizations);
      return {
        ...this,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandBuilder, "SlashCommandBuilder");
  SlashCommandBuilder = __decorateClass([
    (0, import_ts_mixer6.mix)(SharedSlashCommandOptions, SharedNameAndDescription)
  ], SlashCommandBuilder);
  var Assertions_exports6 = {};
  __export2(Assertions_exports6, {
    validateDMPermission: () => validateDMPermission2,
    validateDefaultMemberPermissions: () => validateDefaultMemberPermissions2,
    validateDefaultPermission: () => validateDefaultPermission2,
    validateName: () => validateName2,
    validateRequiredParameters: () => validateRequiredParameters4,
    validateType: () => validateType
  });
  var import_shapeshift11 = require_cjs2();
  var import_v1025 = require_v106();
  var namePredicate2 = import_shapeshift11.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^( *[\p{P}\p{L}\p{N}\p{sc=Devanagari}\p{sc=Thai}]+ *)+$/u).setValidationEnabled(isValidationEnabled);
  var typePredicate = import_shapeshift11.s.union(import_shapeshift11.s.literal(import_v1025.ApplicationCommandType.User), import_shapeshift11.s.literal(import_v1025.ApplicationCommandType.Message)).setValidationEnabled(isValidationEnabled);
  var booleanPredicate3 = import_shapeshift11.s.boolean;
  __name(validateDefaultPermission2, "validateDefaultPermission");
  __name(validateName2, "validateName");
  __name(validateType, "validateType");
  __name(validateRequiredParameters4, "validateRequiredParameters");
  var dmPermissionPredicate2 = import_shapeshift11.s.boolean.nullish;
  __name(validateDMPermission2, "validateDMPermission");
  var memberPermissionPredicate2 = import_shapeshift11.s.union(import_shapeshift11.s.bigint.transform((value) => value.toString()), import_shapeshift11.s.number.safeInt.transform((value) => value.toString()), import_shapeshift11.s.string.regex(/^\d+$/)).nullish;
  __name(validateDefaultMemberPermissions2, "validateDefaultMemberPermissions");
  var ContextMenuCommandBuilder = class {
    static {
      __name(this, "ContextMenuCommandBuilder");
    }
    name = undefined;
    name_localizations;
    type = undefined;
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    setName(name) {
      validateName2(name);
      Reflect.set(this, "name", name);
      return this;
    }
    setType(type) {
      validateType(type);
      Reflect.set(this, "type", type);
      return this;
    }
    setDefaultPermission(value) {
      validateDefaultPermission2(value);
      Reflect.set(this, "default_permission", value);
      return this;
    }
    setDefaultMemberPermissions(permissions) {
      const permissionValue = validateDefaultMemberPermissions2(permissions);
      Reflect.set(this, "default_member_permissions", permissionValue);
      return this;
    }
    setDMPermission(enabled) {
      validateDMPermission2(enabled);
      Reflect.set(this, "dm_permission", enabled);
      return this;
    }
    setNameLocalization(locale, localizedName) {
      if (!this.name_localizations) {
        Reflect.set(this, "name_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedName === null) {
        this.name_localizations[parsedLocale] = null;
        return this;
      }
      validateName2(localizedName);
      this.name_localizations[parsedLocale] = localizedName;
      return this;
    }
    setNameLocalizations(localizedNames) {
      if (localizedNames === null) {
        Reflect.set(this, "name_localizations", null);
        return this;
      }
      Reflect.set(this, "name_localizations", {});
      for (const args of Object.entries(localizedNames))
        this.setNameLocalization(...args);
      return this;
    }
    toJSON() {
      validateRequiredParameters4(this.name, this.type);
      validateLocalizationMap(this.name_localizations);
      return { ...this };
    }
  };
  __name(embedLength, "embedLength");
  var version = "1.7.0";
});

// node_modules/discord.js/src/structures/Component.js
var require_Component = __commonJS((exports, module) => {
  var isEqual = require_fast_deep_equal();

  class Component {
    constructor(data) {
      this.data = data;
    }
    get type() {
      return this.data.type;
    }
    equals(other) {
      if (other instanceof Component) {
        return isEqual(other.data, this.data);
      }
      return isEqual(other, this.data);
    }
    toJSON() {
      return { ...this.data };
    }
  }
  module.exports = Component;
});

// node_modules/discord.js/src/structures/ActionRow.js
var require_ActionRow = __commonJS((exports, module) => {
  var { deprecate } = __require("node:util");
  var { isJSONEncodable } = require_dist();
  var Component = require_Component();
  var { createComponent } = require_Components();

  class ActionRow extends Component {
    constructor({ components, ...data }) {
      super(data);
      this.components = components.map((component) => createComponent(component));
    }
    static from = deprecate((other) => new this(isJSONEncodable(other) ? other.toJSON() : other), "ActionRow.from() is deprecated. Use ActionRowBuilder.from() instead.");
    toJSON() {
      return { ...this.data, components: this.components.map((component) => component.toJSON()) };
    }
  }
  module.exports = ActionRow;
});

// node_modules/discord.js/src/structures/ButtonBuilder.js
var require_ButtonBuilder = __commonJS((exports, module) => {
  var { ButtonBuilder: BuildersButton } = require_dist9();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class ButtonBuilder extends BuildersButton {
    constructor({ emoji, ...data } = {}) {
      super(toSnakeCase({ ...data, emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji }));
    }
    setEmoji(emoji) {
      if (typeof emoji === "string") {
        return super.setEmoji(resolvePartialEmoji(emoji));
      }
      return super.setEmoji(emoji);
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ButtonBuilder;
});

// node_modules/discord.js/src/structures/ButtonComponent.js
var require_ButtonComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class ButtonComponent extends Component {
    get style() {
      return this.data.style;
    }
    get label() {
      return this.data.label ?? null;
    }
    get emoji() {
      return this.data.emoji ?? null;
    }
    get disabled() {
      return this.data.disabled ?? false;
    }
    get customId() {
      return this.data.custom_id ?? null;
    }
    get url() {
      return this.data.url ?? null;
    }
  }
  module.exports = ButtonComponent;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuBuilder.js
var require_ChannelSelectMenuBuilder = __commonJS((exports, module) => {
  var { ChannelSelectMenuBuilder: BuildersChannelSelectMenu } = require_dist9();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class ChannelSelectMenuBuilder extends BuildersChannelSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ChannelSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/BaseSelectMenuComponent.js
var require_BaseSelectMenuComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class BaseSelectMenuComponent extends Component {
    get placeholder() {
      return this.data.placeholder ?? null;
    }
    get maxValues() {
      return this.data.max_values ?? null;
    }
    get minValues() {
      return this.data.min_values ?? null;
    }
    get customId() {
      return this.data.custom_id;
    }
    get disabled() {
      return this.data.disabled ?? false;
    }
  }
  module.exports = BaseSelectMenuComponent;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuComponent.js
var require_ChannelSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class ChannelSelectMenuComponent extends BaseSelectMenuComponent {
    get channelTypes() {
      return this.data.channel_types ?? null;
    }
  }
  module.exports = ChannelSelectMenuComponent;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuBuilder.js
var require_MentionableSelectMenuBuilder = __commonJS((exports, module) => {
  var { MentionableSelectMenuBuilder: BuildersMentionableSelectMenu } = require_dist9();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class MentionableSelectMenuBuilder extends BuildersMentionableSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = MentionableSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuComponent.js
var require_MentionableSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class MentionableSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = MentionableSelectMenuComponent;
});

// node_modules/discord.js/src/structures/RoleSelectMenuBuilder.js
var require_RoleSelectMenuBuilder = __commonJS((exports, module) => {
  var { RoleSelectMenuBuilder: BuildersRoleSelectMenu } = require_dist9();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class RoleSelectMenuBuilder extends BuildersRoleSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = RoleSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/RoleSelectMenuComponent.js
var require_RoleSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class RoleSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = RoleSelectMenuComponent;
});

// node_modules/discord.js/src/structures/StringSelectMenuBuilder.js
var require_StringSelectMenuBuilder = __commonJS((exports, module) => {
  var { SelectMenuBuilder: BuildersSelectMenu, normalizeArray } = require_dist9();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class StringSelectMenuBuilder extends BuildersSelectMenu {
    constructor({ options, ...data } = {}) {
      super(toSnakeCase({
        ...data,
        options: options?.map(({ emoji, ...option }) => ({
          ...option,
          emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
        }))
      }));
    }
    static normalizeEmoji(selectMenuOption) {
      if (isJSONEncodable(selectMenuOption)) {
        return selectMenuOption;
      }
      const { emoji, ...option } = selectMenuOption;
      return {
        ...option,
        emoji: typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
      };
    }
    addOptions(...options) {
      return super.addOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
    }
    setOptions(...options) {
      return super.setOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
    }
    static from(other) {
      if (isJSONEncodable(other)) {
        return new this(other.toJSON());
      }
      return new this(other);
    }
  }
  module.exports = StringSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/StringSelectMenuComponent.js
var require_StringSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class StringSelectMenuComponent extends BaseSelectMenuComponent {
    get options() {
      return this.data.options;
    }
  }
  module.exports = StringSelectMenuComponent;
});

// node_modules/discord.js/src/structures/TextInputBuilder.js
var require_TextInputBuilder = __commonJS((exports, module) => {
  var { TextInputBuilder: BuildersTextInput } = require_dist9();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class TextInputBuilder extends BuildersTextInput {
    constructor(data) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = TextInputBuilder;
});

// node_modules/discord.js/src/structures/TextInputComponent.js
var require_TextInputComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class TextInputComponent extends Component {
    get customId() {
      return this.data.custom_id;
    }
    get value() {
      return this.data.value;
    }
  }
  module.exports = TextInputComponent;
});

// node_modules/discord.js/src/structures/UserSelectMenuBuilder.js
var require_UserSelectMenuBuilder = __commonJS((exports, module) => {
  var { UserSelectMenuBuilder: BuildersUserSelectMenu } = require_dist9();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class UserSelectMenuBuilder extends BuildersUserSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = UserSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/UserSelectMenuComponent.js
var require_UserSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class UserSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = UserSelectMenuComponent;
});

// node_modules/discord.js/src/util/Components.js
var require_Components = __commonJS((exports, module) => {
  var createComponent = function(data) {
    if (data instanceof Component) {
      return data;
    }
    switch (data.type) {
      case ComponentType.ActionRow:
        return new ActionRow(data);
      case ComponentType.Button:
        return new ButtonComponent(data);
      case ComponentType.StringSelect:
        return new StringSelectMenuComponent(data);
      case ComponentType.TextInput:
        return new TextInputComponent(data);
      case ComponentType.UserSelect:
        return new UserSelectMenuComponent(data);
      case ComponentType.RoleSelect:
        return new RoleSelectMenuComponent(data);
      case ComponentType.MentionableSelect:
        return new MentionableSelectMenuComponent(data);
      case ComponentType.ChannelSelect:
        return new ChannelSelectMenuComponent(data);
      default:
        return new Component(data);
    }
  };
  var createComponentBuilder = function(data) {
    if (data instanceof ComponentBuilder) {
      return data;
    }
    switch (data.type) {
      case ComponentType.ActionRow:
        return new ActionRowBuilder(data);
      case ComponentType.Button:
        return new ButtonBuilder(data);
      case ComponentType.StringSelect:
        return new StringSelectMenuBuilder(data);
      case ComponentType.TextInput:
        return new TextInputBuilder(data);
      case ComponentType.UserSelect:
        return new UserSelectMenuBuilder(data);
      case ComponentType.RoleSelect:
        return new RoleSelectMenuBuilder(data);
      case ComponentType.MentionableSelect:
        return new MentionableSelectMenuBuilder(data);
      case ComponentType.ChannelSelect:
        return new ChannelSelectMenuBuilder(data);
      default:
        return new ComponentBuilder(data);
    }
  };
  var { ComponentBuilder } = require_dist9();
  var { ComponentType } = require_v106();
  module.exports = { createComponent, createComponentBuilder };
  var ActionRow = require_ActionRow();
  var ActionRowBuilder = require_ActionRowBuilder();
  var ButtonBuilder = require_ButtonBuilder();
  var ButtonComponent = require_ButtonComponent();
  var ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
  var ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
  var Component = require_Component();
  var MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
  var MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
  var RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
  var RoleSelectMenuComponent = require_RoleSelectMenuComponent();
  var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  var StringSelectMenuComponent = require_StringSelectMenuComponent();
  var TextInputBuilder = require_TextInputBuilder();
  var TextInputComponent = require_TextInputComponent();
  var UserSelectMenuBuilder = require_UserSelectMenuBuilder();
  var UserSelectMenuComponent = require_UserSelectMenuComponent();
});

// node_modules/discord.js/src/structures/ActionRowBuilder.js
var require_ActionRowBuilder = __commonJS((exports, module) => {
  var { ActionRowBuilder: BuildersActionRow } = require_dist9();
  var { isJSONEncodable } = require_dist();
  var { createComponentBuilder } = require_Components();
  var { toSnakeCase } = require_Transformers();

  class ActionRowBuilder extends BuildersActionRow {
    constructor({ components, ...data } = {}) {
      super({
        ...toSnakeCase(data),
        components: components?.map((component) => createComponentBuilder(component))
      });
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ActionRowBuilder;
});

// node_modules/discord.js/src/structures/GuildScheduledEvent.js
var require_GuildScheduledEvent = __commonJS((exports) => {
  var { DiscordSnowflake } = require_dist3();
  var { GuildScheduledEventStatus, GuildScheduledEventEntityType, RouteBases } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class GuildScheduledEvent extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.guildId = data.guild_id;
      this._patch(data);
    }
    _patch(data) {
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      } else {
        this.channelId ??= null;
      }
      if ("creator_id" in data) {
        this.creatorId = data.creator_id;
      } else {
        this.creatorId ??= null;
      }
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if ("scheduled_start_time" in data) {
        this.scheduledStartTimestamp = Date.parse(data.scheduled_start_time);
      } else {
        this.scheduledStartTimestamp ??= null;
      }
      if ("scheduled_end_time" in data) {
        this.scheduledEndTimestamp = data.scheduled_end_time ? Date.parse(data.scheduled_end_time) : null;
      } else {
        this.scheduledEndTimestamp ??= null;
      }
      if ("privacy_level" in data) {
        this.privacyLevel = data.privacy_level;
      } else {
        this.privacyLevel ??= null;
      }
      if ("status" in data) {
        this.status = data.status;
      } else {
        this.status ??= null;
      }
      if ("entity_type" in data) {
        this.entityType = data.entity_type;
      } else {
        this.entityType ??= null;
      }
      if ("entity_id" in data) {
        this.entityId = data.entity_id;
      } else {
        this.entityId ??= null;
      }
      if ("user_count" in data) {
        this.userCount = data.user_count;
      } else {
        this.userCount ??= null;
      }
      if ("creator" in data) {
        this.creator = this.client.users._add(data.creator);
      } else {
        this.creator ??= this.client.users.resolve(this.creatorId);
      }
      if ("entity_metadata" in data) {
        if (data.entity_metadata) {
          this.entityMetadata = {
            location: data.entity_metadata.location ?? this.entityMetadata?.location ?? null
          };
        } else {
          this.entityMetadata = null;
        }
      } else {
        this.entityMetadata ??= null;
      }
      if ("image" in data) {
        this.image = data.image;
      } else {
        this.image ??= null;
      }
    }
    get partial() {
      return this.name === null;
    }
    coverImageURL(options = {}) {
      return this.image && this.client.rest.cdn.guildScheduledEventCover(this.id, this.image, options);
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get scheduledStartAt() {
      return this.scheduledStartTimestamp && new Date(this.scheduledStartTimestamp);
    }
    get scheduledEndAt() {
      return this.scheduledEndTimestamp && new Date(this.scheduledEndTimestamp);
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return `${RouteBases.scheduledEvent}/${this.guildId}/${this.id}`;
    }
    async createInviteURL(options) {
      let channelId = this.channelId;
      if (this.entityType === GuildScheduledEventEntityType.External) {
        if (!options?.channel)
          throw new DiscordjsError(ErrorCodes.InviteOptionsMissingChannel);
        channelId = this.guild.channels.resolveId(options.channel);
        if (!channelId)
          throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      }
      const invite = await this.guild.invites.create(channelId, options);
      return `${RouteBases.invite}/${invite.code}?event=${this.id}`;
    }
    edit(options) {
      return this.guild.scheduledEvents.edit(this.id, options);
    }
    fetch(force = true) {
      return this.guild.scheduledEvents.fetch({ guildScheduledEvent: this.id, force });
    }
    async delete() {
      await this.guild.scheduledEvents.delete(this.id);
      return this;
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setScheduledStartTime(scheduledStartTime, reason) {
      return this.edit({ scheduledStartTime, reason });
    }
    setScheduledEndTime(scheduledEndTime, reason) {
      return this.edit({ scheduledEndTime, reason });
    }
    setDescription(description, reason) {
      return this.edit({ description, reason });
    }
    setStatus(status, reason) {
      return this.edit({ status, reason });
    }
    setLocation(location, reason) {
      return this.edit({ entityMetadata: { location }, reason });
    }
    fetchSubscribers(options) {
      return this.guild.scheduledEvents.fetchSubscribers(this.id, options);
    }
    toString() {
      return this.url;
    }
    isActive() {
      return this.status === GuildScheduledEventStatus.Active;
    }
    isCanceled() {
      return this.status === GuildScheduledEventStatus.Canceled;
    }
    isCompleted() {
      return this.status === GuildScheduledEventStatus.Completed;
    }
    isScheduled() {
      return this.status === GuildScheduledEventStatus.Scheduled;
    }
  }
  exports.GuildScheduledEvent = GuildScheduledEvent;
});

// node_modules/discord.js/src/structures/interfaces/Application.js
var require_Application = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();

  class Application extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      } else {
        this.icon ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.appIcon(this.id, this.icon, options);
    }
    coverURL(options = {}) {
      return this.cover && this.client.rest.cdn.appIcon(this.id, this.cover, options);
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({ createdTimestamp: true });
    }
  }
  module.exports = Application;
});

// node_modules/discord.js/src/structures/IntegrationApplication.js
var require_IntegrationApplication = __commonJS((exports, module) => {
  var Application = require_Application();

  class IntegrationApplication extends Application {
    _patch(data) {
      super._patch(data);
      if ("bot" in data) {
        this.bot = this.client.users._add(data.bot);
      } else {
        this.bot ??= null;
      }
      if ("terms_of_service_url" in data) {
        this.termsOfServiceURL = data.terms_of_service_url;
      } else {
        this.termsOfServiceURL ??= null;
      }
      if ("privacy_policy_url" in data) {
        this.privacyPolicyURL = data.privacy_policy_url;
      } else {
        this.privacyPolicyURL ??= null;
      }
      if ("rpc_origins" in data) {
        this.rpcOrigins = data.rpc_origins;
      } else {
        this.rpcOrigins ??= [];
      }
      if ("hook" in data) {
        this.hook = data.hook;
      } else {
        this.hook ??= null;
      }
      if ("cover_image" in data) {
        this.cover = data.cover_image;
      } else {
        this.cover ??= null;
      }
      if ("verify_key" in data) {
        this.verifyKey = data.verify_key;
      } else {
        this.verifyKey ??= null;
      }
    }
  }
  module.exports = IntegrationApplication;
});

// node_modules/discord.js/src/structures/InviteStageInstance.js
var require_InviteStageInstance = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var Base = require_Base();

  class InviteStageInstance extends Base {
    constructor(client, data, channelId, guildId) {
      super(client);
      this.channelId = channelId;
      this.guildId = guildId;
      this.members = new Collection;
      this._patch(data);
    }
    _patch(data) {
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("participant_count" in data) {
        this.participantCount = data.participant_count;
      }
      if ("speaker_count" in data) {
        this.speakerCount = data.speaker_count;
      }
      this.members.clear();
      for (const rawMember of data.members) {
        const member = this.guild.members._add(rawMember);
        this.members.set(member.id, member);
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
  }
  module.exports = InviteStageInstance;
});

// node_modules/discord.js/src/structures/BaseGuild.js
var require_BaseGuild = __commonJS((exports, module) => {
  var { makeURLSearchParams } = require_dist6();
  var { DiscordSnowflake } = require_dist3();
  var { Routes, GuildFeature } = require_v106();
  var Base = require_Base();

  class BaseGuild extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.name = data.name;
      this.icon = data.icon;
      this.features = data.features;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get nameAcronym() {
      return this.name.replace(/'s /g, " ").replace(/\w+/g, (e) => e[0]).replace(/\s/g, "");
    }
    get partnered() {
      return this.features.includes(GuildFeature.Partnered);
    }
    get verified() {
      return this.features.includes(GuildFeature.Verified);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guild(this.id), {
        query: makeURLSearchParams({ with_counts: true })
      });
      return this.client.guilds._add(data);
    }
    toString() {
      return this.name;
    }
  }
  module.exports = BaseGuild;
});

// node_modules/discord.js/src/structures/AnonymousGuild.js
var require_AnonymousGuild = __commonJS((exports, module) => {
  var BaseGuild = require_BaseGuild();

  class AnonymousGuild extends BaseGuild {
    constructor(client, data, immediatePatch = true) {
      super(client, data);
      if (immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      if ("features" in data)
        this.features = data.features;
      if ("splash" in data) {
        this.splash = data.splash;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("verification_level" in data) {
        this.verificationLevel = data.verification_level;
      }
      if ("vanity_url_code" in data) {
        this.vanityURLCode = data.vanity_url_code;
      }
      if ("nsfw_level" in data) {
        this.nsfwLevel = data.nsfw_level;
      }
      if ("premium_subscription_count" in data) {
        this.premiumSubscriptionCount = data.premium_subscription_count;
      } else {
        this.premiumSubscriptionCount ??= null;
      }
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
    }
    splashURL(options = {}) {
      return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
    }
  }
  module.exports = AnonymousGuild;
});

// node_modules/discord.js/src/structures/Emoji.js
var require_Emoji = __commonJS((exports) => {
  var process2 = __require("node:process");
  var { formatEmoji } = require_dist8();
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();
  var deprecationEmittedForURL = false;

  class Emoji extends Base {
    constructor(client, emoji) {
      super(client);
      this.animated = emoji.animated ?? null;
      this.name = emoji.name ?? null;
      this.id = emoji.id ?? null;
    }
    get identifier() {
      if (this.id)
        return `${this.animated ? "a:" : ""}${this.name}:${this.id}`;
      return encodeURIComponent(this.name);
    }
    imageURL(options) {
      return this.id && this.client.rest.cdn.emoji(this.id, options);
    }
    get url() {
      if (!deprecationEmittedForURL) {
        process2.emitWarning("The Emoji#url getter is deprecated. Use Emoji#imageURL() instead.", "DeprecationWarning");
        deprecationEmittedForURL = true;
      }
      return this.imageURL({ extension: this.animated ? "gif" : "png" });
    }
    get createdTimestamp() {
      return this.id && DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return this.id && new Date(this.createdTimestamp);
    }
    toString() {
      return this.id ? formatEmoji(this.id, this.animated) : this.name;
    }
    toJSON() {
      return super.toJSON({
        guild: "guildId",
        createdTimestamp: true,
        url: true,
        identifier: true
      });
    }
  }
  exports.Emoji = Emoji;
});

// node_modules/discord.js/src/structures/WelcomeChannel.js
var require_WelcomeChannel = __commonJS((exports, module) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class WelcomeChannel extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.description = data.description;
      this._emoji = {
        name: data.emoji_name,
        id: data.emoji_id
      };
      this.channelId = data.channel_id;
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get emoji() {
      return this.client.emojis.resolve(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
  }
  module.exports = WelcomeChannel;
});

// node_modules/discord.js/src/structures/WelcomeScreen.js
var require_WelcomeScreen = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { GuildFeature } = require_v106();
  var Base = require_Base();
  var WelcomeChannel = require_WelcomeChannel();

  class WelcomeScreen extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.description = data.description ?? null;
      this.welcomeChannels = new Collection;
      for (const channel of data.welcome_channels) {
        const welcomeChannel = new WelcomeChannel(this.guild, channel);
        this.welcomeChannels.set(welcomeChannel.channelId, welcomeChannel);
      }
    }
    get enabled() {
      return this.guild.features.includes(GuildFeature.WelcomeScreenEnabled);
    }
  }
  module.exports = WelcomeScreen;
});

// node_modules/discord.js/src/structures/InviteGuild.js
var require_InviteGuild = __commonJS((exports, module) => {
  var AnonymousGuild = require_AnonymousGuild();
  var WelcomeScreen = require_WelcomeScreen();

  class InviteGuild extends AnonymousGuild {
    constructor(client, data) {
      super(client, data);
      this.welcomeScreen = data.welcome_screen !== undefined ? new WelcomeScreen(this, data.welcome_screen) : null;
    }
  }
  module.exports = InviteGuild;
});

// node_modules/discord.js/src/structures/Invite.js
var require_Invite = __commonJS((exports, module) => {
  var { RouteBases, Routes, PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var IntegrationApplication = require_IntegrationApplication();
  var InviteStageInstance = require_InviteStageInstance();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class Invite extends Base {
    static InvitesPattern = /discord(?:(?:app)?\.com\/invite|\.gg(?:\/invite)?)\/(?<code>[\w-]{2,255})/i;
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      const InviteGuild = require_InviteGuild();
      this.guild ??= null;
      if (data.guild) {
        this.guild = this.client.guilds.resolve(data.guild.id) ?? new InviteGuild(this.client, data.guild);
      }
      if ("code" in data) {
        this.code = data.code;
      }
      if ("approximate_presence_count" in data) {
        this.presenceCount = data.approximate_presence_count;
      } else {
        this.presenceCount ??= null;
      }
      if ("approximate_member_count" in data) {
        this.memberCount = data.approximate_member_count;
      } else {
        this.memberCount ??= null;
      }
      if ("temporary" in data) {
        this.temporary = data.temporary ?? null;
      } else {
        this.temporary ??= null;
      }
      if ("max_age" in data) {
        this.maxAge = data.max_age;
      } else {
        this.maxAge ??= null;
      }
      if ("uses" in data) {
        this.uses = data.uses;
      } else {
        this.uses ??= null;
      }
      if ("max_uses" in data) {
        this.maxUses = data.max_uses;
      } else {
        this.maxUses ??= null;
      }
      if ("inviter_id" in data) {
        this.inviterId = data.inviter_id;
      } else {
        this.inviterId ??= null;
      }
      if ("inviter" in data) {
        this.client.users._add(data.inviter);
        this.inviterId = data.inviter.id;
      }
      if ("target_user" in data) {
        this.targetUser = this.client.users._add(data.target_user);
      } else {
        this.targetUser ??= null;
      }
      if ("target_application" in data) {
        this.targetApplication = new IntegrationApplication(this.client, data.target_application);
      } else {
        this.targetApplication ??= null;
      }
      if ("target_type" in data) {
        this.targetType = data.target_type;
      } else {
        this.targetType ??= null;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("channel" in data) {
        this.channel = this.client.channels._add(data.channel, this.guild, { cache: false }) ?? this.client.channels.resolve(this.channelId);
        this.channelId ??= data.channel.id;
      }
      if ("created_at" in data) {
        this.createdTimestamp = Date.parse(data.created_at);
      } else {
        this.createdTimestamp ??= null;
      }
      if ("expires_at" in data) {
        this._expiresTimestamp = data.expires_at && Date.parse(data.expires_at);
      } else {
        this._expiresTimestamp ??= null;
      }
      if ("stage_instance" in data) {
        this.stageInstance = new InviteStageInstance(this.client, data.stage_instance, this.channel.id, this.guild.id);
      } else {
        this.stageInstance ??= null;
      }
      if ("guild_scheduled_event" in data) {
        this.guildScheduledEvent = new GuildScheduledEvent(this.client, data.guild_scheduled_event);
      } else {
        this.guildScheduledEvent ??= null;
      }
    }
    get createdAt() {
      return this.createdTimestamp && new Date(this.createdTimestamp);
    }
    get deletable() {
      const guild = this.guild;
      if (!guild || !this.client.guilds.cache.has(guild.id))
        return false;
      if (!guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return Boolean(this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageChannels, false) || guild.members.me.permissions.has(PermissionFlagsBits.ManageGuild));
    }
    get expiresTimestamp() {
      return this._expiresTimestamp ?? (this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1000 : null);
    }
    get expiresAt() {
      return this.expiresTimestamp && new Date(this.expiresTimestamp);
    }
    get inviter() {
      return this.inviterId && this.client.users.resolve(this.inviterId);
    }
    get url() {
      return `${RouteBases.invite}/${this.code}`;
    }
    async delete(reason) {
      await this.client.rest.delete(Routes.invite(this.code), { reason });
      return this;
    }
    toString() {
      return this.url;
    }
    toJSON() {
      return super.toJSON({
        url: true,
        expiresTimestamp: true,
        presenceCount: false,
        memberCount: false,
        uses: false,
        channel: "channelId",
        inviter: "inviterId",
        guild: "guildId"
      });
    }
    valueOf() {
      return this.code;
    }
  }
  module.exports = Invite;
});

// node_modules/discord.js/src/structures/GuildTemplate.js
var require_GuildTemplate = __commonJS((exports, module) => {
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { RouteBases, Routes } = require_v106();
  var Base = require_Base();
  var DataResolver = require_DataResolver();
  var Events = require_Events();

  class GuildTemplate extends Base {
    static GuildTemplatesPattern = /discord(?:app)?\.(?:com\/template|new)\/(?<code>[\w-]{2,255})/i;
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      if ("code" in data) {
        this.code = data.code;
      }
      if ("name" in data) {
        this.name = data.name;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("usage_count" in data) {
        this.usageCount = data.usage_count;
      }
      if ("creator_id" in data) {
        this.creatorId = data.creator_id;
      }
      if ("creator" in data) {
        this.creator = this.client.users._add(data.creator);
      }
      if ("created_at" in data) {
        this.createdTimestamp = Date.parse(data.created_at);
      }
      if ("updated_at" in data) {
        this.updatedTimestamp = Date.parse(data.updated_at);
      }
      if ("source_guild_id" in data) {
        this.guildId = data.source_guild_id;
      }
      if ("serialized_source_guild" in data) {
        this.serializedGuild = data.serialized_source_guild;
      }
      this.unSynced = "is_dirty" in data ? Boolean(data.is_dirty) : null;
      return this;
    }
    async createGuild(name, icon) {
      const { client } = this;
      const data = await client.rest.post(Routes.template(this.code), {
        body: {
          name,
          icon: await DataResolver.resolveImage(icon)
        }
      });
      if (client.guilds.cache.has(data.id))
        return client.guilds.cache.get(data.id);
      return new Promise((resolve) => {
        const resolveGuild = (guild) => {
          client.off(Events.GuildCreate, handleGuild);
          client.decrementMaxListeners();
          resolve(guild);
        };
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            clearTimeout2(timeout);
            resolveGuild(guild);
          }
        };
        client.incrementMaxListeners();
        client.on(Events.GuildCreate, handleGuild);
        const timeout = setTimeout2(() => resolveGuild(client.guilds._add(data)), 1e4).unref();
      });
    }
    async edit({ name, description } = {}) {
      const data = await this.client.rest.patch(Routes.guildTemplate(this.guildId, this.code), {
        body: { name, description }
      });
      return this._patch(data);
    }
    async delete() {
      await this.client.rest.delete(Routes.guildTemplate(this.guildId, this.code));
      return this;
    }
    async sync() {
      const data = await this.client.rest.put(Routes.guildTemplate(this.guildId, this.code));
      return this._patch(data);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get updatedAt() {
      return new Date(this.updatedTimestamp);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return `${RouteBases.template}/${this.code}`;
    }
    toString() {
      return this.code;
    }
  }
  module.exports = GuildTemplate;
});

// node_modules/discord.js/src/util/DataResolver.js
var require_DataResolver = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  var fs = __require("node:fs/promises");
  var path = __require("node:path");
  var { fetch: fetch2 } = require_undici();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var Invite = require_Invite();

  class DataResolver extends null {
    static resolveCode(data, regex) {
      return regex.exec(data)?.[1] ?? data;
    }
    static resolveInviteCode(data) {
      return this.resolveCode(data, Invite.InvitesPattern);
    }
    static resolveGuildTemplateCode(data) {
      const GuildTemplate = require_GuildTemplate();
      return this.resolveCode(data, GuildTemplate.GuildTemplatesPattern);
    }
    static async resolveImage(image) {
      if (!image)
        return null;
      if (typeof image === "string" && image.startsWith("data:")) {
        return image;
      }
      const file = await this.resolveFile(image);
      return this.resolveBase64(file.data);
    }
    static resolveBase64(data) {
      if (Buffer2.isBuffer(data))
        return `data:image/jpg;base64,${data.toString("base64")}`;
      return data;
    }
    static async resolveFile(resource) {
      if (Buffer2.isBuffer(resource))
        return { data: resource };
      if (typeof resource[Symbol.asyncIterator] === "function") {
        const buffers = [];
        for await (const data of resource)
          buffers.push(Buffer2.from(data));
        return { data: Buffer2.concat(buffers) };
      }
      if (typeof resource === "string") {
        if (/^https?:\/\//.test(resource)) {
          const res = await fetch2(resource);
          return { data: Buffer2.from(await res.arrayBuffer()), contentType: res.headers.get("content-type") };
        }
        const file = path.resolve(resource);
        const stats = await fs.stat(file);
        if (!stats.isFile())
          throw new DiscordjsError(ErrorCodes.FileNotFound, file);
        return { data: await fs.readFile(file) };
      }
      throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
    }
  }
  module.exports = DataResolver;
});

// node_modules/discord.js/src/util/MessageFlagsBitField.js
var require_MessageFlagsBitField = __commonJS((exports, module) => {
  var { MessageFlags } = require_v106();
  var BitField = require_BitField();

  class MessageFlagsBitField extends BitField {
    static Flags = MessageFlags;
  }
  module.exports = MessageFlagsBitField;
});

// node_modules/discord.js/src/structures/BaseInteraction.js
var require_BaseInteraction = __commonJS((exports, module) => {
  var { deprecate } = __require("node:util");
  var { DiscordSnowflake } = require_dist3();
  var { InteractionType, ApplicationCommandType, ComponentType } = require_v106();
  var Base = require_Base();
  var { SelectMenuTypes } = require_Constants();
  var PermissionsBitField = require_PermissionsBitField();

  class BaseInteraction extends Base {
    constructor(client, data) {
      super(client);
      this.type = data.type;
      this.id = data.id;
      Object.defineProperty(this, "token", { value: data.token });
      this.applicationId = data.application_id;
      this.channelId = data.channel?.id ?? null;
      this.guildId = data.guild_id ?? null;
      this.user = this.client.users._add(data.user ?? data.member.user);
      this.member = data.member ? this.guild?.members._add(data.member) ?? data.member : null;
      this.version = data.version;
      this.appPermissions = data.app_permissions ? new PermissionsBitField(data.app_permissions).freeze() : null;
      this.memberPermissions = data.member?.permissions ? new PermissionsBitField(data.member.permissions).freeze() : null;
      this.locale = data.locale;
      this.guildLocale = data.guild_locale ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get channel() {
      return this.client.channels.cache.get(this.channelId) ?? null;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    inGuild() {
      return Boolean(this.guildId && this.member);
    }
    inCachedGuild() {
      return Boolean(this.guild && this.member);
    }
    inRawGuild() {
      return Boolean(this.guildId && !this.guild && this.member);
    }
    isAutocomplete() {
      return this.type === InteractionType.ApplicationCommandAutocomplete;
    }
    isCommand() {
      return this.type === InteractionType.ApplicationCommand;
    }
    isChatInputCommand() {
      return this.type === InteractionType.ApplicationCommand && this.commandType === ApplicationCommandType.ChatInput;
    }
    isContextMenuCommand() {
      return this.type === InteractionType.ApplicationCommand && [ApplicationCommandType.User, ApplicationCommandType.Message].includes(this.commandType);
    }
    isMessageComponent() {
      return this.type === InteractionType.MessageComponent;
    }
    isModalSubmit() {
      return this.type === InteractionType.ModalSubmit;
    }
    isUserContextMenuCommand() {
      return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.User;
    }
    isMessageContextMenuCommand() {
      return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.Message;
    }
    isButton() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.Button;
    }
    isSelectMenu() {
      return this.isStringSelectMenu();
    }
    isAnySelectMenu() {
      return this.type === InteractionType.MessageComponent && SelectMenuTypes.includes(this.componentType);
    }
    isStringSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.StringSelect;
    }
    isUserSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.UserSelect;
    }
    isRoleSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.RoleSelect;
    }
    isChannelSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.ChannelSelect;
    }
    isMentionableSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.MentionableSelect;
    }
    isRepliable() {
      return ![InteractionType.Ping, InteractionType.ApplicationCommandAutocomplete].includes(this.type);
    }
  }
  BaseInteraction.prototype.isSelectMenu = deprecate(BaseInteraction.prototype.isSelectMenu, "BaseInteraction#isSelectMenu() is deprecated. Use BaseInteraction#isStringSelectMenu() instead.");
  module.exports = BaseInteraction;
});

// node_modules/discord.js/src/structures/ApplicationRoleConnectionMetadata.js
var require_ApplicationRoleConnectionMetadata = __commonJS((exports) => {
  class ApplicationRoleConnectionMetadata {
    constructor(data) {
      this.name = data.name;
      this.nameLocalizations = data.name_localizations ?? null;
      this.description = data.description;
      this.descriptionLocalizations = data.description_localizations ?? null;
      this.key = data.key;
      this.type = data.type;
    }
  }
  exports.ApplicationRoleConnectionMetadata = ApplicationRoleConnectionMetadata;
});

// node_modules/discord.js/src/structures/TeamMember.js
var require_TeamMember = __commonJS((exports, module) => {
  var Base = require_Base();

  class TeamMember extends Base {
    constructor(team, data) {
      super(team.client);
      this.team = team;
      this._patch(data);
    }
    _patch(data) {
      if ("permissions" in data) {
        this.permissions = data.permissions;
      }
      if ("membership_state" in data) {
        this.membershipState = data.membership_state;
      }
      if ("user" in data) {
        this.user = this.client.users._add(data.user);
      }
      if ("role" in data) {
        this.role = data.role;
      }
    }
    get id() {
      return this.user.id;
    }
    toString() {
      return this.user.toString();
    }
  }
  module.exports = TeamMember;
});

// node_modules/discord.js/src/structures/Team.js
var require_Team = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();
  var TeamMember = require_TeamMember();

  class Team extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      } else {
        this.icon ??= null;
      }
      if ("owner_user_id" in data) {
        this.ownerId = data.owner_user_id;
      } else {
        this.ownerId ??= null;
      }
      this.members = new Collection;
      for (const memberData of data.members) {
        const member = new TeamMember(this, memberData);
        this.members.set(member.id, member);
      }
    }
    get owner() {
      return this.members.get(this.ownerId) ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.teamIcon(this.id, this.icon, options);
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({ createdTimestamp: true });
    }
  }
  module.exports = Team;
});

// node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js
var require_ApplicationCommandPermissionsManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { ApplicationCommandPermissionType, RESTJSONErrorCodes, Routes } = require_v106();
  var BaseManager = require_BaseManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();

  class ApplicationCommandPermissionsManager extends BaseManager {
    constructor(manager) {
      super(manager.client);
      this.manager = manager;
      this.guild = manager.guild ?? null;
      this.guildId = manager.guildId ?? manager.guild?.id ?? null;
      this.commandId = manager.id ?? null;
    }
    permissionsPath(guildId, commandId) {
      if (commandId) {
        return Routes.applicationCommandPermissions(this.client.application.id, guildId, commandId);
      }
      return Routes.guildApplicationCommandsPermissions(this.client.application.id, guildId);
    }
    async fetch({ guild, command } = {}) {
      const { guildId, commandId } = this._validateOptions(guild, command);
      if (commandId) {
        const data2 = await this.client.rest.get(this.permissionsPath(guildId, commandId));
        return data2.permissions;
      }
      const data = await this.client.rest.get(this.permissionsPath(guildId));
      return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions), new Collection);
    }
    async set({ guild, command, permissions, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!Array.isArray(permissions)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissions", "Array of ApplicationCommandPermissions", true);
      }
      if (!commandId) {
        commandId = this.client.user.id;
      }
      const data = await this.client.rest.put(this.permissionsPath(guildId, commandId), {
        body: { permissions },
        auth: false,
        headers: { Authorization: `Bearer ${token}` }
      });
      return data.permissions;
    }
    async add({ guild, command, permissions, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId) {
        commandId = this.client.user.id;
      }
      if (!Array.isArray(permissions)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissions", "Array of ApplicationCommandPermissions", true);
      }
      let existingPermissions = [];
      try {
        existingPermissions = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      const newPermissions = permissions.slice();
      for (const existingPermission of existingPermissions) {
        if (!newPermissions.some((newPermission) => newPermission.id === existingPermission.id)) {
          newPermissions.push(existingPermission);
        }
      }
      return this.set({ guild: guildId, command: commandId, permissions: newPermissions, token });
    }
    async remove({ guild, command, users, roles, channels, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId) {
        commandId = this.client.user.id;
      }
      if (!users && !roles && !channels) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "users OR roles OR channels", "Array or Resolvable", true);
      }
      let resolvedUserIds = [];
      if (Array.isArray(users)) {
        for (const user of users) {
          const userId = this.client.users.resolveId(user);
          if (!userId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "users", user);
          resolvedUserIds.push(userId);
        }
      }
      let resolvedRoleIds = [];
      if (Array.isArray(roles)) {
        for (const role of roles) {
          if (typeof role === "string") {
            resolvedRoleIds.push(role);
            continue;
          }
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "roles");
          const roleId = this.guild.roles.resolveId(role);
          if (!roleId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "users", role);
          resolvedRoleIds.push(roleId);
        }
      }
      let resolvedChannelIds = [];
      if (Array.isArray(channels)) {
        for (const channel of channels) {
          if (typeof channel === "string") {
            resolvedChannelIds.push(channel);
            continue;
          }
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "channels");
          const channelId = this.guild.channels.resolveId(channel);
          if (!channelId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "channels", channel);
          resolvedChannelIds.push(channelId);
        }
      }
      let existing = [];
      try {
        existing = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      const permissions = existing.filter((perm) => {
        switch (perm.type) {
          case ApplicationCommandPermissionType.Role:
            return !resolvedRoleIds.includes(perm.id);
          case ApplicationCommandPermissionType.User:
            return !resolvedUserIds.includes(perm.id);
          case ApplicationCommandPermissionType.Channel:
            return !resolvedChannelIds.includes(perm.id);
        }
        return true;
      });
      return this.set({ guild: guildId, command: commandId, permissions, token });
    }
    async has({ guild, command, permissionId, permissionType }) {
      const { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      if (!permissionId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissionId", "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant");
      }
      let resolvedId = permissionId;
      if (typeof permissionId !== "string") {
        resolvedId = this.client.users.resolveId(permissionId);
        if (!resolvedId) {
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "roles");
          resolvedId = this.guild.roles.resolveId(permissionId);
        }
        if (!resolvedId) {
          resolvedId = this.guild.channels.resolveId(permissionId);
        }
        if (!resolvedId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissionId", "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant");
        }
      }
      let existing = [];
      try {
        existing = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      return existing.some((perm) => perm.id === resolvedId && (permissionType ?? perm.type) === perm.type);
    }
    _validateOptions(guild, command) {
      const guildId = this.guildId ?? this.client.guilds.resolveId(guild);
      if (!guildId)
        throw new DiscordjsError(ErrorCodes.GlobalCommandPermissions);
      let commandId = this.commandId;
      if (command && !commandId) {
        commandId = this.manager.resolveId?.(command);
        if (!commandId && this.guild) {
          commandId = this.guild.commands.resolveId(command);
        }
        commandId ??= this.client.application?.commands.resolveId(command);
        if (!commandId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable", true);
        }
      }
      return { guildId, commandId };
    }
  }
  module.exports = ApplicationCommandPermissionsManager;
});

// node_modules/discord.js/src/structures/ApplicationCommand.js
var require_ApplicationCommand = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_dist3();
  var { ApplicationCommandOptionType } = require_v106();
  var isEqual = require_fast_deep_equal();
  var Base = require_Base();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  var PermissionsBitField = require_PermissionsBitField();

  class ApplicationCommand extends Base {
    constructor(client, data, guild, guildId) {
      super(client);
      this.id = data.id;
      this.applicationId = data.application_id;
      this.guild = guild ?? null;
      this.guildId = guild?.id ?? guildId ?? null;
      this.permissions = new ApplicationCommandPermissionsManager(this);
      this.type = data.type;
      this.nsfw = data.nsfw ?? false;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      if ("name_localizations" in data) {
        this.nameLocalizations = data.name_localizations;
      } else {
        this.nameLocalizations ??= null;
      }
      if ("name_localized" in data) {
        this.nameLocalized = data.name_localized;
      } else {
        this.nameLocalized ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("description_localizations" in data) {
        this.descriptionLocalizations = data.description_localizations;
      } else {
        this.descriptionLocalizations ??= null;
      }
      if ("description_localized" in data) {
        this.descriptionLocalized = data.description_localized;
      } else {
        this.descriptionLocalized ??= null;
      }
      if ("options" in data) {
        this.options = data.options.map((option) => this.constructor.transformOption(option, true));
      } else {
        this.options ??= [];
      }
      if ("default_member_permissions" in data) {
        this.defaultMemberPermissions = data.default_member_permissions ? new PermissionsBitField(BigInt(data.default_member_permissions)).freeze() : null;
      } else {
        this.defaultMemberPermissions ??= null;
      }
      if ("dm_permission" in data) {
        this.dmPermission = data.dm_permission;
      } else {
        this.dmPermission ??= null;
      }
      if ("version" in data) {
        this.version = data.version;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get manager() {
      return (this.guild ?? this.client.application).commands;
    }
    edit(data) {
      return this.manager.edit(this, data, this.guildId);
    }
    setName(name) {
      return this.edit({ name });
    }
    setNameLocalizations(nameLocalizations) {
      return this.edit({ nameLocalizations });
    }
    setDescription(description) {
      return this.edit({ description });
    }
    setDescriptionLocalizations(descriptionLocalizations) {
      return this.edit({ descriptionLocalizations });
    }
    setDefaultMemberPermissions(defaultMemberPermissions) {
      return this.edit({ defaultMemberPermissions });
    }
    setDMPermission(dmPermission = true) {
      return this.edit({ dmPermission });
    }
    setOptions(options) {
      return this.edit({ options });
    }
    delete() {
      return this.manager.delete(this, this.guildId);
    }
    equals(command, enforceOptionOrder = false) {
      if (command.id && this.id !== command.id)
        return false;
      let defaultMemberPermissions = null;
      let dmPermission = command.dmPermission ?? command.dm_permission;
      if ("default_member_permissions" in command) {
        defaultMemberPermissions = command.default_member_permissions ? new PermissionsBitField(BigInt(command.default_member_permissions)).bitfield : null;
      }
      if ("defaultMemberPermissions" in command) {
        defaultMemberPermissions = command.defaultMemberPermissions !== null ? new PermissionsBitField(command.defaultMemberPermissions).bitfield : null;
      }
      if (command.name !== this.name || "description" in command && command.description !== this.description || "version" in command && command.version !== this.version || command.type && command.type !== this.type || "nsfw" in command && command.nsfw !== this.nsfw || (command.options?.length ?? 0) !== (this.options?.length ?? 0) || defaultMemberPermissions !== (this.defaultMemberPermissions?.bitfield ?? null) || dmPermission !== undefined && dmPermission !== this.dmPermission || !isEqual(command.nameLocalizations ?? command.name_localizations ?? {}, this.nameLocalizations ?? {}) || !isEqual(command.descriptionLocalizations ?? command.description_localizations ?? {}, this.descriptionLocalizations ?? {})) {
        return false;
      }
      if (command.options) {
        return this.constructor.optionsEqual(this.options, command.options, enforceOptionOrder);
      }
      return true;
    }
    static optionsEqual(existing, options, enforceOptionOrder = false) {
      if (existing.length !== options.length)
        return false;
      if (enforceOptionOrder) {
        return existing.every((option, index) => this._optionEquals(option, options[index], enforceOptionOrder));
      }
      const newOptions = new Map(options.map((option) => [option.name, option]));
      for (const option of existing) {
        const foundOption = newOptions.get(option.name);
        if (!foundOption || !this._optionEquals(option, foundOption))
          return false;
      }
      return true;
    }
    static _optionEquals(existing, option, enforceOptionOrder = false) {
      if (option.name !== existing.name || option.type !== existing.type || option.description !== existing.description || option.autocomplete !== existing.autocomplete || (option.required ?? ([ApplicationCommandOptionType.Subcommand, ApplicationCommandOptionType.SubcommandGroup].includes(option.type) ? undefined : false)) !== existing.required || option.choices?.length !== existing.choices?.length || option.options?.length !== existing.options?.length || (option.channelTypes ?? option.channel_types)?.length !== existing.channelTypes?.length || (option.minValue ?? option.min_value) !== existing.minValue || (option.maxValue ?? option.max_value) !== existing.maxValue || (option.minLength ?? option.min_length) !== existing.minLength || (option.maxLength ?? option.max_length) !== existing.maxLength || !isEqual(option.nameLocalizations ?? option.name_localizations ?? {}, existing.nameLocalizations ?? {}) || !isEqual(option.descriptionLocalizations ?? option.description_localizations ?? {}, existing.descriptionLocalizations ?? {})) {
        return false;
      }
      if (existing.choices) {
        if (enforceOptionOrder && !existing.choices.every((choice, index) => choice.name === option.choices[index].name && choice.value === option.choices[index].value && isEqual(choice.nameLocalizations ?? {}, option.choices[index].nameLocalizations ?? option.choices[index].name_localizations ?? {}))) {
          return false;
        }
        if (!enforceOptionOrder) {
          const newChoices = new Map(option.choices.map((choice) => [choice.name, choice]));
          for (const choice of existing.choices) {
            const foundChoice = newChoices.get(choice.name);
            if (!foundChoice || foundChoice.value !== choice.value)
              return false;
          }
        }
      }
      if (existing.channelTypes) {
        const newTypes = option.channelTypes ?? option.channel_types;
        for (const type of existing.channelTypes) {
          if (!newTypes.includes(type))
            return false;
        }
      }
      if (existing.options) {
        return this.optionsEqual(existing.options, option.options, enforceOptionOrder);
      }
      return true;
    }
    static transformOption(option, received) {
      const channelTypesKey = received ? "channelTypes" : "channel_types";
      const minValueKey = received ? "minValue" : "min_value";
      const maxValueKey = received ? "maxValue" : "max_value";
      const minLengthKey = received ? "minLength" : "min_length";
      const maxLengthKey = received ? "maxLength" : "max_length";
      const nameLocalizationsKey = received ? "nameLocalizations" : "name_localizations";
      const nameLocalizedKey = received ? "nameLocalized" : "name_localized";
      const descriptionLocalizationsKey = received ? "descriptionLocalizations" : "description_localizations";
      const descriptionLocalizedKey = received ? "descriptionLocalized" : "description_localized";
      return {
        type: option.type,
        name: option.name,
        [nameLocalizationsKey]: option.nameLocalizations ?? option.name_localizations,
        [nameLocalizedKey]: option.nameLocalized ?? option.name_localized,
        description: option.description,
        [descriptionLocalizationsKey]: option.descriptionLocalizations ?? option.description_localizations,
        [descriptionLocalizedKey]: option.descriptionLocalized ?? option.description_localized,
        required: option.required ?? (option.type === ApplicationCommandOptionType.Subcommand || option.type === ApplicationCommandOptionType.SubcommandGroup ? undefined : false),
        autocomplete: option.autocomplete,
        choices: option.choices?.map((choice) => ({
          name: choice.name,
          [nameLocalizedKey]: choice.nameLocalized ?? choice.name_localized,
          [nameLocalizationsKey]: choice.nameLocalizations ?? choice.name_localizations,
          value: choice.value
        })),
        options: option.options?.map((opt) => this.transformOption(opt, received)),
        [channelTypesKey]: option.channelTypes ?? option.channel_types,
        [minValueKey]: option.minValue ?? option.min_value,
        [maxValueKey]: option.maxValue ?? option.max_value,
        [minLengthKey]: option.minLength ?? option.min_length,
        [maxLengthKey]: option.maxLength ?? option.max_length
      };
    }
  }
  module.exports = ApplicationCommand;
});

// node_modules/discord.js/src/managers/ApplicationCommandManager.js
var require_ApplicationCommandManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { makeURLSearchParams } = require_dist6();
  var { isJSONEncodable } = require_dist();
  var { Routes } = require_v106();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var ApplicationCommand = require_ApplicationCommand();
  var PermissionsBitField = require_PermissionsBitField();

  class ApplicationCommandManager extends CachedManager {
    constructor(client, iterable) {
      super(client, ApplicationCommand, iterable);
      this.permissions = new ApplicationCommandPermissionsManager(this);
    }
    _add(data, cache, guildId) {
      return super._add(data, cache, { extras: [this.guild, guildId] });
    }
    commandPath({ id, guildId } = {}) {
      if (this.guild ?? guildId) {
        if (id) {
          return Routes.applicationGuildCommand(this.client.application.id, this.guild?.id ?? guildId, id);
        }
        return Routes.applicationGuildCommands(this.client.application.id, this.guild?.id ?? guildId);
      }
      if (id) {
        return Routes.applicationCommand(this.client.application.id, id);
      }
      return Routes.applicationCommands(this.client.application.id);
    }
    async fetch(id, { guildId, cache = true, force = false, locale, withLocalizations } = {}) {
      if (typeof id === "object") {
        ({ guildId, cache = true, locale, withLocalizations } = id);
      } else if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const command = await this.client.rest.get(this.commandPath({ id, guildId }));
        return this._add(command, cache);
      }
      const data = await this.client.rest.get(this.commandPath({ guildId }), {
        headers: {
          "X-Discord-Locale": locale
        },
        query: makeURLSearchParams({ with_localizations: withLocalizations })
      });
      return data.reduce((coll, command) => coll.set(command.id, this._add(command, cache, guildId)), new Collection);
    }
    async create(command, guildId) {
      const data = await this.client.rest.post(this.commandPath({ guildId }), {
        body: this.constructor.transformCommand(command)
      });
      return this._add(data, true, guildId);
    }
    async set(commands, guildId) {
      const data = await this.client.rest.put(this.commandPath({ guildId }), {
        body: commands.map((command) => this.constructor.transformCommand(command))
      });
      return data.reduce((collection, command) => collection.set(command.id, this._add(command, true, guildId)), new Collection);
    }
    async edit(command, data, guildId) {
      const id = this.resolveId(command);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      const patched = await this.client.rest.patch(this.commandPath({ id, guildId }), {
        body: this.constructor.transformCommand(data)
      });
      return this._add(patched, true, guildId);
    }
    async delete(command, guildId) {
      const id = this.resolveId(command);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      await this.client.rest.delete(this.commandPath({ id, guildId }));
      const cached = this.cache.get(id);
      this.cache.delete(id);
      return cached ?? null;
    }
    static transformCommand(command) {
      if (isJSONEncodable(command))
        return command.toJSON();
      let default_member_permissions;
      if ("default_member_permissions" in command) {
        default_member_permissions = command.default_member_permissions ? new PermissionsBitField(BigInt(command.default_member_permissions)).bitfield.toString() : command.default_member_permissions;
      }
      if ("defaultMemberPermissions" in command) {
        default_member_permissions = command.defaultMemberPermissions !== null ? new PermissionsBitField(command.defaultMemberPermissions).bitfield.toString() : command.defaultMemberPermissions;
      }
      return {
        name: command.name,
        name_localizations: command.nameLocalizations ?? command.name_localizations,
        description: command.description,
        nsfw: command.nsfw,
        description_localizations: command.descriptionLocalizations ?? command.description_localizations,
        type: command.type,
        options: command.options?.map((option) => ApplicationCommand.transformOption(option)),
        default_member_permissions,
        dm_permission: command.dmPermission ?? command.dm_permission
      };
    }
  }
  module.exports = ApplicationCommandManager;
});

// node_modules/discord.js/src/util/ApplicationFlagsBitField.js
var require_ApplicationFlagsBitField = __commonJS((exports, module) => {
  var { ApplicationFlags } = require_v106();
  var BitField = require_BitField();

  class ApplicationFlagsBitField extends BitField {
    static Flags = ApplicationFlags;
  }
  module.exports = ApplicationFlagsBitField;
});

// node_modules/discord.js/src/structures/ClientApplication.js
var require_ClientApplication = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var { ApplicationRoleConnectionMetadata } = require_ApplicationRoleConnectionMetadata();
  var Team = require_Team();
  var Application = require_Application();
  var ApplicationCommandManager = require_ApplicationCommandManager();
  var ApplicationFlagsBitField = require_ApplicationFlagsBitField();
  var DataResolver = require_DataResolver();
  var PermissionsBitField = require_PermissionsBitField();

  class ClientApplication extends Application {
    constructor(client, data) {
      super(client, data);
      this.commands = new ApplicationCommandManager(this.client);
    }
    _patch(data) {
      super._patch(data);
      this.tags = data.tags ?? [];
      if ("install_params" in data) {
        this.installParams = {
          scopes: data.install_params.scopes,
          permissions: new PermissionsBitField(data.install_params.permissions).freeze()
        };
      } else {
        this.installParams ??= null;
      }
      if ("custom_install_url" in data) {
        this.customInstallURL = data.custom_install_url;
      } else {
        this.customInstallURL = null;
      }
      if ("flags" in data) {
        this.flags = new ApplicationFlagsBitField(data.flags).freeze();
      }
      if ("approximate_guild_count" in data) {
        this.approximateGuildCount = data.approximate_guild_count;
      } else {
        this.approximateGuildCount ??= null;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("cover_image" in data) {
        this.cover = data.cover_image;
      } else {
        this.cover ??= null;
      }
      if ("rpc_origins" in data) {
        this.rpcOrigins = data.rpc_origins;
      } else {
        this.rpcOrigins ??= [];
      }
      if ("bot_require_code_grant" in data) {
        this.botRequireCodeGrant = data.bot_require_code_grant;
      } else {
        this.botRequireCodeGrant ??= null;
      }
      if ("bot" in data) {
        this.bot = this.client.users._add(data.bot);
      } else {
        this.bot ??= null;
      }
      if ("bot_public" in data) {
        this.botPublic = data.bot_public;
      } else {
        this.botPublic ??= null;
      }
      if ("interactions_endpoint_url" in data) {
        this.interactionsEndpointURL = data.interactions_endpoint_url;
      } else {
        this.interactionsEndpointURL ??= null;
      }
      if ("role_connections_verification_url" in data) {
        this.roleConnectionsVerificationURL = data.role_connections_verification_url;
      } else {
        this.roleConnectionsVerificationURL ??= null;
      }
      this.owner = data.team ? new Team(this.client, data.team) : data.owner ? this.client.users._add(data.owner) : this.owner ?? null;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    get partial() {
      return !this.name;
    }
    async edit({
      customInstallURL,
      description,
      roleConnectionsVerificationURL,
      installParams,
      flags,
      icon,
      coverImage,
      interactionsEndpointURL,
      tags
    } = {}) {
      const data = await this.client.rest.patch(Routes.currentApplication(), {
        body: {
          custom_install_url: customInstallURL,
          description,
          role_connections_verification_url: roleConnectionsVerificationURL,
          install_params: installParams,
          flags: flags === undefined ? undefined : ApplicationFlagsBitField.resolve(flags),
          icon: icon && await DataResolver.resolveImage(icon),
          cover_image: coverImage && await DataResolver.resolveImage(coverImage),
          interactions_endpoint_url: interactionsEndpointURL,
          tags
        }
      });
      this._patch(data);
      return this;
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.currentApplication());
      this._patch(data);
      return this;
    }
    async fetchRoleConnectionMetadataRecords() {
      const metadata = await this.client.rest.get(Routes.applicationRoleConnectionMetadata(this.client.user.id));
      return metadata.map((data) => new ApplicationRoleConnectionMetadata(data));
    }
    async editRoleConnectionMetadataRecords(records) {
      const newRecords = await this.client.rest.put(Routes.applicationRoleConnectionMetadata(this.client.user.id), {
        body: records.map((record) => ({
          type: record.type,
          key: record.key,
          name: record.name,
          name_localizations: record.nameLocalizations,
          description: record.description,
          description_localizations: record.descriptionLocalizations
        }))
      });
      return newRecords.map((data) => new ApplicationRoleConnectionMetadata(data));
    }
  }
  module.exports = ClientApplication;
});

// node_modules/discord.js/src/structures/Embed.js
var require_Embed = __commonJS((exports, module) => {
  var { embedLength } = require_dist9();
  var isEqual = require_fast_deep_equal();

  class Embed {
    constructor(data) {
      this.data = { ...data };
    }
    get fields() {
      return this.data.fields ?? [];
    }
    get title() {
      return this.data.title ?? null;
    }
    get description() {
      return this.data.description ?? null;
    }
    get url() {
      return this.data.url ?? null;
    }
    get color() {
      return this.data.color ?? null;
    }
    get timestamp() {
      return this.data.timestamp ?? null;
    }
    get thumbnail() {
      if (!this.data.thumbnail)
        return null;
      return {
        url: this.data.thumbnail.url,
        proxyURL: this.data.thumbnail.proxy_url,
        height: this.data.thumbnail.height,
        width: this.data.thumbnail.width
      };
    }
    get image() {
      if (!this.data.image)
        return null;
      return {
        url: this.data.image.url,
        proxyURL: this.data.image.proxy_url,
        height: this.data.image.height,
        width: this.data.image.width
      };
    }
    get video() {
      if (!this.data.video)
        return null;
      return {
        url: this.data.video.url,
        proxyURL: this.data.video.proxy_url,
        height: this.data.video.height,
        width: this.data.video.width
      };
    }
    get author() {
      if (!this.data.author)
        return null;
      return {
        name: this.data.author.name,
        url: this.data.author.url,
        iconURL: this.data.author.icon_url,
        proxyIconURL: this.data.author.proxy_icon_url
      };
    }
    get provider() {
      return this.data.provider ?? null;
    }
    get footer() {
      if (!this.data.footer)
        return null;
      return {
        text: this.data.footer.text,
        iconURL: this.data.footer.icon_url,
        proxyIconURL: this.data.footer.proxy_icon_url
      };
    }
    get length() {
      return embedLength(this.data);
    }
    get hexColor() {
      return typeof this.data.color === "number" ? `#${this.data.color.toString(16).padStart(6, "0")}` : this.data.color ?? null;
    }
    toJSON() {
      return { ...this.data };
    }
    equals(other) {
      if (other instanceof Embed) {
        return isEqual(other.data, this.data);
      }
      return isEqual(other, this.data);
    }
  }
  module.exports = Embed;
});

// node_modules/discord.js/src/structures/MessageMentions.js
var require_MessageMentions = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { FormattingPatterns } = require_v106();
  var { flatten } = require_Util();

  class MessageMentions {
    static EveryonePattern = /@(?<mention>everyone|here)/;
    static UsersPattern = FormattingPatterns.UserWithOptionalNickname;
    static RolesPattern = FormattingPatterns.Role;
    static ChannelsPattern = FormattingPatterns.Channel;
    static GlobalChannelsPattern = new RegExp(this.ChannelsPattern.source, "g");
    static GlobalUsersPattern = new RegExp(this.UsersPattern.source, "g");
    constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {
      Object.defineProperty(this, "client", { value: message.client });
      Object.defineProperty(this, "guild", { value: message.guild });
      Object.defineProperty(this, "_content", { value: message.content });
      this.everyone = Boolean(everyone);
      if (users) {
        if (users instanceof Collection) {
          this.users = new Collection(users);
        } else {
          this.users = new Collection;
          for (const mention of users) {
            if (mention.member && message.guild) {
              message.guild.members._add(Object.assign(mention.member, { user: mention }));
            }
            const user = message.client.users._add(mention);
            this.users.set(user.id, user);
          }
        }
      } else {
        this.users = new Collection;
      }
      if (roles instanceof Collection) {
        this.roles = new Collection(roles);
      } else if (roles) {
        this.roles = new Collection;
        const guild = message.guild;
        if (guild) {
          for (const mention of roles) {
            const role = guild.roles.cache.get(mention);
            if (role)
              this.roles.set(role.id, role);
          }
        }
      } else {
        this.roles = new Collection;
      }
      this._members = null;
      this._channels = null;
      this._parsedUsers = null;
      if (crosspostedChannels) {
        if (crosspostedChannels instanceof Collection) {
          this.crosspostedChannels = new Collection(crosspostedChannels);
        } else {
          this.crosspostedChannels = new Collection;
          for (const crosspostedChannel of crosspostedChannels) {
            this.crosspostedChannels.set(crosspostedChannel.id, {
              channelId: crosspostedChannel.id,
              guildId: crosspostedChannel.guild_id,
              type: crosspostedChannel.type,
              name: crosspostedChannel.name
            });
          }
        }
      } else {
        this.crosspostedChannels = new Collection;
      }
      this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;
    }
    get members() {
      if (this._members)
        return this._members;
      if (!this.guild)
        return null;
      this._members = new Collection;
      this.users.forEach((user) => {
        const member = this.guild.members.resolve(user);
        if (member)
          this._members.set(member.user.id, member);
      });
      return this._members;
    }
    get channels() {
      if (this._channels)
        return this._channels;
      this._channels = new Collection;
      let matches;
      while ((matches = this.constructor.GlobalChannelsPattern.exec(this._content)) !== null) {
        const channel = this.client.channels.cache.get(matches.groups.id);
        if (channel)
          this._channels.set(channel.id, channel);
      }
      return this._channels;
    }
    get parsedUsers() {
      if (this._parsedUsers)
        return this._parsedUsers;
      this._parsedUsers = new Collection;
      let matches;
      while ((matches = this.constructor.GlobalUsersPattern.exec(this._content)) !== null) {
        const user = this.client.users.cache.get(matches[1]);
        if (user)
          this._parsedUsers.set(user.id, user);
      }
      return this._parsedUsers;
    }
    has(data, { ignoreDirect = false, ignoreRoles = false, ignoreRepliedUser = false, ignoreEveryone = false } = {}) {
      const user = this.client.users.resolve(data);
      if (!ignoreEveryone && user && this.everyone)
        return true;
      const userWasRepliedTo = user && this.repliedUser?.id === user.id;
      if (!ignoreRepliedUser && userWasRepliedTo && this.users.has(user.id))
        return true;
      if (!ignoreDirect) {
        if (user && (!ignoreRepliedUser || this.parsedUsers.has(user.id)) && this.users.has(user.id))
          return true;
        const role = this.guild?.roles.resolve(data);
        if (role && this.roles.has(role.id))
          return true;
        const channel = this.client.channels.resolve(data);
        if (channel && this.channels.has(channel.id))
          return true;
      }
      if (!ignoreRoles) {
        const member = this.guild?.members.resolve(data);
        if (member) {
          for (const mentionedRole of this.roles.values())
            if (member.roles.cache.has(mentionedRole.id))
              return true;
        }
      }
      return false;
    }
    toJSON() {
      return flatten(this, {
        members: true,
        channels: true
      });
    }
  }
  module.exports = MessageMentions;
});

// node_modules/discord.js/src/structures/ReactionCollector.js
var require_ReactionCollector = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var Collector = require_Collector();
  var Events = require_Events();

  class ReactionCollector extends Collector {
    constructor(message, options = {}) {
      super(message.client, options);
      this.message = message;
      this.users = new Collection;
      this.total = 0;
      this.empty = this.empty.bind(this);
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
      const bulkDeleteListener = (messages) => {
        if (messages.has(this.message.id))
          this.stop("messageDelete");
      };
      this.client.incrementMaxListeners();
      this.client.on(Events.MessageReactionAdd, this.handleCollect);
      this.client.on(Events.MessageReactionRemove, this.handleDispose);
      this.client.on(Events.MessageReactionRemoveAll, this.empty);
      this.client.on(Events.MessageDelete, this._handleMessageDeletion);
      this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
      this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events.MessageReactionAdd, this.handleCollect);
        this.client.removeListener(Events.MessageReactionRemove, this.handleDispose);
        this.client.removeListener(Events.MessageReactionRemoveAll, this.empty);
        this.client.removeListener(Events.MessageDelete, this._handleMessageDeletion);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
      this.on("collect", (reaction, user) => {
        if (reaction.count === 1) {
          this.emit("create", reaction, user);
        }
        this.total++;
        this.users.set(user.id, user);
      });
      this.on("remove", (_reaction, user) => {
        this.total--;
        if (!this.collected.some((reaction) => reaction.users.cache.has(user.id)))
          this.users.delete(user.id);
      });
    }
    collect(reaction) {
      if (reaction.message.id !== this.message.id)
        return null;
      return ReactionCollector.key(reaction);
    }
    dispose(reaction, user) {
      if (reaction.message.id !== this.message.id)
        return null;
      if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {
        this.emit("remove", reaction, user);
      }
      return reaction.count ? null : ReactionCollector.key(reaction);
    }
    empty() {
      this.total = 0;
      this.collected.clear();
      this.users.clear();
      this.checkEnd();
    }
    get endReason() {
      if (this.options.max && this.total >= this.options.max)
        return "limit";
      if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis)
        return "emojiLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return super.endReason;
    }
    _handleMessageDeletion(message) {
      if (message.id === this.message.id) {
        this.stop("messageDelete");
      }
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.message.channelId || channel.threads?.cache.has(this.message.channelId)) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.message.channelId) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.message.guild?.id) {
        this.stop("guildDelete");
      }
    }
    static key(reaction) {
      return reaction.emoji.id ?? reaction.emoji.name;
    }
  }
  module.exports = ReactionCollector;
});

// node_modules/discord.js/src/structures/Sticker.js
var require_Sticker = __commonJS((exports) => {
  var { DiscordSnowflake } = require_dist3();
  var { Routes } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var { StickerFormatExtensionMap } = require_Constants();

  class Sticker extends Base {
    constructor(client, sticker) {
      super(client);
      this._patch(sticker);
    }
    _patch(sticker) {
      this.id = sticker.id;
      if ("description" in sticker) {
        this.description = sticker.description;
      } else {
        this.description ??= null;
      }
      if ("type" in sticker) {
        this.type = sticker.type;
      } else {
        this.type ??= null;
      }
      if ("format_type" in sticker) {
        this.format = sticker.format_type;
      }
      if ("name" in sticker) {
        this.name = sticker.name;
      }
      if ("pack_id" in sticker) {
        this.packId = sticker.pack_id;
      } else {
        this.packId ??= null;
      }
      if ("tags" in sticker) {
        this.tags = sticker.tags;
      } else {
        this.tags ??= null;
      }
      if ("available" in sticker) {
        this.available = sticker.available;
      } else {
        this.available ??= null;
      }
      if ("guild_id" in sticker) {
        this.guildId = sticker.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("user" in sticker) {
        this.user = this.client.users._add(sticker.user);
      } else {
        this.user ??= null;
      }
      if ("sort_value" in sticker) {
        this.sortValue = sticker.sort_value;
      } else {
        this.sortValue ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get partial() {
      return !this.type;
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return this.client.rest.cdn.sticker(this.id, StickerFormatExtensionMap[this.format]);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.sticker(this.id));
      this._patch(data);
      return this;
    }
    async fetchPack() {
      return (this.packId && (await this.client.fetchStickerPacks()).get(this.packId)) ?? null;
    }
    async fetchUser() {
      if (this.partial)
        await this.fetch();
      if (!this.guildId)
        throw new DiscordjsError(ErrorCodes.NotGuildSticker);
      return this.guild.stickers.fetchUser(this);
    }
    edit(options) {
      return this.guild.stickers.edit(this, options);
    }
    async delete(reason) {
      await this.guild.stickers.delete(this, reason);
      return this;
    }
    equals(other) {
      if (other instanceof Sticker) {
        return other.id === this.id && other.description === this.description && other.type === this.type && other.format === this.format && other.name === this.name && other.packId === this.packId && other.tags === this.tags && other.available === this.available && other.guildId === this.guildId && other.sortValue === this.sortValue;
      } else {
        return other.id === this.id && other.description === this.description && other.name === this.name && other.tags === this.tags;
      }
    }
  }
  exports.Sticker = Sticker;
});

// node_modules/discord.js/src/structures/BaseGuildEmoji.js
var require_BaseGuildEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();

  class BaseGuildEmoji extends Emoji {
    constructor(client, data, guild) {
      super(client, data);
      this.guild = guild;
      this.requiresColons = null;
      this.managed = null;
      this.available = null;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data)
        this.name = data.name;
      if ("require_colons" in data) {
        this.requiresColons = data.require_colons;
      }
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("available" in data) {
        this.available = data.available;
      }
    }
  }
  module.exports = BaseGuildEmoji;
});

// node_modules/discord.js/src/managers/GuildEmojiRoleManager.js
var require_GuildEmojiRoleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var DataManager = require_DataManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Role } = require_Role();

  class GuildEmojiRoleManager extends DataManager {
    constructor(emoji) {
      super(emoji.client, Role);
      this.emoji = emoji;
      this.guild = emoji.guild;
    }
    get cache() {
      return this.guild.roles.cache.filter((role) => this.emoji._roles.includes(role.id));
    }
    add(roleOrRoles) {
      if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection))
        roleOrRoles = [roleOrRoles];
      const resolvedRoles = [];
      for (const role of roleOrRoles.values()) {
        const resolvedRole = this.guild.roles.resolveId(role);
        if (!resolvedRole) {
          return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role));
        }
        resolvedRoles.push(resolvedRole);
      }
      const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
      return this.set(newRoles);
    }
    remove(roleOrRoles) {
      if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection))
        roleOrRoles = [roleOrRoles];
      const resolvedRoleIds = [];
      for (const role of roleOrRoles.values()) {
        const roleId = this.guild.roles.resolveId(role);
        if (!roleId) {
          return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role));
        }
        resolvedRoleIds.push(roleId);
      }
      const newRoles = [...this.cache.keys()].filter((id) => !resolvedRoleIds.includes(id));
      return this.set(newRoles);
    }
    set(roles) {
      return this.emoji.edit({ roles });
    }
    clone() {
      const clone = new this.constructor(this.emoji);
      clone._patch([...this.cache.keys()]);
      return clone;
    }
    _patch(roles) {
      this.emoji._roles = roles;
    }
    valueOf() {
      return this.cache;
    }
  }
  module.exports = GuildEmojiRoleManager;
});

// node_modules/discord.js/src/structures/GuildEmoji.js
var require_GuildEmoji = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BaseGuildEmoji = require_BaseGuildEmoji();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var GuildEmojiRoleManager = require_GuildEmojiRoleManager();

  class GuildEmoji extends BaseGuildEmoji {
    constructor(client, data, guild) {
      super(client, data, guild);
      this.author = null;
      Object.defineProperty(this, "_roles", { value: [], writable: true });
      this._patch(data);
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    _patch(data) {
      super._patch(data);
      if (data.user)
        this.author = this.client.users._add(data.user);
      if (data.roles)
        this._roles = data.roles;
    }
    get deletable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return !this.managed && this.guild.members.me.permissions.has(PermissionFlagsBits.ManageGuildExpressions);
    }
    get roles() {
      return new GuildEmojiRoleManager(this);
    }
    fetchAuthor() {
      return this.guild.emojis.fetchAuthor(this);
    }
    edit(options) {
      return this.guild.emojis.edit(this.id, options);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    async delete(reason) {
      await this.guild.emojis.delete(this.id, reason);
      return this;
    }
    equals(other) {
      if (other instanceof GuildEmoji) {
        return other.id === this.id && other.name === this.name && other.managed === this.managed && other.available === this.available && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every((role) => this.roles.cache.has(role.id));
      } else {
        return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every((role) => this.roles.cache.has(role));
      }
    }
  }
  module.exports = GuildEmoji;
});

// node_modules/discord.js/src/structures/ReactionEmoji.js
var require_ReactionEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();
  var { flatten } = require_Util();

  class ReactionEmoji extends Emoji {
    constructor(reaction, emoji) {
      super(reaction.message.client, emoji);
      this.reaction = reaction;
    }
    toJSON() {
      return flatten(this, { identifier: true });
    }
    valueOf() {
      return this.id;
    }
  }
  module.exports = ReactionEmoji;
});

// node_modules/discord.js/src/util/UserFlagsBitField.js
var require_UserFlagsBitField = __commonJS((exports, module) => {
  var { UserFlags } = require_v106();
  var BitField = require_BitField();

  class UserFlagsBitField extends BitField {
    static Flags = UserFlags;
  }
  module.exports = UserFlagsBitField;
});

// node_modules/discord.js/src/structures/User.js
var require_User = __commonJS((exports, module) => {
  var { userMention } = require_dist8();
  var { calculateUserDefaultAvatarIndex } = require_dist6();
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();
  var TextBasedChannel = require_TextBasedChannel();
  var UserFlagsBitField = require_UserFlagsBitField();

  class User extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.bot = null;
      this.system = null;
      this.flags = null;
      this._patch(data);
    }
    _patch(data) {
      if ("username" in data) {
        this.username = data.username;
      } else {
        this.username ??= null;
      }
      if ("global_name" in data) {
        this.globalName = data.global_name;
      } else {
        this.globalName ??= null;
      }
      if ("bot" in data) {
        this.bot = Boolean(data.bot);
      } else if (!this.partial && typeof this.bot !== "boolean") {
        this.bot = false;
      }
      if ("discriminator" in data) {
        this.discriminator = data.discriminator;
      } else {
        this.discriminator ??= null;
      }
      if ("avatar" in data) {
        this.avatar = data.avatar;
      } else {
        this.avatar ??= null;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      } else if (this.banner !== null) {
        this.banner ??= undefined;
      }
      if ("accent_color" in data) {
        this.accentColor = data.accent_color;
      } else if (this.accentColor !== null) {
        this.accentColor ??= undefined;
      }
      if ("system" in data) {
        this.system = Boolean(data.system);
      } else if (!this.partial && typeof this.system !== "boolean") {
        this.system = false;
      }
      if ("public_flags" in data) {
        this.flags = new UserFlagsBitField(data.public_flags);
      }
      if ("avatar_decoration" in data) {
        this.avatarDecoration = data.avatar_decoration;
      } else {
        this.avatarDecoration ??= null;
      }
    }
    get partial() {
      return typeof this.username !== "string";
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
    }
    avatarDecorationURL(options = {}) {
      return this.avatarDecoration && this.client.rest.cdn.avatarDecoration(this.id, this.avatarDecoration, options);
    }
    get defaultAvatarURL() {
      const index = this.discriminator === "0" ? calculateUserDefaultAvatarIndex(this.id) : this.discriminator % 5;
      return this.client.rest.cdn.defaultAvatar(index);
    }
    displayAvatarURL(options) {
      return this.avatarURL(options) ?? this.defaultAvatarURL;
    }
    get hexAccentColor() {
      if (typeof this.accentColor !== "number")
        return this.accentColor;
      return `#${this.accentColor.toString(16).padStart(6, "0")}`;
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
    }
    get tag() {
      return typeof this.username === "string" ? this.discriminator === "0" ? this.username : `${this.username}#${this.discriminator}` : null;
    }
    get displayName() {
      return this.globalName ?? this.username;
    }
    get dmChannel() {
      return this.client.users.dmChannel(this.id);
    }
    createDM(force = false) {
      return this.client.users.createDM(this.id, { force });
    }
    deleteDM() {
      return this.client.users.deleteDM(this.id);
    }
    equals(user) {
      return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.globalName && this.avatar === user.avatar && this.flags?.bitfield === user.flags?.bitfield && this.banner === user.banner && this.accentColor === user.accentColor;
    }
    _equals(user) {
      return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.global_name && this.avatar === user.avatar && this.flags?.bitfield === user.public_flags && ("banner" in user ? this.banner === user.banner : true) && ("accent_color" in user ? this.accentColor === user.accent_color : true);
    }
    fetchFlags(force = false) {
      return this.client.users.fetchFlags(this.id, { force });
    }
    fetch(force = true) {
      return this.client.users.fetch(this.id, { force });
    }
    toString() {
      return userMention(this.id);
    }
    toJSON(...props) {
      const json = super.toJSON({
        createdTimestamp: true,
        defaultAvatarURL: true,
        hexAccentColor: true,
        tag: true
      }, ...props);
      json.avatarURL = this.avatarURL();
      json.displayAvatarURL = this.displayAvatarURL();
      json.bannerURL = this.banner ? this.bannerURL() : this.banner;
      return json;
    }
  }
  TextBasedChannel.applyToClass(User);
  module.exports = User;
});

// node_modules/discord.js/src/managers/ReactionUserManager.js
var require_ReactionUserManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { makeURLSearchParams } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var User = require_User();

  class ReactionUserManager extends CachedManager {
    constructor(reaction, iterable) {
      super(reaction.client, User, iterable);
      this.reaction = reaction;
    }
    async fetch({ limit = 100, after } = {}) {
      const message = this.reaction.message;
      const query = makeURLSearchParams({ limit, after });
      const data = await this.client.rest.get(Routes.channelMessageReaction(message.channelId, message.id, this.reaction.emoji.identifier), { query });
      const users = new Collection;
      for (const rawUser of data) {
        const user = this.client.users._add(rawUser);
        this.cache.set(user.id, user);
        users.set(user.id, user);
      }
      return users;
    }
    async remove(user = this.client.user) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        throw new DiscordjsError(ErrorCodes.ReactionResolveUser);
      const message = this.reaction.message;
      const route = userId === this.client.user.id ? Routes.channelMessageOwnReaction(message.channelId, message.id, this.reaction.emoji.identifier) : Routes.channelMessageUserReaction(message.channelId, message.id, this.reaction.emoji.identifier, userId);
      await this.client.rest.delete(route);
      return this.reaction;
    }
  }
  module.exports = ReactionUserManager;
});

// node_modules/discord.js/src/structures/MessageReaction.js
var require_MessageReaction = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var ReactionUserManager = require_ReactionUserManager();
  var { flatten } = require_Util();

  class MessageReaction {
    constructor(client, data, message) {
      Object.defineProperty(this, "client", { value: client });
      this.message = message;
      this.me = data.me;
      this.users = new ReactionUserManager(this, this.me ? [client.user] : []);
      this._emoji = new ReactionEmoji(this, data.emoji);
      this._patch(data);
    }
    _patch(data) {
      if ("count" in data) {
        this.count ??= data.count;
      }
    }
    react() {
      return this.message.react(this.emoji);
    }
    async remove() {
      await this.client.rest.delete(Routes.channelMessageReaction(this.message.channelId, this.message.id, this._emoji.identifier));
      return this;
    }
    get emoji() {
      if (this._emoji instanceof GuildEmoji)
        return this._emoji;
      if (this._emoji.id) {
        const emojis = this.message.client.emojis.cache;
        if (emojis.has(this._emoji.id)) {
          const emoji = emojis.get(this._emoji.id);
          this._emoji = emoji;
          return emoji;
        }
      }
      return this._emoji;
    }
    get partial() {
      return this.count === null;
    }
    async fetch() {
      const message = await this.message.fetch();
      const existing = message.reactions.cache.get(this.emoji.id ?? this.emoji.name);
      this._patch(existing ?? { count: 0 });
      return this;
    }
    toJSON() {
      return flatten(this, { emoji: "emojiId", message: "messageId" });
    }
    valueOf() {
      return this._emoji.id ?? this._emoji.name;
    }
    _add(user) {
      if (this.partial)
        return;
      this.users.cache.set(user.id, user);
      if (!this.me || user.id !== this.message.client.user.id || this.count === 0)
        this.count++;
      this.me ||= user.id === this.message.client.user.id;
    }
    _remove(user) {
      if (this.partial)
        return;
      this.users.cache.delete(user.id);
      if (!this.me || user.id !== this.message.client.user.id)
        this.count--;
      if (user.id === this.message.client.user.id)
        this.me = false;
      if (this.count <= 0 && this.users.cache.size === 0) {
        this.message.reactions.cache.delete(this.emoji.id ?? this.emoji.name);
      }
    }
  }
  module.exports = MessageReaction;
});

// node_modules/discord.js/src/managers/ReactionManager.js
var require_ReactionManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var MessageReaction = require_MessageReaction();

  class ReactionManager extends CachedManager {
    constructor(message, iterable) {
      super(message.client, MessageReaction, iterable);
      this.message = message;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.emoji.id ?? data.emoji.name, extras: [this.message] });
    }
    async removeAll() {
      await this.client.rest.delete(Routes.channelMessageAllReactions(this.message.channelId, this.message.id));
      return this.message;
    }
  }
  module.exports = ReactionManager;
});

// node_modules/discord.js/src/structures/Message.js
var require_Message = __commonJS((exports) => {
  var { Collection } = require_dist7();
  var { messageLink } = require_dist8();
  var { DiscordSnowflake } = require_dist3();
  var {
    InteractionType,
    ChannelType,
    MessageType,
    MessageFlags,
    PermissionFlagsBits
  } = require_v106();
  var Attachment = require_Attachment();
  var Base = require_Base();
  var ClientApplication = require_ClientApplication();
  var Embed = require_Embed();
  var InteractionCollector = require_InteractionCollector();
  var Mentions = require_MessageMentions();
  var MessagePayload = require_MessagePayload();
  var ReactionCollector = require_ReactionCollector();
  var { Sticker } = require_Sticker();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var ReactionManager = require_ReactionManager();
  var { createComponent } = require_Components();
  var { NonSystemMessageTypes, MaxBulkDeletableMessageAge, DeletableMessageTypes } = require_Constants();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var PermissionsBitField = require_PermissionsBitField();
  var { cleanContent, resolvePartialEmoji, transformResolved } = require_Util();

  class Message extends Base {
    constructor(client, data) {
      super(client);
      this.channelId = data.channel_id;
      this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);
      if ("type" in data) {
        this.type = data.type;
        this.system = !NonSystemMessageTypes.includes(this.type);
      } else {
        this.system ??= null;
        this.type ??= null;
      }
      if ("content" in data) {
        this.content = data.content;
      } else {
        this.content ??= null;
      }
      if ("author" in data) {
        this.author = this.client.users._add(data.author, !data.webhook_id);
      } else {
        this.author ??= null;
      }
      if ("pinned" in data) {
        this.pinned = Boolean(data.pinned);
      } else {
        this.pinned ??= null;
      }
      if ("tts" in data) {
        this.tts = data.tts;
      } else {
        this.tts ??= null;
      }
      if ("nonce" in data) {
        this.nonce = data.nonce;
      } else {
        this.nonce ??= null;
      }
      if ("embeds" in data) {
        this.embeds = data.embeds.map((embed) => new Embed(embed));
      } else {
        this.embeds = this.embeds?.slice() ?? [];
      }
      if ("components" in data) {
        this.components = data.components.map((component) => createComponent(component));
      } else {
        this.components = this.components?.slice() ?? [];
      }
      if ("attachments" in data) {
        this.attachments = new Collection;
        if (data.attachments) {
          for (const attachment of data.attachments) {
            this.attachments.set(attachment.id, new Attachment(attachment));
          }
        }
      } else {
        this.attachments = new Collection(this.attachments);
      }
      if ("sticker_items" in data || "stickers" in data) {
        this.stickers = new Collection((data.sticker_items ?? data.stickers)?.map((sticker) => [sticker.id, new Sticker(this.client, sticker)]));
      } else {
        this.stickers = new Collection(this.stickers);
      }
      if ("position" in data) {
        this.position = data.position;
      } else {
        this.position ??= null;
      }
      if ("role_subscription_data" in data) {
        this.roleSubscriptionData = {
          roleSubscriptionListingId: data.role_subscription_data.role_subscription_listing_id,
          tierName: data.role_subscription_data.tier_name,
          totalMonthsSubscribed: data.role_subscription_data.total_months_subscribed,
          isRenewal: data.role_subscription_data.is_renewal
        };
      } else {
        this.roleSubscriptionData ??= null;
      }
      if ("resolved" in data) {
        this.resolved = transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.resolved);
      } else {
        this.resolved ??= null;
      }
      if (data.edited_timestamp) {
        this.editedTimestamp = Date.parse(data.edited_timestamp);
      } else {
        this.editedTimestamp ??= null;
      }
      if ("reactions" in data) {
        this.reactions = new ReactionManager(this);
        if (data.reactions?.length > 0) {
          for (const reaction of data.reactions) {
            this.reactions._add(reaction);
          }
        }
      } else {
        this.reactions ??= new ReactionManager(this);
      }
      if (!this.mentions) {
        this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels, data.referenced_message?.author);
      } else {
        this.mentions = new Mentions(this, data.mentions ?? this.mentions.users, data.mention_roles ?? this.mentions.roles, data.mention_everyone ?? this.mentions.everyone, data.mention_channels ?? this.mentions.crosspostedChannels, data.referenced_message?.author ?? this.mentions.repliedUser);
      }
      if ("webhook_id" in data) {
        this.webhookId = data.webhook_id;
      } else {
        this.webhookId ??= null;
      }
      if ("application" in data) {
        this.groupActivityApplication = new ClientApplication(this.client, data.application);
      } else {
        this.groupActivityApplication ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      } else {
        this.applicationId ??= null;
      }
      if ("activity" in data) {
        this.activity = {
          partyId: data.activity.party_id,
          type: data.activity.type
        };
      } else {
        this.activity ??= null;
      }
      if ("thread" in data) {
        this.client.channels._add(data.thread, this.guild);
      }
      if (this.member && data.member) {
        this.member._patch(data.member);
      } else if (data.member && this.guild && this.author) {
        this.guild.members._add(Object.assign(data.member, { user: this.author }));
      }
      if ("flags" in data) {
        this.flags = new MessageFlagsBitField(data.flags).freeze();
      } else {
        this.flags = new MessageFlagsBitField(this.flags).freeze();
      }
      if ("message_reference" in data) {
        this.reference = {
          channelId: data.message_reference.channel_id,
          guildId: data.message_reference.guild_id,
          messageId: data.message_reference.message_id
        };
      } else {
        this.reference ??= null;
      }
      if (data.referenced_message) {
        this.channel?.messages._add({ guild_id: data.message_reference?.guild_id, ...data.referenced_message });
      }
      if (data.interaction) {
        this.interaction = {
          id: data.interaction.id,
          type: data.interaction.type,
          commandName: data.interaction.name,
          user: this.client.users._add(data.interaction.user)
        };
      } else {
        this.interaction ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get partial() {
      return typeof this.content !== "string" || !this.author;
    }
    get member() {
      return this.guild?.members.resolve(this.author) ?? null;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get editedAt() {
      return this.editedTimestamp && new Date(this.editedTimestamp);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;
    }
    get hasThread() {
      return this.flags.has(MessageFlags.HasThread);
    }
    get thread() {
      return this.channel?.threads?.resolve(this.id) ?? null;
    }
    get url() {
      return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);
    }
    get cleanContent() {
      return this.content != null ? cleanContent(this.content, this.channel) : null;
    }
    createReactionCollector(options = {}) {
      return new ReactionCollector(this, options);
    }
    awaitReactions(options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createReactionCollector(options);
        collector.once("end", (reactions, reason) => {
          if (options.errors?.includes(reason))
            reject(reactions);
          else
            resolve(reactions);
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionType: InteractionType.MessageComponent,
        message: this
      });
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    get editable() {
      const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || this.channel?.viewable));
      if (this.channel?.isThread()) {
        if (this.channel.archived)
          return false;
        if (this.channel.locked) {
          const permissions = this.channel.permissionsFor(this.client.user);
          if (!permissions?.has(PermissionFlagsBits.ManageThreads, true))
            return false;
        }
      }
      return precheck;
    }
    get deletable() {
      if (!DeletableMessageTypes.includes(this.type))
        return false;
      if (!this.guild) {
        return this.author.id === this.client.user.id;
      }
      if (!this.channel?.viewable) {
        return false;
      }
      const permissions = this.channel?.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.type !== MessageType.AutoModerationAction && this.author.id === this.client.user.id || permissions.has(PermissionFlagsBits.ManageMessages, false) && !this.guild.members.me.isCommunicationDisabled();
    }
    get bulkDeletable() {
      return (this.inGuild() && Date.now() - this.createdTimestamp < MaxBulkDeletableMessageAge && this.deletable && this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageMessages, false)) ?? false;
    }
    get pinnable() {
      const { channel } = this;
      return Boolean(!this.system && (!this.guild || channel?.viewable && channel?.permissionsFor(this.client.user)?.has(PermissionFlagsBits.ManageMessages, false)));
    }
    async fetchReference() {
      if (!this.reference)
        throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);
      const { channelId, messageId } = this.reference;
      const channel = this.client.channels.resolve(channelId);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      const message = await channel.messages.fetch(messageId);
      return message;
    }
    get crosspostable() {
      const bitfield = PermissionFlagsBits.SendMessages | (this.author.id === this.client.user.id ? PermissionsBitField.DefaultBit : PermissionFlagsBits.ManageMessages);
      const { channel } = this;
      return Boolean(channel?.type === ChannelType.GuildAnnouncement && !this.flags.has(MessageFlags.Crossposted) && this.type === MessageType.Default && channel.viewable && channel.permissionsFor(this.client.user)?.has(bitfield, false));
    }
    edit(options) {
      if (!this.channel)
        return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
      return this.channel.messages.edit(this, options);
    }
    crosspost() {
      if (!this.channel)
        return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
      return this.channel.messages.crosspost(this.id);
    }
    async pin(reason) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.pin(this.id, reason);
      return this;
    }
    async unpin(reason) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.unpin(this.id, reason);
      return this;
    }
    async react(emoji) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.react(this.id, emoji);
      return this.client.actions.MessageReactionAdd.handle({
        [this.client.actions.injectedUser]: this.client.user,
        [this.client.actions.injectedChannel]: this.channel,
        [this.client.actions.injectedMessage]: this,
        emoji: resolvePartialEmoji(emoji)
      }, true).reaction;
    }
    async delete() {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.delete(this.id);
      return this;
    }
    reply(options) {
      if (!this.channel)
        return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
      let data;
      if (options instanceof MessagePayload) {
        data = options;
      } else {
        data = MessagePayload.create(this, options, {
          reply: {
            messageReference: this,
            failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists
          }
        });
      }
      return this.channel.send(data);
    }
    startThread(options = {}) {
      if (!this.channel)
        return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
      if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {
        return Promise.reject(new DiscordjsError(ErrorCodes.MessageThreadParent));
      }
      if (this.hasThread)
        return Promise.reject(new DiscordjsError(ErrorCodes.MessageExistingThread));
      return this.channel.threads.create({ ...options, startMessage: this });
    }
    fetch(force = true) {
      if (!this.channel)
        return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
      return this.channel.messages.fetch({ message: this.id, force });
    }
    fetchWebhook() {
      if (!this.webhookId)
        return Promise.reject(new DiscordjsError(ErrorCodes.WebhookMessage));
      if (this.webhookId === this.applicationId)
        return Promise.reject(new DiscordjsError(ErrorCodes.WebhookApplication));
      return this.client.fetchWebhook(this.webhookId);
    }
    suppressEmbeds(suppress = true) {
      const flags = new MessageFlagsBitField(this.flags.bitfield);
      if (suppress) {
        flags.add(MessageFlags.SuppressEmbeds);
      } else {
        flags.remove(MessageFlags.SuppressEmbeds);
      }
      return this.edit({ flags });
    }
    removeAttachments() {
      return this.edit({ attachments: [] });
    }
    resolveComponent(customId) {
      return this.components.flatMap((row) => row.components).find((component) => component.customId === customId) ?? null;
    }
    equals(message, rawData) {
      if (!message)
        return false;
      const embedUpdate = !message.author && !message.attachments;
      if (embedUpdate)
        return this.id === message.id && this.embeds.length === message.embeds.length;
      let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;
      if (equal && rawData) {
        equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === Date.parse(rawData.timestamp) && this.editedTimestamp === Date.parse(rawData.edited_timestamp);
      }
      return equal;
    }
    inGuild() {
      return Boolean(this.guildId);
    }
    toString() {
      return this.content;
    }
    toJSON() {
      return super.toJSON({
        channel: "channelId",
        author: "authorId",
        groupActivityApplication: "groupActivityApplicationId",
        guild: "guildId",
        cleanContent: true,
        member: false,
        reactions: false
      });
    }
  }
  exports.Message = Message;
});

// node_modules/discord.js/src/structures/Webhook.js
var require_Webhook = __commonJS((exports, module) => {
  var { makeURLSearchParams } = require_dist6();
  var { lazy } = require_dist();
  var { DiscordSnowflake } = require_dist3();
  var { Routes, WebhookType } = require_v106();
  var MessagePayload = require_MessagePayload();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var DataResolver = require_DataResolver();
  var getMessage = lazy(() => require_Message().Message);

  class Webhook {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      Object.defineProperty(this, "token", {
        value: data.token ?? null,
        writable: true,
        configurable: true
      });
      if ("avatar" in data) {
        this.avatar = data.avatar;
      }
      this.id = data.id;
      if ("type" in data) {
        this.type = data.type;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("user" in data) {
        this.owner = this.client.users?._add(data.user) ?? data.user;
      } else {
        this.owner ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      } else {
        this.applicationId ??= null;
      }
      if ("source_guild" in data) {
        this.sourceGuild = this.client.guilds?.resolve(data.source_guild.id) ?? data.source_guild;
      } else {
        this.sourceGuild ??= null;
      }
      if ("source_channel" in data) {
        this.sourceChannel = this.client.channels?.resolve(data.source_channel?.id) ?? data.source_channel;
      } else {
        this.sourceChannel ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    async send(options) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      let messagePayload;
      if (options instanceof MessagePayload) {
        messagePayload = options.resolveBody();
      } else {
        messagePayload = MessagePayload.create(this, options).resolveBody();
      }
      const query = makeURLSearchParams({
        wait: true,
        thread_id: messagePayload.options.threadId
      });
      const { body, files } = await messagePayload.resolveFiles();
      const d = await this.client.rest.post(Routes.webhook(this.id, this.token), {
        body,
        files,
        query,
        auth: false
      });
      if (!this.client.channels)
        return d;
      return this.client.channels.cache.get(d.channel_id)?.messages._add(d, false) ?? new (getMessage())(this.client, d);
    }
    async sendSlackMessage(body) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      const data = await this.client.rest.post(Routes.webhookPlatform(this.id, this.token, "slack"), {
        query: makeURLSearchParams({ wait: true }),
        auth: false,
        body
      });
      return data.toString() === "ok";
    }
    async edit({ name = this.name, avatar, channel, reason }) {
      if (avatar && !(typeof avatar === "string" && avatar.startsWith("data:"))) {
        avatar = await DataResolver.resolveImage(avatar);
      }
      channel &&= channel.id ?? channel;
      const data = await this.client.rest.patch(Routes.webhook(this.id, channel ? undefined : this.token), {
        body: { name, avatar, channel_id: channel },
        reason,
        auth: !this.token || Boolean(channel)
      });
      this.name = data.name;
      this.avatar = data.avatar;
      this.channelId = data.channel_id;
      return this;
    }
    async fetchMessage(message, { threadId } = {}) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      const data = await this.client.rest.get(Routes.webhookMessage(this.id, this.token, message), {
        query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,
        auth: false
      });
      if (!this.client.channels)
        return data;
      return this.client.channels.cache.get(data.channel_id)?.messages._add(data, false) ?? new (getMessage())(this.client, data);
    }
    async editMessage(message, options) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body, files } = await messagePayload.resolveBody().resolveFiles();
      const d = await this.client.rest.patch(Routes.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id), {
        body,
        files,
        query: messagePayload.options.threadId ? makeURLSearchParams({ thread_id: messagePayload.options.threadId }) : undefined,
        auth: false
      });
      const channelManager = this.client.channels;
      if (!channelManager)
        return d;
      const messageManager = channelManager.cache.get(d.channel_id)?.messages;
      if (!messageManager)
        return new (getMessage())(this.client, d);
      const existing = messageManager.cache.get(d.id);
      if (!existing)
        return messageManager._add(d);
      const clone = existing._clone();
      clone._patch(d);
      return clone;
    }
    delete(reason) {
      return this.client.deleteWebhook(this.id, { token: this.token, reason });
    }
    async deleteMessage(message, threadId) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      await this.client.rest.delete(Routes.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id), {
        query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,
        auth: false
      });
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get url() {
      return this.client.options.rest.api + Routes.webhook(this.id, this.token);
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
    }
    isUserCreated() {
      return Boolean(this.type === WebhookType.Incoming && this.owner && !this.owner.bot);
    }
    isApplicationCreated() {
      return this.type === WebhookType.Application;
    }
    isChannelFollower() {
      return this.type === WebhookType.ChannelFollower;
    }
    isIncoming() {
      return this.type === WebhookType.Incoming;
    }
    static applyToClass(structure, ignore = []) {
      for (const prop of [
        "send",
        "sendSlackMessage",
        "fetchMessage",
        "edit",
        "editMessage",
        "delete",
        "deleteMessage",
        "createdTimestamp",
        "createdAt",
        "url"
      ]) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));
      }
    }
  }
  module.exports = Webhook;
});

// node_modules/discord.js/src/client/WebhookClient.js
var require_WebhookClient = __commonJS((exports, module) => {
  var BaseClient = require_BaseClient();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var Webhook = require_Webhook();
  var { parseWebhookURL } = require_Util();

  class WebhookClient extends BaseClient {
    constructor(data, options) {
      super(options);
      Object.defineProperty(this, "client", { value: this });
      let { id, token } = data;
      if ("url" in data) {
        const parsed = parseWebhookURL(data.url);
        if (!parsed) {
          throw new DiscordjsError(ErrorCodes.WebhookURLInvalid);
        }
        ({ id, token } = parsed);
      }
      this.id = id;
      Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
    }
    send() {
    }
    fetchMessage() {
    }
    editMessage() {
    }
    sendSlackMessage() {
    }
    edit() {
    }
    delete() {
    }
    deleteMessage() {
    }
    get createdTimestamp() {
    }
    get createdAt() {
    }
    get url() {
    }
  }
  Webhook.applyToClass(WebhookClient);
  module.exports = WebhookClient;
});

// node_modules/discord.js/src/structures/VoiceState.js
var require_VoiceState = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();

  class VoiceState extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.id = data.user_id;
      this._patch(data);
    }
    _patch(data) {
      if ("deaf" in data) {
        this.serverDeaf = data.deaf;
      } else {
        this.serverDeaf ??= null;
      }
      if ("mute" in data) {
        this.serverMute = data.mute;
      } else {
        this.serverMute ??= null;
      }
      if ("self_deaf" in data) {
        this.selfDeaf = data.self_deaf;
      } else {
        this.selfDeaf ??= null;
      }
      if ("self_mute" in data) {
        this.selfMute = data.self_mute;
      } else {
        this.selfMute ??= null;
      }
      if ("self_video" in data) {
        this.selfVideo = data.self_video;
      } else {
        this.selfVideo ??= null;
      }
      if ("session_id" in data) {
        this.sessionId = data.session_id;
      } else {
        this.sessionId ??= null;
      }
      if ("self_video" in data) {
        this.streaming = data.self_stream ?? false;
      } else {
        this.streaming ??= null;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      } else {
        this.channelId ??= null;
      }
      if ("suppress" in data) {
        this.suppress = data.suppress;
      } else {
        this.suppress ??= null;
      }
      if ("request_to_speak_timestamp" in data) {
        this.requestToSpeakTimestamp = data.request_to_speak_timestamp && Date.parse(data.request_to_speak_timestamp);
      } else {
        this.requestToSpeakTimestamp ??= null;
      }
      return this;
    }
    get member() {
      return this.guild.members.cache.get(this.id) ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get deaf() {
      return this.serverDeaf || this.selfDeaf;
    }
    get mute() {
      return this.serverMute || this.selfMute;
    }
    setMute(mute = true, reason) {
      return this.guild.members.edit(this.id, { mute, reason });
    }
    setDeaf(deaf = true, reason) {
      return this.guild.members.edit(this.id, { deaf, reason });
    }
    disconnect(reason) {
      return this.setChannel(null, reason);
    }
    setChannel(channel, reason) {
      return this.guild.members.edit(this.id, { channel, reason });
    }
    async edit(options) {
      if (this.channel?.type !== ChannelType.GuildStageVoice)
        throw new DiscordjsError(ErrorCodes.VoiceNotStageChannel);
      const target = this.client.user.id === this.id ? "@me" : this.id;
      if (target !== "@me" && options.requestToSpeak !== undefined) {
        throw new DiscordjsError(ErrorCodes.VoiceStateNotOwn);
      }
      if (!["boolean", "undefined"].includes(typeof options.requestToSpeak)) {
        throw new DiscordjsTypeError(ErrorCodes.VoiceStateInvalidType, "requestToSpeak");
      }
      if (!["boolean", "undefined"].includes(typeof options.suppressed)) {
        throw new DiscordjsTypeError(ErrorCodes.VoiceStateInvalidType, "suppressed");
      }
      await this.client.rest.patch(Routes.guildVoiceState(this.guild.id, target), {
        body: {
          channel_id: this.channelId,
          request_to_speak_timestamp: options.requestToSpeak ? new Date().toISOString() : options.requestToSpeak === false ? null : undefined,
          suppress: options.suppressed
        }
      });
      return this;
    }
    setRequestToSpeak(requestToSpeak = true) {
      return this.edit({ requestToSpeak });
    }
    setSuppressed(suppressed = true) {
      return this.edit({ suppressed });
    }
    toJSON() {
      return super.toJSON({
        id: true,
        serverDeaf: true,
        serverMute: true,
        selfDeaf: true,
        selfMute: true,
        sessionId: true,
        channelId: "channel"
      });
    }
  }
  module.exports = VoiceState;
});

// node_modules/discord.js/src/managers/GuildMemberRoleManager.js
var require_GuildMemberRoleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { Routes } = require_v106();
  var DataManager = require_DataManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Role } = require_Role();

  class GuildMemberRoleManager extends DataManager {
    constructor(member) {
      super(member.client, Role);
      this.member = member;
      this.guild = member.guild;
    }
    get cache() {
      const everyone = this.guild.roles.everyone;
      return this.guild.roles.cache.filter((role) => this.member._roles.includes(role.id)).set(everyone.id, everyone);
    }
    get hoist() {
      const hoistedRoles = this.cache.filter((role) => role.hoist);
      if (!hoistedRoles.size)
        return null;
      return hoistedRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get icon() {
      const iconRoles = this.cache.filter((role) => role.icon || role.unicodeEmoji);
      if (!iconRoles.size)
        return null;
      return iconRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get color() {
      const coloredRoles = this.cache.filter((role) => role.color);
      if (!coloredRoles.size)
        return null;
      return coloredRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get highest() {
      return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
    }
    get premiumSubscriberRole() {
      return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
    }
    get botRole() {
      if (!this.member.user.bot)
        return null;
      return this.cache.find((role) => role.tags?.botId === this.member.user.id) ?? null;
    }
    async add(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
        if (roleOrRoles === null) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
        }
        await this.client.rest.put(Routes.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
        const clone = this.member._clone();
        clone._roles = [...this.cache.keys(), roleOrRoles];
        return clone;
      }
    }
    async remove(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = this.cache.filter((role) => !resolvedRoles.includes(role.id));
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
        if (roleOrRoles === null) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
        }
        await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
        const clone = this.member._clone();
        const newRoles = this.cache.filter((role) => role.id !== roleOrRoles);
        clone._roles = [...newRoles.keys()];
        return clone;
      }
    }
    set(roles, reason) {
      return this.member.edit({ roles, reason });
    }
    clone() {
      const clone = new this.constructor(this.member);
      clone.member._roles = [...this.cache.keys()];
      return clone;
    }
  }
  module.exports = GuildMemberRoleManager;
});

// node_modules/discord.js/src/util/GuildMemberFlagsBitField.js
var require_GuildMemberFlagsBitField = __commonJS((exports) => {
  var { GuildMemberFlags } = require_v106();
  var BitField = require_BitField();

  class GuildMemberFlagsBitField extends BitField {
    static Flags = GuildMemberFlags;
  }
  exports.GuildMemberFlagsBitField = GuildMemberFlagsBitField;
});

// node_modules/discord.js/src/structures/GuildMember.js
var require_GuildMember = __commonJS((exports) => {
  var { PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var VoiceState = require_VoiceState();
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var GuildMemberRoleManager = require_GuildMemberRoleManager();
  var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
  var PermissionsBitField = require_PermissionsBitField();

  class GuildMember extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.joinedTimestamp = null;
      this.premiumSinceTimestamp = null;
      this.nickname = null;
      this.pending = null;
      this.communicationDisabledUntilTimestamp = null;
      Object.defineProperty(this, "_roles", { value: [], writable: true });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if ("user" in data) {
        this.user = this.client.users._add(data.user, true);
      }
      if ("nick" in data)
        this.nickname = data.nick;
      if ("avatar" in data) {
        this.avatar = data.avatar;
      } else if (typeof this.avatar !== "string") {
        this.avatar = null;
      }
      if ("joined_at" in data)
        this.joinedTimestamp = Date.parse(data.joined_at);
      if ("premium_since" in data) {
        this.premiumSinceTimestamp = data.premium_since ? Date.parse(data.premium_since) : null;
      }
      if ("roles" in data)
        this._roles = data.roles;
      if ("pending" in data) {
        this.pending = data.pending;
      } else if (!this.partial) {
        this.pending ??= false;
      }
      if ("communication_disabled_until" in data) {
        this.communicationDisabledUntilTimestamp = data.communication_disabled_until && Date.parse(data.communication_disabled_until);
      }
      if ("flags" in data) {
        this.flags = new GuildMemberFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new GuildMemberFlagsBitField().freeze();
      }
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    get partial() {
      return this.joinedTimestamp === null;
    }
    get roles() {
      return new GuildMemberRoleManager(this);
    }
    get voice() {
      return this.guild.voiceStates.cache.get(this.id) ?? new VoiceState(this.guild, { user_id: this.id });
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.guildMemberAvatar(this.guild.id, this.id, this.avatar, options);
    }
    displayAvatarURL(options) {
      return this.avatarURL(options) ?? this.user.displayAvatarURL(options);
    }
    get joinedAt() {
      return this.joinedTimestamp && new Date(this.joinedTimestamp);
    }
    get communicationDisabledUntil() {
      return this.communicationDisabledUntilTimestamp && new Date(this.communicationDisabledUntilTimestamp);
    }
    get premiumSince() {
      return this.premiumSinceTimestamp && new Date(this.premiumSinceTimestamp);
    }
    get presence() {
      return this.guild.presences.resolve(this.id);
    }
    get displayColor() {
      return this.roles.color?.color ?? 0;
    }
    get displayHexColor() {
      return this.roles.color?.hexColor ?? "#000000";
    }
    get id() {
      return this.user.id;
    }
    get dmChannel() {
      return this.client.users.dmChannel(this.id);
    }
    get displayName() {
      return this.nickname ?? this.user.displayName;
    }
    get permissions() {
      if (this.user.id === this.guild.ownerId)
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      return new PermissionsBitField(this.roles.cache.map((role) => role.permissions)).freeze();
    }
    get manageable() {
      if (this.user.id === this.guild.ownerId)
        return false;
      if (this.user.id === this.client.user.id)
        return false;
      if (this.client.user.id === this.guild.ownerId)
        return true;
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.guild.members.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
    }
    get kickable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.KickMembers);
    }
    get bannable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.BanMembers);
    }
    get moderatable() {
      return !this.permissions.has(PermissionFlagsBits.Administrator) && this.manageable && (this.guild.members.me?.permissions.has(PermissionFlagsBits.ModerateMembers) ?? false);
    }
    isCommunicationDisabled() {
      return this.communicationDisabledUntilTimestamp > Date.now();
    }
    permissionsIn(channel) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      return channel.permissionsFor(this);
    }
    edit(options) {
      return this.guild.members.edit(this, options);
    }
    setFlags(flags, reason) {
      return this.edit({ flags, reason });
    }
    setNickname(nick, reason) {
      return this.edit({ nick, reason });
    }
    createDM(force = false) {
      return this.user.createDM(force);
    }
    deleteDM() {
      return this.user.deleteDM();
    }
    kick(reason) {
      return this.guild.members.kick(this, reason);
    }
    ban(options) {
      return this.guild.bans.create(this, options);
    }
    disableCommunicationUntil(communicationDisabledUntil, reason) {
      return this.edit({ communicationDisabledUntil, reason });
    }
    timeout(timeout, reason) {
      return this.disableCommunicationUntil(timeout && Date.now() + timeout, reason);
    }
    fetch(force = true) {
      return this.guild.members.fetch({ user: this.id, cache: true, force });
    }
    equals(member) {
      return member instanceof this.constructor && this.id === member.id && this.partial === member.partial && this.guild.id === member.guild.id && this.joinedTimestamp === member.joinedTimestamp && this.nickname === member.nickname && this.avatar === member.avatar && this.pending === member.pending && this.communicationDisabledUntilTimestamp === member.communicationDisabledUntilTimestamp && this.flags.bitfield === member.flags.bitfield && (this._roles === member._roles || this._roles.length === member._roles.length && this._roles.every((role, i) => role === member._roles[i]));
    }
    toString() {
      return this.user.toString();
    }
    toJSON() {
      const json = super.toJSON({
        guild: "guildId",
        user: "userId",
        displayName: true,
        roles: true
      });
      json.avatarURL = this.avatarURL();
      json.displayAvatarURL = this.displayAvatarURL();
      return json;
    }
  }
  TextBasedChannel.applyToClass(GuildMember);
  exports.GuildMember = GuildMember;
});

// node_modules/discord.js/src/managers/MessageManager.js
var require_MessageManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { makeURLSearchParams } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Message } = require_Message();
  var MessagePayload = require_MessagePayload();
  var { MakeCacheOverrideSymbol } = require_Symbols();
  var { resolvePartialEmoji } = require_Util();

  class MessageManager extends CachedManager {
    static [MakeCacheOverrideSymbol] = MessageManager;
    constructor(channel, iterable) {
      super(channel.client, Message, iterable);
      this.channel = channel;
    }
    _add(data, cache) {
      return super._add(data, cache);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { message, cache, force } = options;
      const resolvedMessage = this.resolveId(message ?? options);
      if (resolvedMessage)
        return this._fetchSingle({ message: resolvedMessage, cache, force });
      return this._fetchMany(options);
    }
    async _fetchSingle({ message, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(message);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.channelMessage(this.channel.id, message));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.channelMessages(this.channel.id), {
        query: makeURLSearchParams(options)
      });
      return data.reduce((_data, message) => _data.set(message.id, this._add(message, options.cache)), new Collection);
    }
    async fetchPinned(cache = true) {
      const data = await this.client.rest.get(Routes.channelPins(this.channel.id));
      const messages = new Collection;
      for (const message of data)
        messages.set(message.id, this._add(message, cache));
      return messages;
    }
    async edit(message, options) {
      const messageId = this.resolveId(message);
      if (!messageId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      const { body, files } = await (options instanceof MessagePayload ? options : MessagePayload.create(message instanceof Message ? message : this, options)).resolveBody().resolveFiles();
      const d = await this.client.rest.patch(Routes.channelMessage(this.channel.id, messageId), { body, files });
      const existing = this.cache.get(messageId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      return this._add(d);
    }
    async crosspost(message) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      const data = await this.client.rest.post(Routes.channelMessageCrosspost(this.channel.id, message));
      return this.cache.get(data.id) ?? this._add(data);
    }
    async pin(message, reason) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.put(Routes.channelPin(this.channel.id, message), { reason });
    }
    async unpin(message, reason) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.delete(Routes.channelPin(this.channel.id, message), { reason });
    }
    async react(message, emoji) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      emoji = resolvePartialEmoji(emoji);
      if (!emoji)
        throw new DiscordjsTypeError(ErrorCodes.EmojiType, "emoji", "EmojiIdentifierResolvable");
      const emojiId = emoji.id ? `${emoji.animated ? "a:" : ""}${emoji.name}:${emoji.id}` : encodeURIComponent(emoji.name);
      await this.client.rest.put(Routes.channelMessageOwnReaction(this.channel.id, message, emojiId));
    }
    async delete(message) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.delete(Routes.channelMessage(this.channel.id, message));
    }
  }
  module.exports = MessageManager;
});

// node_modules/discord.js/src/structures/InteractionWebhook.js
var require_InteractionWebhook = __commonJS((exports, module) => {
  var Webhook = require_Webhook();

  class InteractionWebhook {
    constructor(client, id, token) {
      Object.defineProperty(this, "client", { value: client });
      this.id = id;
      Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
    }
    send() {
    }
    fetchMessage() {
    }
    editMessage() {
    }
    deleteMessage() {
    }
    get url() {
    }
  }
  Webhook.applyToClass(InteractionWebhook, ["sendSlackMessage", "edit", "delete", "createdTimestamp", "createdAt"]);
  module.exports = InteractionWebhook;
});

// node_modules/discord.js/src/structures/MessagePayload.js
var require_MessagePayload = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  var { lazy, isJSONEncodable } = require_dist();
  var { MessageFlags } = require_v106();
  var ActionRowBuilder = require_ActionRowBuilder();
  var { DiscordjsRangeError, ErrorCodes } = require_errors2();
  var DataResolver = require_DataResolver();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var { basename, verifyString } = require_Util();
  var getBaseInteraction = lazy(() => require_BaseInteraction());

  class MessagePayload {
    constructor(target, options) {
      this.target = target;
      this.options = options;
      this.body = null;
      this.files = null;
    }
    get isWebhook() {
      const Webhook = require_Webhook();
      const WebhookClient = require_WebhookClient();
      return this.target instanceof Webhook || this.target instanceof WebhookClient;
    }
    get isUser() {
      const User = require_User();
      const { GuildMember } = require_GuildMember();
      return this.target instanceof User || this.target instanceof GuildMember;
    }
    get isMessage() {
      const { Message } = require_Message();
      return this.target instanceof Message;
    }
    get isMessageManager() {
      const MessageManager = require_MessageManager();
      return this.target instanceof MessageManager;
    }
    get isInteraction() {
      const BaseInteraction = getBaseInteraction();
      const InteractionWebhook = require_InteractionWebhook();
      return this.target instanceof BaseInteraction || this.target instanceof InteractionWebhook;
    }
    makeContent() {
      let content;
      if (this.options.content === null) {
        content = "";
      } else if (this.options.content !== undefined) {
        content = verifyString(this.options.content, DiscordjsRangeError, ErrorCodes.MessageContentType, true);
      }
      return content;
    }
    resolveBody() {
      if (this.body)
        return this;
      const isInteraction = this.isInteraction;
      const isWebhook = this.isWebhook;
      const content = this.makeContent();
      const tts = Boolean(this.options.tts);
      let nonce;
      if (this.options.nonce !== undefined) {
        nonce = this.options.nonce;
        if (typeof nonce === "number" ? !Number.isInteger(nonce) : typeof nonce !== "string") {
          throw new DiscordjsRangeError(ErrorCodes.MessageNonceType);
        }
      }
      const components = this.options.components?.map((component) => (isJSONEncodable(component) ? component : new ActionRowBuilder(component)).toJSON());
      let username;
      let avatarURL;
      let threadName;
      if (isWebhook) {
        username = this.options.username ?? this.target.name;
        if (this.options.avatarURL)
          avatarURL = this.options.avatarURL;
        if (this.options.threadName)
          threadName = this.options.threadName;
      }
      let flags;
      if (this.options.flags !== undefined || this.isMessage && this.options.reply === undefined || this.isMessageManager) {
        flags = this.options.flags != null ? new MessageFlagsBitField(this.options.flags).bitfield : this.target.flags?.bitfield;
      }
      if (isInteraction && this.options.ephemeral) {
        flags |= MessageFlags.Ephemeral;
      }
      let allowedMentions = this.options.allowedMentions === undefined ? this.target.client.options.allowedMentions : this.options.allowedMentions;
      if (allowedMentions?.repliedUser !== undefined) {
        allowedMentions = { ...allowedMentions, replied_user: allowedMentions.repliedUser };
        delete allowedMentions.repliedUser;
      }
      let message_reference;
      if (typeof this.options.reply === "object") {
        const reference = this.options.reply.messageReference;
        const message_id = this.isMessage ? reference.id ?? reference : this.target.messages.resolveId(reference);
        if (message_id) {
          message_reference = {
            message_id,
            fail_if_not_exists: this.options.reply.failIfNotExists ?? this.target.client.options.failIfNotExists
          };
        }
      }
      const attachments = this.options.files?.map((file, index) => ({
        id: index.toString(),
        description: file.description
      }));
      if (Array.isArray(this.options.attachments)) {
        this.options.attachments.push(...attachments ?? []);
      } else {
        this.options.attachments = attachments;
      }
      this.body = {
        content,
        tts,
        nonce,
        embeds: this.options.embeds?.map((embed) => isJSONEncodable(embed) ? embed.toJSON() : this.target.client.options.jsonTransformer(embed)),
        components,
        username,
        avatar_url: avatarURL,
        allowed_mentions: content === undefined && message_reference === undefined ? undefined : allowedMentions,
        flags,
        message_reference,
        attachments: this.options.attachments,
        sticker_ids: this.options.stickers?.map((sticker) => sticker.id ?? sticker),
        thread_name: threadName
      };
      return this;
    }
    async resolveFiles() {
      if (this.files)
        return this;
      this.files = await Promise.all(this.options.files?.map((file) => this.constructor.resolveFile(file)) ?? []);
      return this;
    }
    static async resolveFile(fileLike) {
      let attachment;
      let name;
      const findName = (thing) => {
        if (typeof thing === "string") {
          return basename(thing);
        }
        if (thing.path) {
          return basename(thing.path);
        }
        return "file.jpg";
      };
      const ownAttachment = typeof fileLike === "string" || fileLike instanceof Buffer2 || typeof fileLike.pipe === "function";
      if (ownAttachment) {
        attachment = fileLike;
        name = findName(attachment);
      } else {
        attachment = fileLike.attachment;
        name = fileLike.name ?? findName(attachment);
      }
      const { data, contentType } = await DataResolver.resolveFile(attachment);
      return { data, name, contentType };
    }
    static create(target, options, extra = {}) {
      return new this(target, typeof options !== "object" || options === null ? { content: options, ...extra } : { ...options, ...extra });
    }
  }
  module.exports = MessagePayload;
});

// node_modules/discord.js/src/managers/GuildMessageManager.js
var require_GuildMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class GuildMessageManager extends MessageManager {
  }
  module.exports = GuildMessageManager;
});

// node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js
var require_TextBasedChannel = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { DiscordSnowflake } = require_dist3();
  var { InteractionType, Routes } = require_v106();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var { MaxBulkDeletableMessageAge } = require_Constants();
  var InteractionCollector = require_InteractionCollector();
  var MessageCollector = require_MessageCollector();
  var MessagePayload = require_MessagePayload();

  class TextBasedChannel {
    constructor() {
      this.messages = new GuildMessageManager(this);
      this.lastMessageId = null;
      this.lastPinTimestamp = null;
    }
    get lastMessage() {
      return this.messages.resolve(this.lastMessageId);
    }
    get lastPinAt() {
      return this.lastPinTimestamp && new Date(this.lastPinTimestamp);
    }
    async send(options) {
      const User = require_User();
      const { GuildMember } = require_GuildMember();
      if (this instanceof User || this instanceof GuildMember) {
        const dm = await this.createDM();
        return dm.send(options);
      }
      let messagePayload;
      if (options instanceof MessagePayload) {
        messagePayload = options.resolveBody();
      } else {
        messagePayload = MessagePayload.create(this, options).resolveBody();
      }
      const { body, files } = await messagePayload.resolveFiles();
      const d = await this.client.rest.post(Routes.channelMessages(this.id), { body, files });
      return this.messages.cache.get(d.id) ?? this.messages._add(d);
    }
    async sendTyping() {
      await this.client.rest.post(Routes.channelTyping(this.id));
    }
    createMessageCollector(options = {}) {
      return new MessageCollector(this, options);
    }
    awaitMessages(options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createMessageCollector(options);
        collector.once("end", (collection, reason) => {
          if (options.errors?.includes(reason)) {
            reject(collection);
          } else {
            resolve(collection);
          }
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionType: InteractionType.MessageComponent,
        channel: this
      });
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    async bulkDelete(messages, filterOld = false) {
      if (Array.isArray(messages) || messages instanceof Collection) {
        let messageIds = messages instanceof Collection ? [...messages.keys()] : messages.map((message) => message.id ?? message);
        if (filterOld) {
          messageIds = messageIds.filter((id) => Date.now() - DiscordSnowflake.timestampFrom(id) < MaxBulkDeletableMessageAge);
        }
        if (messageIds.length === 0)
          return new Collection;
        if (messageIds.length === 1) {
          const message = this.client.actions.MessageDelete.getMessage({
            message_id: messageIds[0]
          }, this);
          await this.client.rest.delete(Routes.channelMessage(this.id, messageIds[0]));
          return message ? new Collection([[message.id, message]]) : new Collection;
        }
        await this.client.rest.post(Routes.channelBulkDelete(this.id), { body: { messages: messageIds } });
        return messageIds.reduce((col, id) => col.set(id, this.client.actions.MessageDeleteBulk.getMessage({
          message_id: id
        }, this)), new Collection);
      }
      if (!isNaN(messages)) {
        const msgs = await this.messages.fetch({ limit: messages });
        return this.bulkDelete(msgs, filterOld);
      }
      throw new DiscordjsTypeError(ErrorCodes.MessageBulkDeleteType);
    }
    fetchWebhooks() {
      return this.guild.channels.fetchWebhooks(this.id);
    }
    createWebhook(options) {
      return this.guild.channels.createWebhook({ channel: this.id, ...options });
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
    setNSFW(nsfw = true, reason) {
      return this.edit({ nsfw, reason });
    }
    static applyToClass(structure, full = false, ignore = []) {
      const props = ["send"];
      if (full) {
        props.push("lastMessage", "lastPinAt", "bulkDelete", "sendTyping", "createMessageCollector", "awaitMessages", "createMessageComponentCollector", "awaitMessageComponent", "fetchWebhooks", "createWebhook", "setRateLimitPerUser", "setNSFW");
      }
      for (const prop of props) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));
      }
    }
  }
  module.exports = TextBasedChannel;
  var GuildMessageManager = require_GuildMessageManager();
});

// node_modules/discord.js/src/managers/DMMessageManager.js
var require_DMMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class DMMessageManager extends MessageManager {
  }
  module.exports = DMMessageManager;
});

// node_modules/discord.js/src/structures/DMChannel.js
var require_DMChannel = __commonJS((exports, module) => {
  var { userMention } = require_dist8();
  var { ChannelType } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var DMMessageManager = require_DMMessageManager();
  var Partials = require_Partials();

  class DMChannel extends BaseChannel {
    constructor(client, data) {
      super(client, data);
      this.type = ChannelType.DM;
      this.messages = new DMMessageManager(this);
    }
    _patch(data) {
      super._patch(data);
      if (data.recipients) {
        const recipient = data.recipients[0];
        this.recipientId = recipient.id;
        if ("username" in recipient || this.client.options.partials.includes(Partials.User)) {
          this.client.users._add(recipient);
        }
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = Date.parse(data.last_pin_timestamp);
      } else {
        this.lastPinTimestamp ??= null;
      }
    }
    get partial() {
      return this.lastMessageId === undefined;
    }
    get recipient() {
      return this.client.users.resolve(this.recipientId);
    }
    fetch(force = true) {
      return this.client.users.createDM(this.recipientId, { force });
    }
    toString() {
      return userMention(this.recipientId);
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
  }
  TextBasedChannel.applyToClass(DMChannel, true, [
    "bulkDelete",
    "fetchWebhooks",
    "createWebhook",
    "setRateLimitPerUser",
    "setNSFW"
  ]);
  module.exports = DMChannel;
});

// node_modules/discord.js/src/managers/GuildForumThreadManager.js
var require_GuildForumThreadManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var ThreadManager = require_ThreadManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var MessagePayload = require_MessagePayload();

  class GuildForumThreadManager extends ThreadManager {
    async create({
      name,
      autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
      message,
      reason,
      rateLimitPerUser,
      appliedTags
    } = {}) {
      if (!message) {
        throw new DiscordjsTypeError(ErrorCodes.GuildForumMessageRequired);
      }
      const { body, files } = await (message instanceof MessagePayload ? message : MessagePayload.create(this, message)).resolveBody().resolveFiles();
      const data = await this.client.rest.post(Routes.threads(this.channel.id), {
        body: {
          name,
          auto_archive_duration: autoArchiveDuration,
          rate_limit_per_user: rateLimitPerUser,
          applied_tags: appliedTags,
          message: body
        },
        files,
        reason
      });
      return this.client.actions.ThreadCreate.handle(data).thread;
    }
  }
  module.exports = GuildForumThreadManager;
});

// node_modules/discord.js/src/structures/ThreadOnlyChannel.js
var require_ThreadOnlyChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildForumThreadManager = require_GuildForumThreadManager();
  var { transformAPIGuildForumTag, transformAPIGuildDefaultReaction } = require_Channels();

  class ThreadOnlyChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.threads = new GuildForumThreadManager(this);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("available_tags" in data) {
        this.availableTags = data.available_tags.map((tag) => transformAPIGuildForumTag(tag));
      } else {
        this.availableTags ??= [];
      }
      if ("default_reaction_emoji" in data) {
        this.defaultReactionEmoji = data.default_reaction_emoji ? transformAPIGuildDefaultReaction(data.default_reaction_emoji) : null;
      } else {
        this.defaultReactionEmoji ??= null;
      }
      if ("default_thread_rate_limit_per_user" in data) {
        this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
      } else {
        this.defaultThreadRateLimitPerUser ??= null;
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      } else {
        this.rateLimitPerUser ??= null;
      }
      if ("default_auto_archive_duration" in data) {
        this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
      } else {
        this.defaultAutoArchiveDuration ??= null;
      }
      if ("nsfw" in data) {
        this.nsfw = data.nsfw;
      } else {
        this.nsfw ??= false;
      }
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("default_sort_order" in data) {
        this.defaultSortOrder = data.default_sort_order;
      } else {
        this.defaultSortOrder ??= null;
      }
    }
    setAvailableTags(availableTags, reason) {
      return this.edit({ availableTags, reason });
    }
    setDefaultReactionEmoji(defaultReactionEmoji, reason) {
      return this.edit({ defaultReactionEmoji, reason });
    }
    setDefaultThreadRateLimitPerUser(defaultThreadRateLimitPerUser, reason) {
      return this.edit({ defaultThreadRateLimitPerUser, reason });
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
      return this.edit({ defaultAutoArchiveDuration, reason });
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
    setDefaultSortOrder(defaultSortOrder, reason) {
      return this.edit({ defaultSortOrder, reason });
    }
    createWebhook() {
    }
    fetchWebhooks() {
    }
    setNSFW() {
    }
    setRateLimitPerUser() {
    }
  }
  TextBasedChannel.applyToClass(ThreadOnlyChannel, true, [
    "send",
    "lastMessage",
    "lastPinAt",
    "bulkDelete",
    "sendTyping",
    "createMessageCollector",
    "awaitMessages",
    "createMessageComponentCollector",
    "awaitMessageComponent"
  ]);
  module.exports = ThreadOnlyChannel;
});

// node_modules/discord.js/src/util/ThreadMemberFlagsBitField.js
var require_ThreadMemberFlagsBitField = __commonJS((exports, module) => {
  var BitField = require_BitField();

  class ThreadMemberFlagsBitField extends BitField {
    static Flags = {};
  }
  module.exports = ThreadMemberFlagsBitField;
});

// node_modules/discord.js/src/structures/ThreadMember.js
var require_ThreadMember = __commonJS((exports, module) => {
  var Base = require_Base();
  var ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();

  class ThreadMember extends Base {
    constructor(thread, data, extra = {}) {
      super(thread.client);
      this.thread = thread;
      this.joinedTimestamp = null;
      this.flags = null;
      this.id = data.user_id;
      this._patch(data, extra);
    }
    _patch(data, extra = {}) {
      if ("join_timestamp" in data)
        this.joinedTimestamp = Date.parse(data.join_timestamp);
      if ("flags" in data)
        this.flags = new ThreadMemberFlagsBitField(data.flags).freeze();
      if ("member" in data) {
        this.member = this.thread.guild.members._add(data.member, extra.cache);
      } else {
        this.member ??= null;
      }
    }
    get partial() {
      return this.flags === null;
    }
    get guildMember() {
      return this.member ?? this.thread.guild.members.resolve(this.id);
    }
    get joinedAt() {
      return this.joinedTimestamp && new Date(this.joinedTimestamp);
    }
    get user() {
      return this.client.users.resolve(this.id);
    }
    get manageable() {
      return !this.thread.archived && this.thread.editable;
    }
    async remove(reason) {
      await this.thread.members.remove(this.id, reason);
      return this;
    }
  }
  module.exports = ThreadMember;
});

// node_modules/discord.js/src/managers/ThreadMemberManager.js
var require_ThreadMemberManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { makeURLSearchParams } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var ThreadMember = require_ThreadMember();

  class ThreadMemberManager extends CachedManager {
    constructor(thread, iterable) {
      super(thread.client, ThreadMember, iterable);
      this.thread = thread;
    }
    _add(data, cache = true) {
      const existing = this.cache.get(data.user_id);
      if (cache)
        existing?._patch(data, { cache });
      if (existing)
        return existing;
      const member = new ThreadMember(this.thread, data, { cache });
      if (cache)
        this.cache.set(data.user_id, member);
      return member;
    }
    fetchMe(options) {
      return this.fetch({ ...options, member: this.client.user.id });
    }
    get me() {
      return this.resolve(this.client.user.id);
    }
    resolve(member) {
      const memberResolvable = super.resolve(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveId(member);
      if (userResolvable)
        return super.resolve(userResolvable);
      return null;
    }
    resolveId(member) {
      const memberResolvable = super.resolveId(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveId(member);
      return this.cache.has(userResolvable) ? userResolvable : null;
    }
    async add(member, reason) {
      const id = member === "@me" ? member : this.client.users.resolveId(member);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "member", "UserResolvable");
      await this.client.rest.put(Routes.threadMembers(this.thread.id, id), { reason });
      return id;
    }
    async remove(id, reason) {
      await this.client.rest.delete(Routes.threadMembers(this.thread.id, id), { reason });
      return id;
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { member, withMember, cache, force } = options;
      const resolvedMember = this.resolveId(member ?? options);
      if (resolvedMember)
        return this._fetchSingle({ member: resolvedMember, withMember, cache, force });
      return this._fetchMany(options);
    }
    async _fetchSingle({ member, withMember, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(member);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.threadMembers(this.thread.id, member), {
        query: makeURLSearchParams({ with_member: withMember })
      });
      return this._add(data, cache);
    }
    async _fetchMany({ withMember, after, limit, cache } = {}) {
      const data = await this.client.rest.get(Routes.threadMembers(this.thread.id), {
        query: makeURLSearchParams({ with_member: withMember, after, limit })
      });
      return data.reduce((col, member) => col.set(member.user_id, this._add(member, cache)), new Collection);
    }
  }
  module.exports = ThreadMemberManager;
});

// node_modules/discord.js/src/structures/ThreadChannel.js
var require_ThreadChannel = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var { ChannelType, PermissionFlagsBits, Routes, ChannelFlags } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var getThreadOnlyChannel = lazy(() => require_ThreadOnlyChannel());
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsRangeError, ErrorCodes } = require_errors2();
  var GuildMessageManager = require_GuildMessageManager();
  var ThreadMemberManager = require_ThreadMemberManager();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();

  class ThreadChannel extends BaseChannel {
    constructor(guild, data, client) {
      super(guild?.client ?? client, data, false);
      this.guild = guild;
      this.guildId = guild?.id ?? data.guild_id;
      this.messages = new GuildMessageManager(this);
      this.members = new ThreadMemberManager(this);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("message" in data)
        this.messages._add(data.message);
      if ("name" in data) {
        this.name = data.name;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("parent_id" in data) {
        this.parentId = data.parent_id;
      } else {
        this.parentId ??= null;
      }
      if ("thread_metadata" in data) {
        this.locked = data.thread_metadata.locked ?? false;
        this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;
        this.archived = data.thread_metadata.archived;
        this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;
        this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);
        if ("create_timestamp" in data.thread_metadata) {
          this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);
        }
      } else {
        this.locked ??= null;
        this.archived ??= null;
        this.autoArchiveDuration ??= null;
        this.archiveTimestamp ??= null;
        this.invitable ??= null;
      }
      this._createdTimestamp ??= this.type === ChannelType.PrivateThread ? super.createdTimestamp : null;
      if ("owner_id" in data) {
        this.ownerId = data.owner_id;
      } else {
        this.ownerId ??= null;
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      } else {
        this.lastMessageId ??= null;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      } else {
        this.lastPinTimestamp ??= null;
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user ?? 0;
      } else {
        this.rateLimitPerUser ??= null;
      }
      if ("message_count" in data) {
        this.messageCount = data.message_count;
      } else {
        this.messageCount ??= null;
      }
      if ("member_count" in data) {
        this.memberCount = data.member_count;
      } else {
        this.memberCount ??= null;
      }
      if ("total_message_sent" in data) {
        this.totalMessageSent = data.total_message_sent;
      } else {
        this.totalMessageSent ??= null;
      }
      if (data.member && this.client.user)
        this.members._add({ user_id: this.client.user.id, ...data.member });
      if (data.messages)
        for (const message of data.messages)
          this.messages._add(message);
      if ("applied_tags" in data) {
        this.appliedTags = data.applied_tags;
      } else {
        this.appliedTags ??= [];
      }
    }
    get createdTimestamp() {
      return this._createdTimestamp;
    }
    get guildMembers() {
      return this.members.cache.mapValues((member) => member.guildMember);
    }
    get archivedAt() {
      return this.archiveTimestamp && new Date(this.archiveTimestamp);
    }
    get createdAt() {
      return this.createdTimestamp && new Date(this.createdTimestamp);
    }
    get parent() {
      return this.guild.channels.resolve(this.parentId);
    }
    async join() {
      await this.members.add("@me");
      return this;
    }
    async leave() {
      await this.members.remove("@me");
      return this;
    }
    permissionsFor(memberOrRole, checkAdmin) {
      return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;
    }
    async fetchOwner({ cache = true, force = false } = {}) {
      if (!force) {
        const existing = this.members.cache.get(this.ownerId);
        if (existing)
          return existing;
      }
      const members = await this.members.fetch({ cache });
      return members.get(this.ownerId) ?? null;
    }
    async fetchStarterMessage(options) {
      const channel = this.parent instanceof getThreadOnlyChannel() ? this : this.parent;
      return channel?.messages.fetch({ message: this.id, ...options }) ?? null;
    }
    async edit(options) {
      const newData = await this.client.rest.patch(Routes.channel(this.id), {
        body: {
          name: (options.name ?? this.name).trim(),
          archived: options.archived,
          auto_archive_duration: options.autoArchiveDuration,
          rate_limit_per_user: options.rateLimitPerUser,
          locked: options.locked,
          invitable: this.type === ChannelType.PrivateThread ? options.invitable : undefined,
          applied_tags: options.appliedTags,
          flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : undefined
        },
        reason: options.reason
      });
      return this.client.actions.ChannelUpdate.handle(newData).updated;
    }
    setArchived(archived = true, reason) {
      return this.edit({ archived, reason });
    }
    setAutoArchiveDuration(autoArchiveDuration, reason) {
      return this.edit({ autoArchiveDuration, reason });
    }
    setInvitable(invitable = true, reason) {
      if (this.type !== ChannelType.PrivateThread) {
        return Promise.reject(new DiscordjsRangeError(ErrorCodes.ThreadInvitableType, this.type));
      }
      return this.edit({ invitable, reason });
    }
    setLocked(locked = true, reason) {
      return this.edit({ locked, reason });
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
    setAppliedTags(appliedTags, reason) {
      return this.edit({ appliedTags, reason });
    }
    pin(reason) {
      return this.edit({ flags: this.flags.add(ChannelFlags.Pinned), reason });
    }
    unpin(reason) {
      return this.edit({ flags: this.flags.remove(ChannelFlags.Pinned), reason });
    }
    get joined() {
      return this.members.cache.has(this.client.user?.id);
    }
    get editable() {
      return this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined) || this.manageable;
    }
    get joinable() {
      return !this.archived && !this.joined && this.permissionsFor(this.client.user)?.has(this.type === ChannelType.PrivateThread ? PermissionFlagsBits.ManageThreads : PermissionFlagsBits.ViewChannel, false);
    }
    get manageable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.ManageThreads, false);
    }
    get viewable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has(PermissionFlagsBits.ViewChannel, false);
    }
    get sendable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return !(this.archived && this.locked && !this.manageable) && (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) && permissions.has(PermissionFlagsBits.SendMessagesInThreads, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now();
    }
    get unarchivable() {
      return this.archived && this.sendable && (!this.locked || this.manageable);
    }
    async delete(reason) {
      await this.guild.channels.delete(this.id, reason);
      return this;
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
    bulkDelete() {
    }
  }
  TextBasedChannel.applyToClass(ThreadChannel, true, ["fetchWebhooks", "setRateLimitPerUser", "setNSFW"]);
  module.exports = ThreadChannel;
});

// node_modules/discord.js/src/managers/ThreadManager.js
var require_ThreadManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { makeURLSearchParams } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var ThreadChannel = require_ThreadChannel();
  var { MakeCacheOverrideSymbol } = require_Symbols();

  class ThreadManager extends CachedManager {
    static [MakeCacheOverrideSymbol] = ThreadManager;
    constructor(channel, iterable) {
      super(channel.client, ThreadChannel, iterable);
      this.channel = channel;
    }
    _add(thread) {
      const existing = this.cache.get(thread.id);
      if (existing)
        return existing;
      this.cache.set(thread.id, thread);
      return thread;
    }
    fetch(options, { cache, force } = {}) {
      if (!options)
        return this.fetchActive(cache);
      const channel = this.client.channels.resolveId(options);
      if (channel)
        return this.client.channels.fetch(channel, { cache, force });
      if (options.archived) {
        return this.fetchArchived(options.archived, cache);
      }
      return this.fetchActive(cache);
    }
    async fetchArchived({ type = "public", fetchAll = false, before, limit } = {}, cache = true) {
      let path = Routes.channelThreads(this.channel.id, type);
      if (type === "private" && !fetchAll) {
        path = Routes.channelJoinedArchivedThreads(this.channel.id);
      }
      let timestamp;
      let id;
      const query = makeURLSearchParams({ limit });
      if (before !== undefined) {
        if (before instanceof ThreadChannel || /^\d{17,19}$/.test(String(before))) {
          id = this.resolveId(before);
          timestamp = this.resolve(before)?.archivedAt?.toISOString();
          const toUse = type === "private" && !fetchAll ? id : timestamp;
          if (toUse) {
            query.set("before", toUse);
          }
        } else {
          try {
            timestamp = new Date(before).toISOString();
            if (type === "public" || fetchAll) {
              query.set("before", timestamp);
            }
          } catch {
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, "before", "DateResolvable or ThreadChannelResolvable");
          }
        }
      }
      const raw = await this.client.rest.get(path, { query });
      return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });
    }
    async fetchActive(cache = true) {
      const data = await this.channel.guild.channels.rawFetchGuildActiveThreads();
      return this.constructor._mapThreads(data, this.client, { parent: this.channel, cache });
    }
    static _mapThreads(rawThreads, client, { parent, guild, cache }) {
      const threads = rawThreads.threads.reduce((coll, raw) => {
        const thread = client.channels._add(raw, guild ?? parent?.guild, { cache });
        if (parent && thread.parentId !== parent.id)
          return coll;
        return coll.set(thread.id, thread);
      }, new Collection);
      const threadMembers = rawThreads.members.reduce((coll, raw) => {
        const thread = threads.get(raw.id);
        return thread ? coll.set(raw.user_id, thread.members._add(raw)) : coll;
      }, new Collection);
      const response = { threads, members: threadMembers };
      if ("has_more" in rawThreads)
        response.hasMore = rawThreads.has_more;
      return response;
    }
  }
  module.exports = ThreadManager;
});

// node_modules/discord.js/src/managers/GuildTextThreadManager.js
var require_GuildTextThreadManager = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var ThreadManager = require_ThreadManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class GuildTextThreadManager extends ThreadManager {
    async create({
      name,
      autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
      startMessage,
      type,
      invitable,
      reason,
      rateLimitPerUser
    } = {}) {
      let resolvedType = this.channel.type === ChannelType.GuildAnnouncement ? ChannelType.AnnouncementThread : ChannelType.PublicThread;
      let startMessageId;
      if (startMessage) {
        startMessageId = this.channel.messages.resolveId(startMessage);
        if (!startMessageId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "startMessage", "MessageResolvable");
      } else if (this.channel.type !== ChannelType.GuildAnnouncement) {
        resolvedType = type ?? resolvedType;
      }
      const data = await this.client.rest.post(Routes.threads(this.channel.id, startMessageId), {
        body: {
          name,
          auto_archive_duration: autoArchiveDuration,
          type: resolvedType,
          invitable: resolvedType === ChannelType.PrivateThread ? invitable : undefined,
          rate_limit_per_user: rateLimitPerUser
        },
        reason
      });
      return this.client.actions.ThreadCreate.handle(data).thread;
    }
  }
  module.exports = GuildTextThreadManager;
});

// node_modules/discord.js/src/structures/BaseGuildTextChannel.js
var require_BaseGuildTextChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildMessageManager = require_GuildMessageManager();
  var GuildTextThreadManager = require_GuildTextThreadManager();

  class BaseGuildTextChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.messages = new GuildMessageManager(this);
      this.threads = new GuildTextThreadManager(this);
      this.nsfw = Boolean(data.nsfw);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("nsfw" in data) {
        this.nsfw = Boolean(data.nsfw);
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      }
      if ("default_auto_archive_duration" in data) {
        this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
      }
      if ("default_thread_rate_limit_per_user" in data) {
        this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
      } else {
        this.defaultThreadRateLimitPerUser ??= null;
      }
      if ("messages" in data) {
        for (const message of data.messages)
          this.messages._add(message);
      }
    }
    setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
      return this.edit({ defaultAutoArchiveDuration, reason });
    }
    setType(type, reason) {
      return this.edit({ type, reason });
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache = true) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
    bulkDelete() {
    }
    fetchWebhooks() {
    }
    createWebhook() {
    }
    setRateLimitPerUser() {
    }
    setNSFW() {
    }
  }
  TextBasedChannel.applyToClass(BaseGuildTextChannel, true);
  module.exports = BaseGuildTextChannel;
});

// node_modules/discord.js/src/structures/NewsChannel.js
var require_NewsChannel = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var BaseGuildTextChannel = require_BaseGuildTextChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class NewsChannel extends BaseGuildTextChannel {
    async addFollower(channel, reason) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      await this.client.rest.post(Routes.channelFollowers(this.id), { body: { webhook_channel_id: channelId }, reason });
      return this;
    }
  }
  module.exports = NewsChannel;
});

// node_modules/discord.js/src/structures/BaseGuildVoiceChannel.js
var require_BaseGuildVoiceChannel = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { PermissionFlagsBits } = require_v106();
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildMessageManager = require_GuildMessageManager();

  class BaseGuildVoiceChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.messages = new GuildMessageManager(this);
      this.nsfw = Boolean(data.nsfw);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("rtc_region" in data) {
        this.rtcRegion = data.rtc_region;
      }
      if ("bitrate" in data) {
        this.bitrate = data.bitrate;
      }
      if ("user_limit" in data) {
        this.userLimit = data.user_limit;
      }
      if ("video_quality_mode" in data) {
        this.videoQualityMode = data.video_quality_mode;
      } else {
        this.videoQualityMode ??= null;
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("messages" in data) {
        for (const message of data.messages)
          this.messages._add(message);
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      }
      if ("nsfw" in data) {
        this.nsfw = data.nsfw;
      }
    }
    get members() {
      const coll = new Collection;
      for (const state of this.guild.voiceStates.cache.values()) {
        if (state.channelId === this.id && state.member) {
          coll.set(state.id, state.member);
        }
      }
      return coll;
    }
    get full() {
      return this.userLimit > 0 && this.members.size >= this.userLimit;
    }
    get joinable() {
      if (!this.viewable)
        return false;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Connect, false);
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache = true) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    setBitrate(bitrate, reason) {
      return this.edit({ bitrate, reason });
    }
    setRTCRegion(rtcRegion, reason) {
      return this.edit({ rtcRegion, reason });
    }
    setUserLimit(userLimit, reason) {
      return this.edit({ userLimit, reason });
    }
    setVideoQualityMode(videoQualityMode, reason) {
      return this.edit({ videoQualityMode, reason });
    }
    get lastMessage() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
    bulkDelete() {
    }
    fetchWebhooks() {
    }
    createWebhook() {
    }
    setRateLimitPerUser() {
    }
    setNSFW() {
    }
  }
  TextBasedChannel.applyToClass(BaseGuildVoiceChannel, true, ["lastPinAt"]);
  module.exports = BaseGuildVoiceChannel;
});

// node_modules/discord.js/src/structures/StageChannel.js
var require_StageChannel = __commonJS((exports, module) => {
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();

  class StageChannel extends BaseGuildVoiceChannel {
    _patch(data) {
      super._patch(data);
      if ("topic" in data) {
        this.topic = data.topic;
      }
    }
    get stageInstance() {
      return this.guild.stageInstances.cache.find((stageInstance) => stageInstance.channelId === this.id) ?? null;
    }
    createStageInstance(options) {
      return this.guild.stageInstances.create(this.id, options);
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
  }
  module.exports = StageChannel;
});

// node_modules/discord.js/src/structures/TextChannel.js
var require_TextChannel = __commonJS((exports, module) => {
  var BaseGuildTextChannel = require_BaseGuildTextChannel();

  class TextChannel extends BaseGuildTextChannel {
    _patch(data) {
      super._patch(data);
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      }
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
  }
  module.exports = TextChannel;
});

// node_modules/discord.js/src/structures/VoiceChannel.js
var require_VoiceChannel = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();

  class VoiceChannel extends BaseGuildVoiceChannel {
    get joinable() {
      if (!super.joinable)
        return false;
      if (this.full && !this.permissionsFor(this.client.user).has(PermissionFlagsBits.MoveMembers, false))
        return false;
      return true;
    }
    get speakable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Speak, false);
    }
  }
  module.exports = VoiceChannel;
});

// node_modules/discord.js/src/structures/DirectoryChannel.js
var require_DirectoryChannel = __commonJS((exports, module) => {
  var { BaseChannel } = require_BaseChannel();

  class DirectoryChannel extends BaseChannel {
    constructor(guild, data, client) {
      super(client, data);
      this.guild = guild;
      this.guildId = guild.id;
    }
    _patch(data) {
      super._patch(data);
      this.name = data.name;
    }
  }
  module.exports = DirectoryChannel;
});

// node_modules/discord.js/src/structures/PartialGroupDMChannel.js
var require_PartialGroupDMChannel = __commonJS((exports, module) => {
  var { BaseChannel } = require_BaseChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class PartialGroupDMChannel extends BaseChannel {
    constructor(client, data) {
      super(client, data);
      this.flags = null;
      this.name = data.name;
      this.icon = data.icon;
      this.recipients = data.recipients;
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.channelIcon(this.id, this.icon, options);
    }
    delete() {
      return Promise.reject(new DiscordjsError(ErrorCodes.DeleteGroupDMChannel));
    }
    fetch() {
      return Promise.reject(new DiscordjsError(ErrorCodes.FetchGroupDMChannel));
    }
  }
  module.exports = PartialGroupDMChannel;
});

// node_modules/discord.js/src/structures/ForumChannel.js
var require_ForumChannel = __commonJS((exports, module) => {
  var ThreadOnlyChannel = require_ThreadOnlyChannel();

  class ForumChannel extends ThreadOnlyChannel {
    _patch(data) {
      super._patch(data);
      this.defaultForumLayout = data.default_forum_layout;
    }
    setDefaultForumLayout(defaultForumLayout, reason) {
      return this.edit({ defaultForumLayout, reason });
    }
  }
  module.exports = ForumChannel;
});

// node_modules/discord.js/src/structures/MediaChannel.js
var require_MediaChannel = __commonJS((exports, module) => {
  var ThreadOnlyChannel = require_ThreadOnlyChannel();

  class MediaChannel extends ThreadOnlyChannel {
  }
  module.exports = MediaChannel;
});

// node_modules/discord.js/src/util/Channels.js
var require_Channels = __commonJS((exports, module) => {
  var createChannel = function(client, data, guild, { allowUnknownGuild } = {}) {
    let channel;
    if (!data.guild_id && !guild) {
      if (data.recipients && data.type !== ChannelType.GroupDM || data.type === ChannelType.DM) {
        channel = new (getDMChannel())(client, data);
      } else if (data.type === ChannelType.GroupDM) {
        channel = new (getPartialGroupDMChannel())(client, data);
      }
    } else {
      guild ??= client.guilds.cache.get(data.guild_id);
      if (guild || allowUnknownGuild) {
        switch (data.type) {
          case ChannelType.GuildText: {
            channel = new (getTextChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildVoice: {
            channel = new (getVoiceChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildCategory: {
            channel = new (getCategoryChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildAnnouncement: {
            channel = new (getNewsChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildStageVoice: {
            channel = new (getStageChannel())(guild, data, client);
            break;
          }
          case ChannelType.AnnouncementThread:
          case ChannelType.PublicThread:
          case ChannelType.PrivateThread: {
            channel = new (getThreadChannel())(guild, data, client);
            if (!allowUnknownGuild)
              channel.parent?.threads.cache.set(channel.id, channel);
            break;
          }
          case ChannelType.GuildDirectory:
            channel = new (getDirectoryChannel())(guild, data, client);
            break;
          case ChannelType.GuildForum:
            channel = new (getForumChannel())(guild, data, client);
            break;
          case ChannelType.GuildMedia:
            channel = new (getMediaChannel())(guild, data, client);
            break;
        }
        if (channel && !allowUnknownGuild)
          guild.channels?.cache.set(channel.id, channel);
      }
    }
    return channel;
  };
  var transformAPIGuildForumTag = function(tag) {
    return {
      id: tag.id,
      name: tag.name,
      moderated: tag.moderated,
      emoji: tag.emoji_id ?? tag.emoji_name ? {
        id: tag.emoji_id,
        name: tag.emoji_name
      } : null
    };
  };
  var transformGuildForumTag = function(tag) {
    return {
      id: tag.id,
      name: tag.name,
      moderated: tag.moderated,
      emoji_id: tag.emoji?.id ?? null,
      emoji_name: tag.emoji?.name ?? null
    };
  };
  var transformAPIGuildDefaultReaction = function(defaultReaction) {
    return {
      id: defaultReaction.emoji_id,
      name: defaultReaction.emoji_name
    };
  };
  var transformGuildDefaultReaction = function(defaultReaction) {
    return {
      emoji_id: defaultReaction.id,
      emoji_name: defaultReaction.name
    };
  };
  var { lazy } = require_dist();
  var { ChannelType } = require_v106();
  var getCategoryChannel = lazy(() => require_CategoryChannel());
  var getDMChannel = lazy(() => require_DMChannel());
  var getNewsChannel = lazy(() => require_NewsChannel());
  var getStageChannel = lazy(() => require_StageChannel());
  var getTextChannel = lazy(() => require_TextChannel());
  var getThreadChannel = lazy(() => require_ThreadChannel());
  var getVoiceChannel = lazy(() => require_VoiceChannel());
  var getDirectoryChannel = lazy(() => require_DirectoryChannel());
  var getPartialGroupDMChannel = lazy(() => require_PartialGroupDMChannel());
  var getForumChannel = lazy(() => require_ForumChannel());
  var getMediaChannel = lazy(() => require_MediaChannel());
  module.exports = {
    createChannel,
    transformAPIGuildForumTag,
    transformGuildForumTag,
    transformAPIGuildDefaultReaction,
    transformGuildDefaultReaction
  };
});

// node_modules/discord.js/src/client/actions/ChannelUpdate.js
var require_ChannelUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var { createChannel } = require_Channels();

  class ChannelUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      let channel = client.channels.cache.get(data.id);
      if (channel) {
        const old = channel._update(data);
        if (channel.type !== data.type) {
          const newChannel = createChannel(this.client, data, channel.guild);
          if (!newChannel) {
            this.client.channels.cache.delete(channel.id);
            return {};
          }
          if (channel.isTextBased() && newChannel.isTextBased()) {
            for (const [id, message] of channel.messages.cache)
              newChannel.messages.cache.set(id, message);
          }
          channel = newChannel;
          this.client.channels.cache.set(channel.id, channel);
        }
        return {
          old,
          updated: channel
        };
      } else {
        client.channels._add(data);
      }
      return {};
    }
  }
  module.exports = ChannelUpdateAction;
});

// node_modules/discord.js/src/structures/AutoModerationRule.js
var require_AutoModerationRule = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var Base = require_Base();
  var { _transformAPIAutoModerationAction } = require_Transformers();

  class AutoModerationRule extends Base {
    constructor(client, data, guild) {
      super(client);
      this.id = data.id;
      this.guild = guild;
      this.creatorId = data.creator_id;
      this.triggerType = data.trigger_type;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      if ("event_type" in data) {
        this.eventType = data.event_type;
      }
      if ("trigger_metadata" in data) {
        this.triggerMetadata = {
          keywordFilter: data.trigger_metadata.keyword_filter ?? [],
          regexPatterns: data.trigger_metadata.regex_patterns ?? [],
          presets: data.trigger_metadata.presets ?? [],
          allowList: data.trigger_metadata.allow_list ?? [],
          mentionTotalLimit: data.trigger_metadata.mention_total_limit ?? null,
          mentionRaidProtectionEnabled: data.trigger_metadata.mention_raid_protection_enabled ?? false
        };
      }
      if ("actions" in data) {
        this.actions = data.actions.map((action) => _transformAPIAutoModerationAction(action));
      }
      if ("enabled" in data) {
        this.enabled = data.enabled;
      }
      if ("exempt_roles" in data) {
        this.exemptRoles = new Collection(data.exempt_roles.map((exemptRole) => [exemptRole, this.guild.roles.cache.get(exemptRole)]));
      }
      if ("exempt_channels" in data) {
        this.exemptChannels = new Collection(data.exempt_channels.map((exemptChannel) => [exemptChannel, this.guild.channels.cache.get(exemptChannel)]));
      }
    }
    edit(options) {
      return this.guild.autoModerationRules.edit(this.id, options);
    }
    delete(reason) {
      return this.guild.autoModerationRules.delete(this.id, reason);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setEventType(eventType, reason) {
      return this.edit({ eventType, reason });
    }
    setKeywordFilter(keywordFilter, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, keywordFilter }, reason });
    }
    setRegexPatterns(regexPatterns, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, regexPatterns }, reason });
    }
    setPresets(presets, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, presets }, reason });
    }
    setAllowList(allowList, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, allowList }, reason });
    }
    setMentionTotalLimit(mentionTotalLimit, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionTotalLimit }, reason });
    }
    setMentionRaidProtectionEnabled(mentionRaidProtectionEnabled, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionRaidProtectionEnabled }, reason });
    }
    setActions(actions, reason) {
      return this.edit({ actions, reason });
    }
    setEnabled(enabled = true, reason) {
      return this.edit({ enabled, reason });
    }
    setExemptRoles(exemptRoles, reason) {
      return this.edit({ exemptRoles, reason });
    }
    setExemptChannels(exemptChannels, reason) {
      return this.edit({ exemptChannels, reason });
    }
  }
  module.exports = AutoModerationRule;
});

// node_modules/discord.js/src/structures/Integration.js
var require_Integration = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var Base = require_Base();
  var IntegrationApplication = require_IntegrationApplication();

  class Integration extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.id = data.id;
      this.name = data.name;
      this.type = data.type;
      this.enabled = data.enabled ?? null;
      if ("syncing" in data) {
        this.syncing = data.syncing;
      } else {
        this.syncing ??= null;
      }
      this.role = this.guild.roles.resolve(data.role_id);
      if ("enable_emoticons" in data) {
        this.enableEmoticons = data.enable_emoticons;
      } else {
        this.enableEmoticons ??= null;
      }
      if (data.user) {
        this.user = this.client.users._add(data.user);
      } else {
        this.user ??= null;
      }
      this.account = data.account;
      if ("synced_at" in data) {
        this.syncedTimestamp = Date.parse(data.synced_at);
      } else {
        this.syncedTimestamp ??= null;
      }
      if ("subscriber_count" in data) {
        this.subscriberCount = data.subscriber_count;
      } else {
        this.subscriberCount ??= null;
      }
      if ("revoked" in data) {
        this.revoked = data.revoked;
      } else {
        this.revoked ??= null;
      }
      this._patch(data);
    }
    get syncedAt() {
      return this.syncedTimestamp && new Date(this.syncedTimestamp);
    }
    get roles() {
      const roles = this.guild.roles.cache;
      return roles.filter((role) => role.tags?.integrationId === this.id);
    }
    _patch(data) {
      if ("expire_behavior" in data) {
        this.expireBehavior = data.expire_behavior;
      } else {
        this.expireBehavior ??= null;
      }
      if ("expire_grace_period" in data) {
        this.expireGracePeriod = data.expire_grace_period;
      } else {
        this.expireGracePeriod ??= null;
      }
      if ("application" in data) {
        if (this.application) {
          this.application._patch(data.application);
        } else {
          this.application = new IntegrationApplication(this.client, data.application);
        }
      } else {
        this.application ??= null;
      }
      if ("scopes" in data) {
        this.scopes = data.scopes;
      } else {
        this.scopes ??= [];
      }
    }
    async delete(reason) {
      await this.client.rest.delete(Routes.guildIntegration(this.guild.id, this.id), { reason });
      return this;
    }
    toJSON() {
      return super.toJSON({
        role: "roleId",
        guild: "guildId",
        user: "userId"
      });
    }
  }
  module.exports = Integration;
});

// node_modules/discord.js/src/structures/StageInstance.js
var require_StageInstance = __commonJS((exports) => {
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();

  class StageInstance extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this._patch(data);
    }
    _patch(data) {
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("privacy_level" in data) {
        this.privacyLevel = data.privacy_level;
      }
      if ("discoverable_disabled" in data) {
        this.discoverableDisabled = data.discoverable_disabled;
      } else {
        this.discoverableDisabled ??= null;
      }
      if ("guild_scheduled_event_id" in data) {
        this.guildScheduledEventId = data.guild_scheduled_event_id;
      } else {
        this.guildScheduledEventId ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get guildScheduledEvent() {
      return this.guild?.scheduledEvents.resolve(this.guildScheduledEventId) ?? null;
    }
    edit(options) {
      return this.guild.stageInstances.edit(this.channelId, options);
    }
    async delete() {
      await this.guild.stageInstances.delete(this.channelId);
      const clone = this._clone();
      return clone;
    }
    setTopic(topic) {
      return this.guild.stageInstances.edit(this.channelId, { topic });
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
  }
  exports.StageInstance = StageInstance;
});

// node_modules/discord.js/src/structures/GuildAuditLogsEntry.js
var require_GuildAuditLogsEntry = __commonJS((exports, module) => {
  var changesReduce = function(changes, initialData = {}) {
    return changes.reduce((accumulator, change) => {
      accumulator[change.key] = change.new ?? change.old;
      return accumulator;
    }, initialData);
  };
  var { DiscordSnowflake } = require_dist3();
  var { AuditLogOptionsType, AuditLogEvent } = require_v106();
  var AutoModerationRule = require_AutoModerationRule();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var Integration = require_Integration();
  var Invite = require_Invite();
  var { StageInstance } = require_StageInstance();
  var { Sticker } = require_Sticker();
  var Webhook = require_Webhook();
  var Partials = require_Partials();
  var { flatten } = require_Util();
  var Targets = {
    All: "All",
    Guild: "Guild",
    GuildScheduledEvent: "GuildScheduledEvent",
    Channel: "Channel",
    User: "User",
    Role: "Role",
    Invite: "Invite",
    Webhook: "Webhook",
    Emoji: "Emoji",
    Message: "Message",
    Integration: "Integration",
    StageInstance: "StageInstance",
    Sticker: "Sticker",
    Thread: "Thread",
    ApplicationCommand: "ApplicationCommand",
    AutoModeration: "AutoModeration",
    Unknown: "Unknown"
  };

  class GuildAuditLogsEntry {
    static Targets = Targets;
    constructor(guild, data, logs) {
      this.targetType = GuildAuditLogsEntry.targetType(data.action_type);
      const targetType = this.targetType;
      this.actionType = GuildAuditLogsEntry.actionType(data.action_type);
      this.action = data.action_type;
      this.reason = data.reason ?? null;
      this.executorId = data.user_id;
      this.executor = data.user_id ? guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.user_id }) : guild.client.users.cache.get(data.user_id) ?? null : null;
      this.changes = data.changes?.map((change) => ({ key: change.key, old: change.old_value, new: change.new_value })) ?? [];
      this.id = data.id;
      this.extra = null;
      switch (data.action_type) {
        case AuditLogEvent.MemberPrune:
          this.extra = {
            removed: Number(data.options.members_removed),
            days: Number(data.options.delete_member_days)
          };
          break;
        case AuditLogEvent.MemberMove:
        case AuditLogEvent.MessageDelete:
        case AuditLogEvent.MessageBulkDelete:
          this.extra = {
            channel: guild.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
            count: Number(data.options.count)
          };
          break;
        case AuditLogEvent.MessagePin:
        case AuditLogEvent.MessageUnpin:
          this.extra = {
            channel: guild.client.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
            messageId: data.options.message_id
          };
          break;
        case AuditLogEvent.MemberDisconnect:
          this.extra = {
            count: Number(data.options.count)
          };
          break;
        case AuditLogEvent.ChannelOverwriteCreate:
        case AuditLogEvent.ChannelOverwriteUpdate:
        case AuditLogEvent.ChannelOverwriteDelete:
          switch (data.options.type) {
            case AuditLogOptionsType.Role:
              this.extra = guild.roles.cache.get(data.options.id) ?? {
                id: data.options.id,
                name: data.options.role_name,
                type: AuditLogOptionsType.Role
              };
              break;
            case AuditLogOptionsType.Member:
              this.extra = guild.members.cache.get(data.options.id) ?? {
                id: data.options.id,
                type: AuditLogOptionsType.Member
              };
              break;
            default:
              break;
          }
          break;
        case AuditLogEvent.StageInstanceCreate:
        case AuditLogEvent.StageInstanceDelete:
        case AuditLogEvent.StageInstanceUpdate:
          this.extra = {
            channel: guild.client.channels.cache.get(data.options?.channel_id) ?? { id: data.options?.channel_id }
          };
          break;
        case AuditLogEvent.ApplicationCommandPermissionUpdate:
          this.extra = {
            applicationId: data.options.application_id
          };
          break;
        case AuditLogEvent.AutoModerationBlockMessage:
        case AuditLogEvent.AutoModerationFlagToChannel:
        case AuditLogEvent.AutoModerationUserCommunicationDisabled:
          this.extra = {
            autoModerationRuleName: data.options.auto_moderation_rule_name,
            autoModerationRuleTriggerType: data.options.auto_moderation_rule_trigger_type,
            channel: guild.client.channels.cache.get(data.options?.channel_id) ?? { id: data.options?.channel_id }
          };
          break;
        case AuditLogEvent.MemberKick:
        case AuditLogEvent.MemberRoleUpdate: {
          if (data.integration_type) {
            this.extra = {
              integrationType: data.integration_type
            };
          }
          break;
        }
        default:
          break;
      }
      this.targetId = data.target_id;
      this.target = null;
      if (targetType === Targets.Unknown) {
        this.target = changesReduce(this.changes);
        this.target.id = data.target_id;
      } else if (targetType === Targets.User && data.target_id) {
        this.target = guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.target_id }) : guild.client.users.cache.get(data.target_id) ?? null;
      } else if (targetType === Targets.Guild) {
        this.target = guild.client.guilds.cache.get(data.target_id);
      } else if (targetType === Targets.Webhook) {
        this.target = logs?.webhooks.get(data.target_id) ?? new Webhook(guild.client, changesReduce(this.changes, {
          id: data.target_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.Invite) {
        const inviteChange = this.changes.find(({ key }) => key === "code");
        this.target = guild.invites.cache.get(inviteChange.new ?? inviteChange.old) ?? new Invite(guild.client, changesReduce(this.changes, { guild }));
      } else if (targetType === Targets.Message) {
        this.target = data.action_type === AuditLogEvent.MessageBulkDelete ? guild.channels.cache.get(data.target_id) ?? { id: data.target_id } : guild.client.users.cache.get(data.target_id) ?? null;
      } else if (targetType === Targets.Integration) {
        this.target = logs?.integrations.get(data.target_id) ?? new Integration(guild.client, changesReduce(this.changes, { id: data.target_id }), guild);
      } else if (targetType === Targets.Channel || targetType === Targets.Thread) {
        this.target = guild.channels.cache.get(data.target_id) ?? changesReduce(this.changes, { id: data.target_id });
      } else if (targetType === Targets.StageInstance) {
        this.target = guild.stageInstances.cache.get(data.target_id) ?? new StageInstance(guild.client, changesReduce(this.changes, {
          id: data.target_id,
          channel_id: data.options?.channel_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.Sticker) {
        this.target = guild.stickers.cache.get(data.target_id) ?? new Sticker(guild.client, changesReduce(this.changes, { id: data.target_id }));
      } else if (targetType === Targets.GuildScheduledEvent) {
        this.target = guild.scheduledEvents.cache.get(data.target_id) ?? new GuildScheduledEvent(guild.client, changesReduce(this.changes, { id: data.target_id, guild_id: guild.id }));
      } else if (targetType === Targets.ApplicationCommand) {
        this.target = logs?.applicationCommands.get(data.target_id) ?? { id: data.target_id };
      } else if (targetType === Targets.AutoModeration) {
        this.target = guild.autoModerationRules.cache.get(data.target_id) ?? new AutoModerationRule(guild.client, changesReduce(this.changes, { id: data.target_id, guild_id: guild.id }), guild);
      } else if (data.target_id) {
        this.target = guild[`${targetType.toLowerCase()}s`]?.cache.get(data.target_id) ?? { id: data.target_id };
      }
    }
    static targetType(target) {
      if (target < 10)
        return Targets.Guild;
      if (target < 20)
        return Targets.Channel;
      if (target < 30)
        return Targets.User;
      if (target < 40)
        return Targets.Role;
      if (target < 50)
        return Targets.Invite;
      if (target < 60)
        return Targets.Webhook;
      if (target < 70)
        return Targets.Emoji;
      if (target < 80)
        return Targets.Message;
      if (target < 83)
        return Targets.Integration;
      if (target < 86)
        return Targets.StageInstance;
      if (target < 100)
        return Targets.Sticker;
      if (target < 110)
        return Targets.GuildScheduledEvent;
      if (target < 120)
        return Targets.Thread;
      if (target < 130)
        return Targets.ApplicationCommand;
      if (target >= 140 && target < 150)
        return Targets.AutoModeration;
      return Targets.Unknown;
    }
    static actionType(action) {
      if ([
        AuditLogEvent.ChannelCreate,
        AuditLogEvent.ChannelOverwriteCreate,
        AuditLogEvent.MemberBanRemove,
        AuditLogEvent.BotAdd,
        AuditLogEvent.RoleCreate,
        AuditLogEvent.InviteCreate,
        AuditLogEvent.WebhookCreate,
        AuditLogEvent.EmojiCreate,
        AuditLogEvent.MessagePin,
        AuditLogEvent.IntegrationCreate,
        AuditLogEvent.StageInstanceCreate,
        AuditLogEvent.StickerCreate,
        AuditLogEvent.GuildScheduledEventCreate,
        AuditLogEvent.ThreadCreate,
        AuditLogEvent.AutoModerationRuleCreate,
        AuditLogEvent.AutoModerationBlockMessage
      ].includes(action)) {
        return "Create";
      }
      if ([
        AuditLogEvent.ChannelDelete,
        AuditLogEvent.ChannelOverwriteDelete,
        AuditLogEvent.MemberKick,
        AuditLogEvent.MemberPrune,
        AuditLogEvent.MemberBanAdd,
        AuditLogEvent.MemberDisconnect,
        AuditLogEvent.RoleDelete,
        AuditLogEvent.InviteDelete,
        AuditLogEvent.WebhookDelete,
        AuditLogEvent.EmojiDelete,
        AuditLogEvent.MessageDelete,
        AuditLogEvent.MessageBulkDelete,
        AuditLogEvent.MessageUnpin,
        AuditLogEvent.IntegrationDelete,
        AuditLogEvent.StageInstanceDelete,
        AuditLogEvent.StickerDelete,
        AuditLogEvent.GuildScheduledEventDelete,
        AuditLogEvent.ThreadDelete,
        AuditLogEvent.AutoModerationRuleDelete
      ].includes(action)) {
        return "Delete";
      }
      if ([
        AuditLogEvent.GuildUpdate,
        AuditLogEvent.ChannelUpdate,
        AuditLogEvent.ChannelOverwriteUpdate,
        AuditLogEvent.MemberUpdate,
        AuditLogEvent.MemberRoleUpdate,
        AuditLogEvent.MemberMove,
        AuditLogEvent.RoleUpdate,
        AuditLogEvent.InviteUpdate,
        AuditLogEvent.WebhookUpdate,
        AuditLogEvent.EmojiUpdate,
        AuditLogEvent.IntegrationUpdate,
        AuditLogEvent.StageInstanceUpdate,
        AuditLogEvent.StickerUpdate,
        AuditLogEvent.GuildScheduledEventUpdate,
        AuditLogEvent.ThreadUpdate,
        AuditLogEvent.ApplicationCommandPermissionUpdate,
        AuditLogEvent.AutoModerationRuleUpdate
      ].includes(action)) {
        return "Update";
      }
      return "All";
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toJSON() {
      return flatten(this, { createdTimestamp: true });
    }
  }
  module.exports = GuildAuditLogsEntry;
});

// node_modules/discord.js/src/client/actions/GuildAuditLogEntryCreate.js
var require_GuildAuditLogEntryCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  var Events = require_Events();

  class GuildAuditLogEntryCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let auditLogEntry;
      if (guild) {
        auditLogEntry = new GuildAuditLogsEntry(guild, data);
        client.emit(Events.GuildAuditLogEntryCreate, auditLogEntry, guild);
      }
      return { auditLogEntry };
    }
  }
  module.exports = GuildAuditLogEntryCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildBanAdd.js
var require_GuildBanAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildBanAdd extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild)
        client.emit(Events.GuildBanAdd, guild.bans._add(data));
    }
  }
  module.exports = GuildBanAdd;
});

// node_modules/discord.js/src/structures/GuildBan.js
var require_GuildBan = __commonJS((exports, module) => {
  var Base = require_Base();

  class GuildBan extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this._patch(data);
    }
    _patch(data) {
      if ("user" in data) {
        this.user = this.client.users._add(data.user, true);
      }
      if ("reason" in data) {
        this.reason = data.reason;
      }
    }
    get partial() {
      return !("reason" in this);
    }
    fetch(force = true) {
      return this.guild.bans.fetch({ user: this.user, cache: true, force });
    }
  }
  module.exports = GuildBan;
});

// node_modules/discord.js/src/client/actions/GuildBanRemove.js
var require_GuildBanRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var GuildBan = require_GuildBan();
  var Events = require_Events();

  class GuildBanRemove extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const ban = guild.bans.cache.get(data.user.id) ?? new GuildBan(client, data, guild);
        guild.bans.cache.delete(ban.user.id);
        client.emit(Events.GuildBanRemove, ban);
      }
    }
  }
  module.exports = GuildBanRemove;
});

// node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js
var require_GuildChannelsPositionUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildChannelsPositionUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialChannel of data.channels) {
          const channel = guild.channels.cache.get(partialChannel.id);
          if (channel)
            channel.rawPosition = partialChannel.position;
        }
      }
      return { guild };
    }
  }
  module.exports = GuildChannelsPositionUpdate;
});

// node_modules/discord.js/src/client/actions/GuildDelete.js
var require_GuildDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      let guild = client.guilds.cache.get(data.id);
      if (guild) {
        if (data.unavailable) {
          guild.available = false;
          client.emit(Events.GuildUnavailable, guild);
          return;
        }
        for (const channel of guild.channels.cache.values())
          this.client.channels._remove(channel.id);
        client.voice.adapters.get(data.id)?.destroy();
        client.guilds.cache.delete(guild.id);
        client.emit(Events.GuildDelete, guild);
      }
    }
  }
  module.exports = GuildDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiCreate.js
var require_GuildEmojiCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiCreateAction extends Action {
    handle(guild, createdEmoji) {
      const already = guild.emojis.cache.has(createdEmoji.id);
      const emoji = guild.emojis._add(createdEmoji);
      if (!already)
        this.client.emit(Events.GuildEmojiCreate, emoji);
      return { emoji };
    }
  }
  module.exports = GuildEmojiCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiDelete.js
var require_GuildEmojiDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiDeleteAction extends Action {
    handle(emoji) {
      emoji.guild.emojis.cache.delete(emoji.id);
      this.client.emit(Events.GuildEmojiDelete, emoji);
      return { emoji };
    }
  }
  module.exports = GuildEmojiDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js
var require_GuildEmojiUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiUpdateAction extends Action {
    handle(current, data) {
      const old = current._update(data);
      this.client.emit(Events.GuildEmojiUpdate, old, current);
      return { emoji: current };
    }
  }
  module.exports = GuildEmojiUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js
var require_GuildEmojisUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildEmojisUpdateAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild?.emojis)
        return;
      const deletions = new Map(guild.emojis.cache);
      for (const emoji of data.emojis) {
        const cachedEmoji = guild.emojis.cache.get(emoji.id);
        if (cachedEmoji) {
          deletions.delete(emoji.id);
          if (!cachedEmoji.equals(emoji)) {
            this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
          }
        } else {
          this.client.actions.GuildEmojiCreate.handle(guild, emoji);
        }
      }
      for (const emoji of deletions.values()) {
        this.client.actions.GuildEmojiDelete.handle(emoji);
      }
    }
  }
  module.exports = GuildEmojisUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js
var require_GuildIntegrationsUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildIntegrationsUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild)
        client.emit(Events.GuildIntegrationsUpdate, guild);
    }
  }
  module.exports = GuildIntegrationsUpdate;
});

// node_modules/discord.js/src/util/Status.js
var require_Status = __commonJS((exports, module) => {
  var { createEnum } = require_Enums();
  module.exports = createEnum([
    "Ready",
    "Connecting",
    "Reconnecting",
    "Idle",
    "Nearly",
    "Disconnected",
    "WaitingForGuilds",
    "Identifying",
    "Resuming"
  ]);
});

// node_modules/discord.js/src/client/actions/GuildMemberRemove.js
var require_GuildMemberRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Status = require_Status();

  class GuildMemberRemoveAction extends Action {
    handle(data, shard) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let member = null;
      if (guild) {
        member = this.getMember({ user: data.user }, guild);
        guild.memberCount--;
        if (member) {
          guild.members.cache.delete(member.id);
          if (shard.status === Status.Ready)
            client.emit(Events.GuildMemberRemove, member);
        }
        guild.presences.cache.delete(data.user.id);
        guild.voiceStates.cache.delete(data.user.id);
      }
      return { guild, member };
    }
  }
  module.exports = GuildMemberRemoveAction;
});

// node_modules/discord.js/src/client/actions/GuildMemberUpdate.js
var require_GuildMemberUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Status = require_Status();

  class GuildMemberUpdateAction extends Action {
    handle(data, shard) {
      const { client } = this;
      if (data.user.username) {
        const user = client.users.cache.get(data.user.id);
        if (!user) {
          client.users._add(data.user);
        } else if (!user._equals(data.user)) {
          client.actions.UserUpdate.handle(data.user);
        }
      }
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const member = this.getMember({ user: data.user }, guild);
        if (member) {
          const old = member._update(data);
          if (shard.status === Status.Ready && !member.equals(old))
            client.emit(Events.GuildMemberUpdate, old, member);
        } else {
          const newMember = guild.members._add(data);
          this.client.emit(Events.GuildMemberAvailable, newMember);
        }
      }
    }
  }
  module.exports = GuildMemberUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildRoleCreate.js
var require_GuildRoleCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleCreate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        const already = guild.roles.cache.has(data.role.id);
        role = guild.roles._add(data.role);
        if (!already)
          client.emit(Events.GuildRoleCreate, role);
      }
      return { role };
    }
  }
  module.exports = GuildRoleCreate;
});

// node_modules/discord.js/src/client/actions/GuildRoleDelete.js
var require_GuildRoleDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        role = guild.roles.cache.get(data.role_id);
        if (role) {
          guild.roles.cache.delete(data.role_id);
          client.emit(Events.GuildRoleDelete, role);
        }
      }
      return { role };
    }
  }
  module.exports = GuildRoleDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildRoleUpdate.js
var require_GuildRoleUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        let old = null;
        const role = guild.roles.cache.get(data.role.id);
        if (role) {
          old = role._update(data.role);
          client.emit(Events.GuildRoleUpdate, old, role);
        }
        return {
          old,
          updated: role
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = GuildRoleUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js
var require_GuildRolesPositionUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildRolesPositionUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialRole of data.roles) {
          const role = guild.roles.cache.get(partialRole.id);
          if (role)
            role.rawPosition = partialRole.position;
        }
      }
      return { guild };
    }
  }
  module.exports = GuildRolesPositionUpdate;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventCreate.js
var require_GuildScheduledEventCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = guild.scheduledEvents._add(data);
        client.emit(Events.GuildScheduledEventCreate, guildScheduledEvent);
        return { guildScheduledEvent };
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventDelete.js
var require_GuildScheduledEventDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        if (guildScheduledEvent) {
          guild.scheduledEvents.cache.delete(guildScheduledEvent.id);
          client.emit(Events.GuildScheduledEventDelete, guildScheduledEvent);
          return { guildScheduledEvent };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUpdate.js
var require_GuildScheduledEventUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldGuildScheduledEvent = guild.scheduledEvents.cache.get(data.id)?._clone() ?? null;
        const newGuildScheduledEvent = guild.scheduledEvents._add(data);
        client.emit(Events.GuildScheduledEventUpdate, oldGuildScheduledEvent, newGuildScheduledEvent);
        return { oldGuildScheduledEvent, newGuildScheduledEvent };
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserAdd.js
var require_GuildScheduledEventUserAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUserAddAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        const user = this.getUser(data);
        if (guildScheduledEvent && user) {
          client.emit(Events.GuildScheduledEventUserAdd, guildScheduledEvent, user);
          return { guildScheduledEvent, user };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUserAddAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserRemove.js
var require_GuildScheduledEventUserRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUserRemoveAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        const user = this.getUser(data);
        if (guildScheduledEvent && user) {
          client.emit(Events.GuildScheduledEventUserRemove, guildScheduledEvent, user);
          return { guildScheduledEvent, user };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUserRemoveAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerCreate.js
var require_GuildStickerCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerCreateAction extends Action {
    handle(guild, createdSticker) {
      const already = guild.stickers.cache.has(createdSticker.id);
      const sticker = guild.stickers._add(createdSticker);
      if (!already)
        this.client.emit(Events.GuildStickerCreate, sticker);
      return { sticker };
    }
  }
  module.exports = GuildStickerCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerDelete.js
var require_GuildStickerDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerDeleteAction extends Action {
    handle(sticker) {
      sticker.guild.stickers.cache.delete(sticker.id);
      this.client.emit(Events.GuildStickerDelete, sticker);
      return { sticker };
    }
  }
  module.exports = GuildStickerDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerUpdate.js
var require_GuildStickerUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerUpdateAction extends Action {
    handle(current, data) {
      const old = current._update(data);
      this.client.emit(Events.GuildStickerUpdate, old, current);
      return { sticker: current };
    }
  }
  module.exports = GuildStickerUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildStickersUpdate.js
var require_GuildStickersUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildStickersUpdateAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild?.stickers)
        return;
      const deletions = new Map(guild.stickers.cache);
      for (const sticker of data.stickers) {
        const cachedSticker = guild.stickers.cache.get(sticker.id);
        if (cachedSticker) {
          deletions.delete(sticker.id);
          if (!cachedSticker.equals(sticker)) {
            this.client.actions.GuildStickerUpdate.handle(cachedSticker, sticker);
          }
        } else {
          this.client.actions.GuildStickerCreate.handle(guild, sticker);
        }
      }
      for (const sticker of deletions.values()) {
        this.client.actions.GuildStickerDelete.handle(sticker);
      }
    }
  }
  module.exports = GuildStickersUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildUpdate.js
var require_GuildUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.id);
      if (guild) {
        const old = guild._update(data);
        client.emit(Events.GuildUpdate, old, guild);
        return {
          old,
          updated: guild
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = GuildUpdateAction;
});

// node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js
var require_CommandInteractionOptionResolver = __commonJS((exports, module) => {
  var { ApplicationCommandOptionType } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class CommandInteractionOptionResolver {
    constructor(client, options, resolved) {
      Object.defineProperty(this, "client", { value: client });
      this._group = null;
      this._subcommand = null;
      this._hoistedOptions = options;
      if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.SubcommandGroup) {
        this._group = this._hoistedOptions[0].name;
        this._hoistedOptions = this._hoistedOptions[0].options ?? [];
      }
      if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.Subcommand) {
        this._subcommand = this._hoistedOptions[0].name;
        this._hoistedOptions = this._hoistedOptions[0].options ?? [];
      }
      Object.defineProperty(this, "data", { value: Object.freeze([...options]) });
      Object.defineProperty(this, "resolved", { value: resolved ? Object.freeze(resolved) : null });
    }
    get(name, required = false) {
      const option = this._hoistedOptions.find((opt) => opt.name === name);
      if (!option) {
        if (required) {
          throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNotFound, name);
        }
        return null;
      }
      return option;
    }
    _getTypedOption(name, allowedTypes, properties, required) {
      const option = this.get(name, required);
      if (!option) {
        return null;
      } else if (!allowedTypes.includes(option.type)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionType, name, option.type, allowedTypes.join(", "));
      } else if (required && properties.every((prop) => option[prop] === null || option[prop] === undefined)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionEmpty, name, option.type);
      }
      return option;
    }
    getSubcommand(required = true) {
      if (required && !this._subcommand) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommand);
      }
      return this._subcommand;
    }
    getSubcommandGroup(required = false) {
      if (required && !this._group) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommandGroup);
      }
      return this._group;
    }
    getBoolean(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Boolean], ["value"], required);
      return option?.value ?? null;
    }
    getChannel(name, required = false, channelTypes = []) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Channel], ["channel"], required);
      const channel = option?.channel ?? null;
      if (channel && channelTypes.length > 0 && !channelTypes.includes(channel.type)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionInvalidChannelType, name, channel.type, channelTypes.join(", "));
      }
      return channel;
    }
    getString(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.String], ["value"], required);
      return option?.value ?? null;
    }
    getInteger(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Integer], ["value"], required);
      return option?.value ?? null;
    }
    getNumber(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Number], ["value"], required);
      return option?.value ?? null;
    }
    getUser(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable], ["user"], required);
      return option?.user ?? null;
    }
    getMember(name) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable], ["member"], false);
      return option?.member ?? null;
    }
    getRole(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Role, ApplicationCommandOptionType.Mentionable], ["role"], required);
      return option?.role ?? null;
    }
    getAttachment(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Attachment], ["attachment"], required);
      return option?.attachment ?? null;
    }
    getMentionable(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Mentionable], ["user", "member", "role"], required);
      return option?.member ?? option?.user ?? option?.role ?? null;
    }
    getMessage(name, required = false) {
      const option = this._getTypedOption(name, ["_MESSAGE"], ["message"], required);
      return option?.message ?? null;
    }
    getFocused(getFull = false) {
      const focusedOption = this._hoistedOptions.find((option) => option.focused);
      if (!focusedOption)
        throw new DiscordjsTypeError(ErrorCodes.AutocompleteInteractionOptionNoFocusedOption);
      return getFull ? focusedOption : focusedOption.value;
    }
  }
  module.exports = CommandInteractionOptionResolver;
});

// node_modules/discord.js/src/structures/AutocompleteInteraction.js
var require_AutocompleteInteraction = __commonJS((exports, module) => {
  var { InteractionResponseType, Routes } = require_v106();
  var BaseInteraction = require_BaseInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class AutocompleteInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.commandId = data.data.id;
      this.commandName = data.data.name;
      this.commandType = data.data.type;
      this.commandGuildId = data.data.guild_id ?? null;
      this.responded = false;
      this.options = new CommandInteractionOptionResolver(this.client, data.data.options ?? []);
    }
    get command() {
      const id = this.commandId;
      return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
    }
    async respond(options) {
      if (this.responded)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.ApplicationCommandAutocompleteResult,
          data: {
            choices: options.map(({ nameLocalizations, ...option }) => ({
              ...this.client.options.jsonTransformer(option),
              name_localizations: nameLocalizations
            }))
          }
        },
        auth: false
      });
      this.responded = true;
    }
  }
  module.exports = AutocompleteInteraction;
});

// node_modules/discord.js/src/structures/InteractionResponse.js
var require_InteractionResponse = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_dist3();
  var { InteractionType } = require_v106();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class InteractionResponse {
    constructor(interaction, id) {
      this.interaction = interaction;
      this.id = id ?? interaction.id;
      this.client = interaction.client;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionResponse: this,
        interactionType: InteractionType.MessageComponent
      });
    }
    fetch() {
      return this.interaction.fetchReply();
    }
    delete() {
      return this.interaction.deleteReply();
    }
    edit(options) {
      return this.interaction.editReply(options);
    }
  }
  var InteractionCollector = require_InteractionCollector();
  module.exports = InteractionResponse;
});

// node_modules/discord.js/src/structures/interfaces/InteractionResponses.js
var require_InteractionResponses = __commonJS((exports, module) => {
  var { isJSONEncodable } = require_dist();
  var { InteractionResponseType, MessageFlags, Routes, InteractionType } = require_v106();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var InteractionCollector = require_InteractionCollector();
  var InteractionResponse = require_InteractionResponse();
  var MessagePayload = require_MessagePayload();

  class InteractionResponses {
    async deferReply(options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      this.ephemeral = options.ephemeral ?? false;
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.DeferredChannelMessageWithSource,
          data: {
            flags: options.ephemeral ? MessageFlags.Ephemeral : undefined
          }
        },
        auth: false
      });
      this.deferred = true;
      return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
    }
    async reply(options) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      this.ephemeral = options.ephemeral ?? false;
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.ChannelMessageWithSource,
          data
        },
        files,
        auth: false
      });
      this.replied = true;
      return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
    }
    fetchReply(message = "@original") {
      return this.webhook.fetchMessage(message);
    }
    async editReply(options) {
      if (!this.deferred && !this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
      const msg = await this.webhook.editMessage(options.message ?? "@original", options);
      this.replied = true;
      return msg;
    }
    async deleteReply(message = "@original") {
      await this.webhook.deleteMessage(message);
    }
    followUp(options) {
      if (!this.deferred && !this.replied)
        return Promise.reject(new DiscordjsError(ErrorCodes.InteractionNotReplied));
      return this.webhook.send(options);
    }
    async deferUpdate(options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.DeferredMessageUpdate
        },
        auth: false
      });
      this.deferred = true;
      return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message?.interaction?.id);
    }
    async update(options) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.UpdateMessage,
          data
        },
        files,
        auth: false
      });
      this.replied = true;
      return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message.interaction?.id);
    }
    async showModal(modal) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.Modal,
          data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal)
        },
        auth: false
      });
      this.replied = true;
    }
    awaitModalSubmit(options) {
      if (typeof options.time !== "number")
        throw new DiscordjsError(ErrorCodes.InvalidType, "time", "number");
      const _options = { ...options, max: 1, interactionType: InteractionType.ModalSubmit };
      return new Promise((resolve, reject) => {
        const collector = new InteractionCollector(this.client, _options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    static applyToClass(structure, ignore = []) {
      const props = [
        "deferReply",
        "reply",
        "fetchReply",
        "editReply",
        "deleteReply",
        "followUp",
        "deferUpdate",
        "update",
        "showModal",
        "awaitModalSubmit"
      ];
      for (const prop of props) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop));
      }
    }
  }
  module.exports = InteractionResponses;
});

// node_modules/discord.js/src/structures/MessageComponentInteraction.js
var require_MessageComponentInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var InteractionResponses = require_InteractionResponses();
  var getMessage = lazy(() => require_Message().Message);

  class MessageComponentInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(client, data.message);
      this.customId = data.data.custom_id;
      this.componentType = data.data.component_type;
      this.deferred = false;
      this.ephemeral = null;
      this.replied = false;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    get component() {
      return this.message.components.flatMap((row) => row.components).find((component) => (component.customId ?? component.custom_id) === this.customId);
    }
    deferReply() {
    }
    reply() {
    }
    fetchReply() {
    }
    editReply() {
    }
    deleteReply() {
    }
    followUp() {
    }
    deferUpdate() {
    }
    update() {
    }
    showModal() {
    }
    awaitModalSubmit() {
    }
  }
  InteractionResponses.applyToClass(MessageComponentInteraction);
  module.exports = MessageComponentInteraction;
});

// node_modules/discord.js/src/structures/ButtonInteraction.js
var require_ButtonInteraction = __commonJS((exports, module) => {
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class ButtonInteraction extends MessageComponentInteraction {
  }
  module.exports = ButtonInteraction;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuInteraction.js
var require_ChannelSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class ChannelSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.channels = new Collection;
      for (const channel of Object.values(resolved?.channels ?? {})) {
        this.channels.set(channel.id, this.client.channels._add(channel, this.guild) ?? channel);
      }
    }
  }
  module.exports = ChannelSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/CommandInteraction.js
var require_CommandInteraction = __commonJS((exports, module) => {
  var Attachment = require_Attachment();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var InteractionResponses = require_InteractionResponses();

  class CommandInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.commandId = data.data.id;
      this.commandName = data.data.name;
      this.commandType = data.data.type;
      this.commandGuildId = data.data.guild_id ?? null;
      this.deferred = false;
      this.replied = false;
      this.ephemeral = null;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    get command() {
      const id = this.commandId;
      return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
    }
    transformOption(option, resolved) {
      const result = {
        name: option.name,
        type: option.type
      };
      if ("value" in option)
        result.value = option.value;
      if ("options" in option)
        result.options = option.options.map((opt) => this.transformOption(opt, resolved));
      if (resolved) {
        const user = resolved.users?.[option.value];
        if (user)
          result.user = this.client.users._add(user);
        const member = resolved.members?.[option.value];
        if (member)
          result.member = this.guild?.members._add({ user, ...member }) ?? member;
        const channel = resolved.channels?.[option.value];
        if (channel)
          result.channel = this.client.channels._add(channel, this.guild) ?? channel;
        const role = resolved.roles?.[option.value];
        if (role)
          result.role = this.guild?.roles._add(role) ?? role;
        const attachment = resolved.attachments?.[option.value];
        if (attachment)
          result.attachment = new Attachment(attachment);
      }
      return result;
    }
    deferReply() {
    }
    reply() {
    }
    fetchReply() {
    }
    editReply() {
    }
    deleteReply() {
    }
    followUp() {
    }
    showModal() {
    }
    awaitModalSubmit() {
    }
  }
  InteractionResponses.applyToClass(CommandInteraction, ["deferUpdate", "update"]);
  module.exports = CommandInteraction;
});

// node_modules/discord.js/src/structures/ChatInputCommandInteraction.js
var require_ChatInputCommandInteraction = __commonJS((exports, module) => {
  var CommandInteraction = require_CommandInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { transformResolved } = require_Util();

  class ChatInputCommandInteraction extends CommandInteraction {
    constructor(client, data) {
      super(client, data);
      this.options = new CommandInteractionOptionResolver(this.client, data.data.options?.map((option) => this.transformOption(option, data.data.resolved)) ?? [], transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.data.resolved));
    }
    toString() {
      const properties = [
        this.commandName,
        this.options._group,
        this.options._subcommand,
        ...this.options._hoistedOptions.map((option) => `${option.name}:${option.value}`)
      ];
      return `/${properties.filter(Boolean).join(" ")}`;
    }
  }
  module.exports = ChatInputCommandInteraction;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuInteraction.js
var require_MentionableSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var MessageComponentInteraction = require_MessageComponentInteraction();
  var Events = require_Events();

  class MentionableSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      const { members, users, roles } = resolved ?? {};
      this.values = values ?? [];
      this.users = new Collection;
      this.members = new Collection;
      this.roles = new Collection;
      if (members) {
        for (const [id, member] of Object.entries(members)) {
          const user = users[id];
          if (!user) {
            this.client.emit(Events.Debug, `[MentionableSelectMenuInteraction] Received a member without a user, skipping ${id}`);
            continue;
          }
          this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
        }
      }
      if (users) {
        for (const user of Object.values(users)) {
          this.users.set(user.id, this.client.users._add(user));
        }
      }
      if (roles) {
        for (const role of Object.values(roles)) {
          this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
        }
      }
    }
  }
  module.exports = MentionableSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/ContextMenuCommandInteraction.js
var require_ContextMenuCommandInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var { ApplicationCommandOptionType } = require_v106();
  var CommandInteraction = require_CommandInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { transformResolved } = require_Util();
  var getMessage = lazy(() => require_Message().Message);

  class ContextMenuCommandInteraction extends CommandInteraction {
    constructor(client, data) {
      super(client, data);
      this.options = new CommandInteractionOptionResolver(this.client, this.resolveContextMenuOptions(data.data), transformResolved({ client: this.client, guild: this.guild, channel: this.channel }, data.data.resolved));
      this.targetId = data.data.target_id;
    }
    resolveContextMenuOptions({ target_id, resolved }) {
      const result = [];
      if (resolved.users?.[target_id]) {
        result.push(this.transformOption({ name: "user", type: ApplicationCommandOptionType.User, value: target_id }, resolved));
      }
      if (resolved.messages?.[target_id]) {
        result.push({
          name: "message",
          type: "_MESSAGE",
          value: target_id,
          message: this.channel?.messages._add(resolved.messages[target_id]) ?? new (getMessage())(this.client, resolved.messages[target_id])
        });
      }
      return result;
    }
  }
  module.exports = ContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/MessageContextMenuCommandInteraction.js
var require_MessageContextMenuCommandInteraction = __commonJS((exports, module) => {
  var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();

  class MessageContextMenuCommandInteraction extends ContextMenuCommandInteraction {
    get targetMessage() {
      return this.options.getMessage("message");
    }
  }
  module.exports = MessageContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/ModalSubmitFields.js
var require_ModalSubmitFields = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { ComponentType } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class ModalSubmitFields {
    constructor(components) {
      this.components = components;
      this.fields = components.reduce((accumulator, next) => {
        next.components.forEach((component) => accumulator.set(component.customId, component));
        return accumulator;
      }, new Collection);
    }
    getField(customId, type) {
      const field = this.fields.get(customId);
      if (!field)
        throw new DiscordjsTypeError(ErrorCodes.ModalSubmitInteractionFieldNotFound, customId);
      if (type !== undefined && type !== field.type) {
        throw new DiscordjsTypeError(ErrorCodes.ModalSubmitInteractionFieldType, customId, field.type, type);
      }
      return field;
    }
    getTextInputValue(customId) {
      return this.getField(customId, ComponentType.TextInput).value;
    }
  }
  module.exports = ModalSubmitFields;
});

// node_modules/discord.js/src/structures/ModalSubmitInteraction.js
var require_ModalSubmitInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var ModalSubmitFields = require_ModalSubmitFields();
  var InteractionResponses = require_InteractionResponses();
  var getMessage = lazy(() => require_Message().Message);

  class ModalSubmitInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.customId = data.data.custom_id;
      if ("message" in data) {
        this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(this.client, data.message);
      } else {
        this.message = null;
      }
      this.components = data.data.components?.map((component) => ModalSubmitInteraction.transformComponent(component));
      this.fields = new ModalSubmitFields(this.components);
      this.deferred = false;
      this.replied = false;
      this.ephemeral = null;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    static transformComponent(rawComponent) {
      return rawComponent.components ? {
        type: rawComponent.type,
        components: rawComponent.components.map((component) => this.transformComponent(component))
      } : {
        value: rawComponent.value,
        type: rawComponent.type,
        customId: rawComponent.custom_id
      };
    }
    isFromMessage() {
      return Boolean(this.message);
    }
    deferReply() {
    }
    reply() {
    }
    fetchReply() {
    }
    editReply() {
    }
    deleteReply() {
    }
    followUp() {
    }
    deferUpdate() {
    }
    update() {
    }
  }
  InteractionResponses.applyToClass(ModalSubmitInteraction, "showModal");
  module.exports = ModalSubmitInteraction;
});

// node_modules/discord.js/src/structures/RoleSelectMenuInteraction.js
var require_RoleSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class RoleSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.roles = new Collection;
      for (const role of Object.values(resolved?.roles ?? {})) {
        this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
      }
    }
  }
  module.exports = RoleSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/StringSelectMenuInteraction.js
var require_StringSelectMenuInteraction = __commonJS((exports, module) => {
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class StringSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      this.values = data.data.values ?? [];
    }
  }
  module.exports = StringSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/UserContextMenuCommandInteraction.js
var require_UserContextMenuCommandInteraction = __commonJS((exports, module) => {
  var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();

  class UserContextMenuCommandInteraction extends ContextMenuCommandInteraction {
    get targetUser() {
      return this.options.getUser("user");
    }
    get targetMember() {
      return this.options.getMember("user");
    }
  }
  module.exports = UserContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/UserSelectMenuInteraction.js
var require_UserSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var MessageComponentInteraction = require_MessageComponentInteraction();
  var Events = require_Events();

  class UserSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.users = new Collection;
      this.members = new Collection;
      for (const user of Object.values(resolved?.users ?? {})) {
        this.users.set(user.id, this.client.users._add(user));
      }
      for (const [id, member] of Object.entries(resolved?.members ?? {})) {
        const user = resolved.users[id];
        if (!user) {
          this.client.emit(Events.Debug, `[UserSelectMenuInteraction] Received a member without a user, skipping ${id}`);
          continue;
        }
        this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
      }
    }
  }
  module.exports = UserSelectMenuInteraction;
});

// node_modules/discord.js/src/client/actions/InteractionCreate.js
var require_InteractionCreate = __commonJS((exports, module) => {
  var { InteractionType, ComponentType, ApplicationCommandType } = require_v106();
  var Action = require_Action();
  var AutocompleteInteraction = require_AutocompleteInteraction();
  var ButtonInteraction = require_ButtonInteraction();
  var ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
  var ChatInputCommandInteraction = require_ChatInputCommandInteraction();
  var MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  var MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
  var ModalSubmitInteraction = require_ModalSubmitInteraction();
  var RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
  var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  var UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
  var UserSelectMenuInteraction = require_UserSelectMenuInteraction();
  var Events = require_Events();

  class InteractionCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = data.channel && this.getChannel(data.channel);
      let InteractionClass;
      switch (data.type) {
        case InteractionType.ApplicationCommand:
          switch (data.data.type) {
            case ApplicationCommandType.ChatInput:
              InteractionClass = ChatInputCommandInteraction;
              break;
            case ApplicationCommandType.User:
              InteractionClass = UserContextMenuCommandInteraction;
              break;
            case ApplicationCommandType.Message:
              if (channel && !channel.isTextBased())
                return;
              InteractionClass = MessageContextMenuCommandInteraction;
              break;
            default:
              client.emit(Events.Debug, `[INTERACTION] Received application command interaction with unknown type: ${data.data.type}`);
              return;
          }
          break;
        case InteractionType.MessageComponent:
          if (channel && !channel.isTextBased())
            return;
          switch (data.data.component_type) {
            case ComponentType.Button:
              InteractionClass = ButtonInteraction;
              break;
            case ComponentType.StringSelect:
              InteractionClass = StringSelectMenuInteraction;
              break;
            case ComponentType.UserSelect:
              InteractionClass = UserSelectMenuInteraction;
              break;
            case ComponentType.RoleSelect:
              InteractionClass = RoleSelectMenuInteraction;
              break;
            case ComponentType.MentionableSelect:
              InteractionClass = MentionableSelectMenuInteraction;
              break;
            case ComponentType.ChannelSelect:
              InteractionClass = ChannelSelectMenuInteraction;
              break;
            default:
              client.emit(Events.Debug, `[INTERACTION] Received component interaction with unknown type: ${data.data.component_type}`);
              return;
          }
          break;
        case InteractionType.ApplicationCommandAutocomplete:
          InteractionClass = AutocompleteInteraction;
          break;
        case InteractionType.ModalSubmit:
          InteractionClass = ModalSubmitInteraction;
          break;
        default:
          client.emit(Events.Debug, `[INTERACTION] Received interaction with unknown type: ${data.type}`);
          return;
      }
      const interaction = new InteractionClass(client, data);
      client.emit(Events.InteractionCreate, interaction);
    }
  }
  module.exports = InteractionCreateAction;
});

// node_modules/discord.js/src/client/actions/InviteCreate.js
var require_InviteCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class InviteCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel)
        return false;
      const inviteData = Object.assign(data, { channel, guild });
      const invite = guild.invites._add(inviteData);
      client.emit(Events.InviteCreate, invite);
      return { invite };
    }
  }
  module.exports = InviteCreateAction;
});

// node_modules/discord.js/src/client/actions/InviteDelete.js
var require_InviteDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Invite = require_Invite();
  var Events = require_Events();

  class InviteDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel)
        return false;
      const inviteData = Object.assign(data, { channel, guild });
      const invite = new Invite(client, inviteData);
      guild.invites.cache.delete(invite.code);
      client.emit(Events.InviteDelete, invite);
      return { invite };
    }
  }
  module.exports = InviteDeleteAction;
});

// node_modules/discord.js/src/client/actions/MessageCreate.js
var require_MessageCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel(data);
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread()) {
          channel.messageCount++;
          channel.totalMessageSent++;
        }
        const existing = channel.messages.cache.get(data.id);
        if (existing)
          return { message: existing };
        const message = channel.messages._add(data);
        channel.lastMessageId = data.id;
        client.emit(Events.MessageCreate, message);
        return { message };
      }
      return {};
    }
  }
  module.exports = MessageCreateAction;
});

// node_modules/discord.js/src/client/actions/MessageDelete.js
var require_MessageDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel(data);
      let message;
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread())
          channel.messageCount--;
        message = this.getMessage(data, channel);
        if (message) {
          channel.messages.cache.delete(message.id);
          client.emit(Events.MessageDelete, message);
        }
      }
      return { message };
    }
  }
  module.exports = MessageDeleteAction;
});

// node_modules/discord.js/src/client/actions/MessageDeleteBulk.js
var require_MessageDeleteBulk = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var Action = require_Action();
  var Events = require_Events();

  class MessageDeleteBulkAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread())
          channel.messageCount -= data.ids.length;
        const ids = data.ids;
        const messages = new Collection;
        for (const id of ids) {
          const message = this.getMessage({
            id,
            guild_id: data.guild_id
          }, channel, false);
          if (message) {
            messages.set(message.id, message);
            channel.messages.cache.delete(id);
          }
        }
        if (messages.size > 0)
          client.emit(Events.MessageBulkDelete, messages, channel);
        return { messages };
      }
      return {};
    }
  }
  module.exports = MessageDeleteBulkAction;
});

// node_modules/discord.js/src/client/actions/MessageReactionAdd.js
var require_MessageReactionAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Partials = require_Partials();

  class MessageReactionAdd extends Action {
    handle(data, fromStructure = false) {
      if (!data.emoji)
        return false;
      const user = this.getUserFromMember(data);
      if (!user)
        return false;
      const channel = this.getChannel(data);
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const includePartial = this.client.options.partials.includes(Partials.Reaction);
      if (message.partial && !includePartial)
        return false;
      const reaction = message.reactions._add({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user.id === this.client.user.id
      });
      if (!reaction)
        return false;
      reaction._add(user);
      if (fromStructure)
        return { message, reaction, user };
      this.client.emit(Events.MessageReactionAdd, reaction, user);
      return { message, reaction, user };
    }
  }
  module.exports = MessageReactionAdd;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemove.js
var require_MessageReactionRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemove extends Action {
    handle(data) {
      if (!data.emoji)
        return false;
      const user = this.getUser(data);
      if (!user)
        return false;
      const channel = this.getChannel(data);
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message, user);
      if (!reaction)
        return false;
      reaction._remove(user);
      this.client.emit(Events.MessageReactionRemove, reaction, user);
      return { message, reaction, user };
    }
  }
  module.exports = MessageReactionRemove;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemoveAll extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const removed = message.reactions.cache.clone();
      message.reactions.cache.clear();
      this.client.emit(Events.MessageReactionRemoveAll, message, removed);
      return { message };
    }
  }
  module.exports = MessageReactionRemoveAll;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js
var require_MessageReactionRemoveEmoji = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemoveEmoji extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message);
      if (!reaction)
        return false;
      if (!message.partial)
        message.reactions.cache.delete(reaction.emoji.id ?? reaction.emoji.name);
      this.client.emit(Events.MessageReactionRemoveEmoji, reaction);
      return { reaction };
    }
  }
  module.exports = MessageReactionRemoveEmoji;
});

// node_modules/discord.js/src/client/actions/MessageUpdate.js
var require_MessageUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class MessageUpdateAction extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (channel) {
        if (!channel.isTextBased())
          return {};
        const { id, channel_id, guild_id, author, timestamp, type } = data;
        const message = this.getMessage({ id, channel_id, guild_id, author, timestamp, type }, channel);
        if (message) {
          const old = message._update(data);
          return {
            old,
            updated: message
          };
        }
      }
      return {};
    }
  }
  module.exports = MessageUpdateAction;
});

// node_modules/discord.js/src/client/actions/PresenceUpdate.js
var require_PresenceUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class PresenceUpdateAction extends Action {
    handle(data) {
      let user = this.client.users.cache.get(data.user.id);
      if (!user && data.user.username)
        user = this.client.users._add(data.user);
      if (!user)
        return;
      if (data.user.username) {
        if (!user._equals(data.user))
          this.client.actions.UserUpdate.handle(data.user);
      }
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild)
        return;
      const oldPresence = guild.presences.cache.get(user.id)?._clone() ?? null;
      let member = guild.members.cache.get(user.id);
      if (!member && data.status !== "offline") {
        member = guild.members._add({
          user,
          deaf: false,
          mute: false
        });
        this.client.emit(Events.GuildMemberAvailable, member);
      }
      const newPresence = guild.presences._add(Object.assign(data, { guild }));
      if (this.client.listenerCount(Events.PresenceUpdate) && !newPresence.equals(oldPresence)) {
        this.client.emit(Events.PresenceUpdate, oldPresence, newPresence);
      }
    }
  }
  module.exports = PresenceUpdateAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceCreate.js
var require_StageInstanceCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel(data);
      if (channel) {
        const stageInstance = channel.guild.stageInstances._add(data);
        client.emit(Events.StageInstanceCreate, stageInstance);
        return { stageInstance };
      }
      return {};
    }
  }
  module.exports = StageInstanceCreateAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceDelete.js
var require_StageInstanceDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel(data);
      if (channel) {
        const stageInstance = channel.guild.stageInstances._add(data);
        if (stageInstance) {
          channel.guild.stageInstances.cache.delete(stageInstance.id);
          client.emit(Events.StageInstanceDelete, stageInstance);
          return { stageInstance };
        }
      }
      return {};
    }
  }
  module.exports = StageInstanceDeleteAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceUpdate.js
var require_StageInstanceUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel(data);
      if (channel) {
        const oldStageInstance = channel.guild.stageInstances.cache.get(data.id)?._clone() ?? null;
        const newStageInstance = channel.guild.stageInstances._add(data);
        client.emit(Events.StageInstanceUpdate, oldStageInstance, newStageInstance);
        return { oldStageInstance, newStageInstance };
      }
      return {};
    }
  }
  module.exports = StageInstanceUpdateAction;
});

// node_modules/discord.js/src/client/actions/ThreadCreate.js
var require_ThreadCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const existing = client.channels.cache.has(data.id);
      const thread = client.channels._add(data);
      if (!existing && thread) {
        client.emit(Events.ThreadCreate, thread, data.newly_created ?? false);
      }
      return { thread };
    }
  }
  module.exports = ThreadCreateAction;
});

// node_modules/discord.js/src/client/actions/ThreadDelete.js
var require_ThreadDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        client.channels._remove(thread.id);
        client.emit(Events.ThreadDelete, thread);
      }
      return { thread };
    }
  }
  module.exports = ThreadDeleteAction;
});

// node_modules/discord.js/src/client/actions/ThreadListSync.js
var require_ThreadListSync = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var Action = require_Action();
  var Events = require_Events();

  class ThreadListSyncAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (!guild)
        return {};
      if (data.channel_ids) {
        for (const id of data.channel_ids) {
          const channel = client.channels.resolve(id);
          if (channel)
            this.removeStale(channel);
        }
      } else {
        for (const channel of guild.channels.cache.values()) {
          this.removeStale(channel);
        }
      }
      const syncedThreads = data.threads.reduce((coll, rawThread) => {
        const thread = client.channels._add(rawThread);
        return coll.set(thread.id, thread);
      }, new Collection);
      for (const rawMember of Object.values(data.members)) {
        const thread = client.channels.cache.get(rawMember.id);
        if (thread) {
          thread.members._add(rawMember);
        }
      }
      client.emit(Events.ThreadListSync, syncedThreads, guild);
      return {
        syncedThreads
      };
    }
    removeStale(channel) {
      channel.threads?.cache.forEach((thread) => {
        if (!thread.archived) {
          this.client.channels._remove(thread.id);
        }
      });
    }
  }
  module.exports = ThreadListSyncAction;
});

// node_modules/discord.js/src/client/actions/ThreadMemberUpdate.js
var require_ThreadMemberUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadMemberUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        const member = thread.members.cache.get(data.user_id);
        if (!member) {
          const newMember = thread.members._add(data);
          return { newMember };
        }
        const old = member._update(data);
        client.emit(Events.ThreadMemberUpdate, old, member);
      }
      return {};
    }
  }
  module.exports = ThreadMemberUpdateAction;
});

// node_modules/discord.js/src/client/actions/ThreadMembersUpdate.js
var require_ThreadMembersUpdate = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var Action = require_Action();
  var Events = require_Events();

  class ThreadMembersUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        thread.memberCount = data.member_count;
        const addedMembers = new Collection;
        const removedMembers = new Collection;
        data.added_members?.reduce((_addedMembers, addedMember) => _addedMembers.set(addedMember.user_id, thread.members._add(addedMember)), addedMembers);
        data.removed_member_ids?.reduce((removedMembersIds, removedMembersId) => {
          const threadMember = this.getThreadMember(removedMembersId, thread.members);
          if (threadMember)
            removedMembersIds.set(threadMember.id, threadMember);
          thread.members.cache.delete(removedMembersId);
          return removedMembersIds;
        }, removedMembers);
        if (addedMembers.size === 0 && removedMembers.size === 0) {
          return {};
        }
        client.emit(Events.ThreadMembersUpdate, addedMembers, removedMembers, thread);
      }
      return {};
    }
  }
  module.exports = ThreadMembersUpdateAction;
});

// node_modules/discord.js/src/structures/Typing.js
var require_Typing = __commonJS((exports, module) => {
  var Base = require_Base();

  class Typing extends Base {
    constructor(channel, user, data) {
      super(channel.client);
      this.channel = channel;
      this.user = user;
      this._patch(data);
    }
    _patch(data) {
      if ("timestamp" in data) {
        this.startedTimestamp = data.timestamp * 1000;
      }
    }
    inGuild() {
      return this.guild !== null;
    }
    get startedAt() {
      return new Date(this.startedTimestamp);
    }
    get guild() {
      return this.channel.guild ?? null;
    }
    get member() {
      return this.guild?.members.resolve(this.user) ?? null;
    }
  }
  module.exports = Typing;
});

// node_modules/discord.js/src/client/actions/TypingStart.js
var require_TypingStart = __commonJS((exports, module) => {
  var Action = require_Action();
  var Typing = require_Typing();
  var Events = require_Events();

  class TypingStart extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (!channel)
        return;
      if (!channel.isTextBased()) {
        this.client.emit(Events.Warn, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);
        return;
      }
      const user = this.getUserFromMember(data);
      if (user) {
        this.client.emit(Events.TypingStart, new Typing(channel, user, data));
      }
    }
  }
  module.exports = TypingStart;
});

// node_modules/discord.js/src/client/actions/UserUpdate.js
var require_UserUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class UserUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const newUser = data.id === client.user.id ? client.user : client.users.cache.get(data.id);
      const oldUser = newUser._update(data);
      if (!oldUser.equals(newUser)) {
        client.emit(Events.UserUpdate, oldUser, newUser);
        return {
          old: oldUser,
          updated: newUser
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = UserUpdateAction;
});

// node_modules/discord.js/src/client/actions/VoiceStateUpdate.js
var require_VoiceStateUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var VoiceState = require_VoiceState();
  var Events = require_Events();

  class VoiceStateUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldState = guild.voiceStates.cache.get(data.user_id)?._clone() ?? new VoiceState(guild, { user_id: data.user_id });
        const newState = guild.voiceStates._add(data);
        let member = guild.members.cache.get(data.user_id);
        if (member && data.member) {
          member._patch(data.member);
        } else if (data.member?.user && data.member.joined_at) {
          member = guild.members._add(data.member);
        }
        if (member?.user.id === client.user.id) {
          client.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(data)}`);
          client.voice.onVoiceStateUpdate(data);
        }
        client.emit(Events.VoiceStateUpdate, oldState, newState);
      }
    }
  }
  module.exports = VoiceStateUpdate;
});

// node_modules/discord.js/src/client/actions/WebhooksUpdate.js
var require_WebhooksUpdate = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var Action = require_Action();
  var deprecationEmitted = false;

  class WebhooksUpdate extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (!channel)
        return;
      client.emit("webhooksUpdate", channel);
      if (client.emit("webhookUpdate", channel) && !deprecationEmitted) {
        deprecationEmitted = true;
        process2.emitWarning("The webhookUpdate event is deprecated. Use webhooksUpdate instead.", "DeprecationWarning");
      }
    }
  }
  module.exports = WebhooksUpdate;
});

// node_modules/discord.js/src/client/actions/ActionsManager.js
var require_ActionsManager = __commonJS((exports, module) => {
  class ActionsManager {
    injectedUser = Symbol("djs.actions.injectedUser");
    injectedChannel = Symbol("djs.actions.injectedChannel");
    injectedMessage = Symbol("djs.actions.injectedMessage");
    constructor(client) {
      this.client = client;
      this.register(require_ApplicationCommandPermissionsUpdate());
      this.register(require_AutoModerationActionExecution2());
      this.register(require_AutoModerationRuleCreate());
      this.register(require_AutoModerationRuleDelete());
      this.register(require_AutoModerationRuleUpdate());
      this.register(require_ChannelCreate());
      this.register(require_ChannelDelete());
      this.register(require_ChannelUpdate());
      this.register(require_GuildAuditLogEntryCreate());
      this.register(require_GuildBanAdd());
      this.register(require_GuildBanRemove());
      this.register(require_GuildChannelsPositionUpdate());
      this.register(require_GuildDelete());
      this.register(require_GuildEmojiCreate());
      this.register(require_GuildEmojiDelete());
      this.register(require_GuildEmojiUpdate());
      this.register(require_GuildEmojisUpdate());
      this.register(require_GuildIntegrationsUpdate());
      this.register(require_GuildMemberRemove());
      this.register(require_GuildMemberUpdate());
      this.register(require_GuildRoleCreate());
      this.register(require_GuildRoleDelete());
      this.register(require_GuildRoleUpdate());
      this.register(require_GuildRolesPositionUpdate());
      this.register(require_GuildScheduledEventCreate());
      this.register(require_GuildScheduledEventDelete());
      this.register(require_GuildScheduledEventUpdate());
      this.register(require_GuildScheduledEventUserAdd());
      this.register(require_GuildScheduledEventUserRemove());
      this.register(require_GuildStickerCreate());
      this.register(require_GuildStickerDelete());
      this.register(require_GuildStickerUpdate());
      this.register(require_GuildStickersUpdate());
      this.register(require_GuildUpdate());
      this.register(require_InteractionCreate());
      this.register(require_InviteCreate());
      this.register(require_InviteDelete());
      this.register(require_MessageCreate());
      this.register(require_MessageDelete());
      this.register(require_MessageDeleteBulk());
      this.register(require_MessageReactionAdd());
      this.register(require_MessageReactionRemove());
      this.register(require_MessageReactionRemoveAll());
      this.register(require_MessageReactionRemoveEmoji());
      this.register(require_MessageUpdate());
      this.register(require_PresenceUpdate());
      this.register(require_StageInstanceCreate());
      this.register(require_StageInstanceDelete());
      this.register(require_StageInstanceUpdate());
      this.register(require_ThreadCreate());
      this.register(require_ThreadDelete());
      this.register(require_ThreadListSync());
      this.register(require_ThreadMemberUpdate());
      this.register(require_ThreadMembersUpdate());
      this.register(require_TypingStart());
      this.register(require_UserUpdate());
      this.register(require_VoiceStateUpdate());
      this.register(require_WebhooksUpdate());
    }
    register(Action) {
      this[Action.name.replace(/Action$/, "")] = new Action(this.client);
    }
  }
  module.exports = ActionsManager;
});

// node_modules/discord.js/src/client/voice/ClientVoiceManager.js
var require_ClientVoiceManager = __commonJS((exports, module) => {
  var Events = require_Events();

  class ClientVoiceManager {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
      this.adapters = new Map;
      client.on(Events.ShardDisconnect, (_, shardId) => {
        for (const [guildId, adapter] of this.adapters.entries()) {
          if (client.guilds.cache.get(guildId)?.shardId === shardId) {
            adapter.destroy();
          }
        }
      });
    }
    onVoiceServer(payload) {
      this.adapters.get(payload.guild_id)?.onVoiceServerUpdate(payload);
    }
    onVoiceStateUpdate(payload) {
      if (payload.guild_id && payload.session_id && payload.user_id === this.client.user?.id) {
        this.adapters.get(payload.guild_id)?.onVoiceStateUpdate(payload);
      }
    }
  }
  module.exports = ClientVoiceManager;
});

// node_modules/@discordjs/ws/node_modules/@discordjs/collection/dist/index.js
var require_dist10 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    findLast(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const val = entries[index][1];
        const key = entries[index][0];
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findLastKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const entries = [...this.entries()];
      for (let index = entries.length - 1;index >= 0; index--) {
        const key = entries[index][0];
        const val = entries[index][1];
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    reduceRight(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      const entries = [...this.entries()];
      let accumulator;
      let index;
      if (initialValue === undefined) {
        if (entries.length === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = entries[entries.length - 1][1];
        index = entries.length - 1;
      } else {
        accumulator = initialValue;
        index = entries.length;
      }
      while (--index >= 0) {
        const key = entries[index][0];
        const val = entries[index][1];
        accumulator = fn(accumulator, val, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersection(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    union(other) {
      const coll = new this.constructor[Symbol.species](this);
      for (const [key, value] of other) {
        if (!coll.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    symmetricDifference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    toReversed() {
      return new this.constructor[Symbol.species](this).reverse();
    }
    toSorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.entries()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "2.0.0";
});

// node_modules/ws/lib/constants.js
var require_constants5 = __commonJS((exports, module) => {
  module.exports = {
    BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {
    }
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var concat = function(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  };
  var _mask = function(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  };
  var _unmask = function(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  };
  var toArrayBuffer = function(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  };
  var toBuffer = function(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  };
  var { EMPTY_BUFFER } = require_constants5();
  var FastBuffer = Buffer[Symbol.species];
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{throw new Error(`Cannot require module "bufferutil"`);})();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var deflateOnData = function(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  };
  var inflateOnData = function(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  };
  var inflateOnError = function(err) {
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
  };
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants5();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var isValidStatusCode = function(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  };
  var _isValidUTF8 = function(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  };
  var { isUtf8 } = __require("buffer");
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{throw new Error(`Cannot require module "utf-8-validate"`);})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver2 = __commonJS((exports, module) => {
  var error = function(ErrorCtor, message, prefix, statusCode, errorCode) {
    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
    Error.captureStackTrace(err, error);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  };
  var queueMicrotaskShim = function(cb) {
    promise.then(cb).catch(throwErrorNextTick);
  };
  var throwError = function(err) {
    throw err;
  };
  var throwErrorNextTick = function(err) {
    process.nextTick(throwError, err);
  };
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants5();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var promise = Promise.resolve();
  var queueTask = typeof queueMicrotask === "function" ? queueMicrotask : queueMicrotaskShim;
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var WAIT_MICROTASK = 6;

  class Receiver extends Writable {
    constructor(options = {}) {
      super();
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._state = GET_INFO;
      this._loop = false;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      let err;
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            err = this.getInfo();
            break;
          case GET_PAYLOAD_LENGTH_16:
            err = this.getPayloadLength16();
            break;
          case GET_PAYLOAD_LENGTH_64:
            err = this.getPayloadLength64();
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            err = this.getData(cb);
            break;
          case INFLATING:
            this._loop = false;
            return;
          default:
            this._loop = false;
            queueTask(() => {
              this._state = GET_INFO;
              this.startLoop(cb);
            });
            return;
        }
      } while (this._loop);
      cb(err);
    }
    getInfo() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        this._loop = false;
        return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        this._loop = false;
        return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        if (!this._fragmented) {
          this._loop = false;
          return error(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          this._loop = false;
          return error(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
        }
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          this._loop = false;
          return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
        }
      } else {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
        }
      } else if (this._masked) {
        this._loop = false;
        return error(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        return this.haveLength();
    }
    getPayloadLength16() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      return this.haveLength();
    }
    getPayloadLength64() {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        this._loop = false;
        return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      return this.haveLength();
    }
    haveLength() {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          this._loop = false;
          return error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7)
        return this.controlMessage(data);
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      return this.dataMessage();
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            return cb(error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
          }
          this._fragments.push(buf);
        }
        const er = this.dataMessage();
        if (er)
          return cb(er);
        this.startLoop(cb);
      });
    }
    dataMessage() {
      if (this._fin) {
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }
          this.emit("message", data, true);
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            this._loop = false;
            return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          }
          this.emit("message", buf, false);
        }
      }
      this._state = WAIT_MICROTASK;
    }
    controlMessage(data) {
      if (this._opcode === 8) {
        this._loop = false;
        if (data.length === 0) {
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
          this._state = GET_INFO;
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            return error(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          }
          this.emit("conclude", code, buf);
          this.end();
          this._state = GET_INFO;
        }
      } else if (this._opcode === 9) {
        this.emit("ping", data);
        this._state = WAIT_MICROTASK;
      } else {
        this.emit("pong", data);
        this._state = WAIT_MICROTASK;
      }
    }
  }
  module.exports = Receiver;
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER } = require_constants5();
  var { isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    static frame(data, options) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          randomFillSync(mask, 0, 4);
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      if (perMessageDeflate) {
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }), cb);
      }
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          if (typeof cb === "function")
            cb(err);
          for (let i = 0;i < this._queue.length; i++) {
            const params = this._queue[i];
            const callback = params[params.length - 1];
            if (typeof callback === "function")
              callback(err);
          }
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._deflating = false;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (!this._deflating && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var callListener = function(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  };
  var { kForOnEventAttribute, kListener } = require_constants5();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event2 {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event2.prototype, "target", { enumerable: true });
  Object.defineProperty(Event2.prototype, "type", { enumerable: true });

  class CloseEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === undefined ? 0 : options.code;
      this[kReason] = options.reason === undefined ? "" : options.reason;
      this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === undefined ? null : options.error;
      this[kMessage] = options.message === undefined ? "" : options.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === undefined ? null : options.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget2 = {
    addEventListener(type, handler, options = {}) {
      for (const listener of this.listeners(type)) {
        if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event2("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event: Event2,
    EventTarget: EventTarget2,
    MessageEvent
  };
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var push = function(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  };
  var parse = function(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  };
  var format = function(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  };
  var { tokenChars } = require_validation();
  module.exports = { format, parse };
});

// node_modules/ws/lib/websocket.js
var require_websocket2 = __commonJS((exports, module) => {
  var initAsClient = function(websocket, address, protocols, options) {
    const opts = {
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = isSecure ? tlsConnect : netConnect;
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      if (res.headers.upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  };
  var emitErrorAndClose = function(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit("error", err);
    websocket.emitClose();
  };
  var netConnect = function(options) {
    options.path = options.socketPath;
    return net.connect(options);
  };
  var tlsConnect = function(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  };
  var abortHandshake = function(websocket, stream, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  };
  var sendAfterClose = function(websocket, data, cb) {
    if (data) {
      const length = toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  };
  var receiverOnConclude = function(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  };
  var receiverOnDrain = function() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  };
  var receiverOnError = function(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    websocket.emit("error", err);
  };
  var receiverOnFinish = function() {
    this[kWebSocket].emitClose();
  };
  var receiverOnMessage = function(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  };
  var receiverOnPing = function(data) {
    const websocket = this[kWebSocket];
    websocket.pong(data, !websocket._isServer, NOOP);
    websocket.emit("ping", data);
  };
  var receiverOnPong = function(data) {
    this[kWebSocket].emit("pong", data);
  };
  var resume = function(stream) {
    stream.resume();
  };
  var socketOnClose = function() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  };
  var socketOnData = function(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  };
  var socketOnEnd = function() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  };
  var socketOnError = function() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  };
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver2();
  var Sender = require_sender();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants5();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options) {
      const receiver = new Receiver({
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      this._sender = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket;
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var emitClose = function(stream) {
    stream.emit("close");
  };
  var duplexOnEnd = function() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  };
  var duplexOnError = function(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  };
  var createWebSocketStream = function(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  };
  var { Duplex } = __require("stream");
  module.exports = createWebSocketStream;
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var parse = function(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  };
  var { tokenChars } = require_validation();
  module.exports = { parse };
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var addListeners = function(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  };
  var emitClose = function(server) {
    server._state = CLOSED;
    server.emit("close");
  };
  var socketOnError = function() {
    this.destroy();
  };
  var abortHandshake = function(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
  };
  var abortHandshakeOrEmitwsClientError = function(server, req, socket, code, message) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message);
    }
  };
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket = require_websocket2();
  var { GUID, kWebSocket } = require_constants5();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (req.headers.upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!key || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 8 && version !== 13) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat("\r\n").join("\r\n"));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
});

// node_modules/ws/index.js
var require_ws = __commonJS((exports, module) => {
  var WebSocket = require_websocket2();
  WebSocket.createWebSocketStream = require_stream();
  WebSocket.Server = require_websocket_server();
  WebSocket.Receiver = require_receiver2();
  WebSocket.Sender = require_sender();
  WebSocket.WebSocket = WebSocket;
  WebSocket.WebSocketServer = WebSocket.Server;
  module.exports = WebSocket;
});

// node_modules/@discordjs/ws/dist/index.js
var require_dist11 = __commonJS((exports, module) => {
  async function managerToFetchingStrategyOptions(manager) {
    const {
      buildIdentifyThrottler,
      buildStrategy,
      retrieveSessionInfo,
      updateSessionInfo,
      shardCount,
      shardIds,
      rest,
      ...managerOptions
    } = manager.options;
    return {
      ...managerOptions,
      gatewayInformation: await manager.fetchGatewayInformation(),
      shardCount: await manager.getShardCount()
    };
  }
  var getInitialSendRateLimitState = function() {
    return {
      remaining: 120,
      resetAt: Date.now() + 60000
    };
  };
  var __dirname = "/Users/jordanfonseca/Projects/Misc/cex-discord-bot/node_modules/@discordjs/ws/dist";
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    CloseCodes: () => CloseCodes,
    CompressionMethod: () => CompressionMethod,
    DefaultDeviceProperty: () => DefaultDeviceProperty,
    DefaultWebSocketManagerOptions: () => DefaultWebSocketManagerOptions,
    Encoding: () => Encoding,
    ImportantGatewayOpcodes: () => ImportantGatewayOpcodes,
    SimpleContextFetchingStrategy: () => SimpleContextFetchingStrategy,
    SimpleIdentifyThrottler: () => SimpleIdentifyThrottler,
    SimpleShardingStrategy: () => SimpleShardingStrategy,
    WebSocketManager: () => WebSocketManager,
    WebSocketShard: () => WebSocketShard,
    WebSocketShardDestroyRecovery: () => WebSocketShardDestroyRecovery,
    WebSocketShardEvents: () => WebSocketShardEvents,
    WebSocketShardStatus: () => WebSocketShardStatus,
    WorkerBootstrapper: () => WorkerBootstrapper,
    WorkerContextFetchingStrategy: () => WorkerContextFetchingStrategy,
    WorkerReceivePayloadOp: () => WorkerReceivePayloadOp,
    WorkerSendPayloadOp: () => WorkerSendPayloadOp,
    WorkerShardingStrategy: () => WorkerShardingStrategy,
    getInitialSendRateLimitState: () => getInitialSendRateLimitState,
    managerToFetchingStrategyOptions: () => managerToFetchingStrategyOptions,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  __name(managerToFetchingStrategyOptions, "managerToFetchingStrategyOptions");
  var SimpleContextFetchingStrategy = class _SimpleContextFetchingStrategy {
    constructor(manager, options) {
      this.manager = manager;
      this.options = options;
    }
    static {
      __name(this, "SimpleContextFetchingStrategy");
    }
    static throttlerCache = new WeakMap;
    static async ensureThrottler(manager) {
      const throttler = _SimpleContextFetchingStrategy.throttlerCache.get(manager);
      if (throttler) {
        return throttler;
      }
      const newThrottler = await manager.options.buildIdentifyThrottler(manager);
      _SimpleContextFetchingStrategy.throttlerCache.set(manager, newThrottler);
      return newThrottler;
    }
    async retrieveSessionInfo(shardId) {
      return this.manager.options.retrieveSessionInfo(shardId);
    }
    updateSessionInfo(shardId, sessionInfo) {
      return this.manager.options.updateSessionInfo(shardId, sessionInfo);
    }
    async waitForIdentify(shardId, signal) {
      const throttler = await _SimpleContextFetchingStrategy.ensureThrottler(this.manager);
      await throttler.waitForIdentify(shardId, signal);
    }
  };
  var import_node_worker_threads2 = __require("worker_threads");
  var import_collection2 = require_dist10();
  var import_node_events = __require("events");
  var import_node_path = __require("path");
  var import_node_worker_threads = __require("worker_threads");
  var import_collection = require_dist10();
  var WorkerSendPayloadOp = ((WorkerSendPayloadOp2) => {
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Connect"] = 0] = "Connect";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Destroy"] = 1] = "Destroy";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Send"] = 2] = "Send";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["SessionInfoResponse"] = 3] = "SessionInfoResponse";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["ShardIdentifyResponse"] = 4] = "ShardIdentifyResponse";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["FetchStatus"] = 5] = "FetchStatus";
    return WorkerSendPayloadOp2;
  })(WorkerSendPayloadOp || {});
  var WorkerReceivePayloadOp = ((WorkerReceivePayloadOp2) => {
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Connected"] = 0] = "Connected";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Destroyed"] = 1] = "Destroyed";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Event"] = 2] = "Event";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["RetrieveSessionInfo"] = 3] = "RetrieveSessionInfo";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["UpdateSessionInfo"] = 4] = "UpdateSessionInfo";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WaitForIdentify"] = 5] = "WaitForIdentify";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["FetchStatusResponse"] = 6] = "FetchStatusResponse";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WorkerReady"] = 7] = "WorkerReady";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["CancelIdentify"] = 8] = "CancelIdentify";
    return WorkerReceivePayloadOp2;
  })(WorkerReceivePayloadOp || {});
  var WorkerShardingStrategy = class {
    static {
      __name(this, "WorkerShardingStrategy");
    }
    manager;
    options;
    #workers = [];
    #workerByShardId = new import_collection.Collection;
    connectPromises = new import_collection.Collection;
    destroyPromises = new import_collection.Collection;
    fetchStatusPromises = new import_collection.Collection;
    waitForIdentifyControllers = new import_collection.Collection;
    throttler;
    constructor(manager, options) {
      this.manager = manager;
      this.options = options;
    }
    async spawn(shardIds) {
      const shardsPerWorker = this.options.shardsPerWorker === "all" ? shardIds.length : this.options.shardsPerWorker;
      const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
      const loops = Math.ceil(shardIds.length / shardsPerWorker);
      const promises = [];
      for (let idx = 0;idx < loops; idx++) {
        const slice = shardIds.slice(idx * shardsPerWorker, (idx + 1) * shardsPerWorker);
        const workerData2 = {
          ...strategyOptions,
          shardIds: slice
        };
        promises.push(this.setupWorker(workerData2));
      }
      await Promise.all(promises);
    }
    async connect() {
      const promises = [];
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const payload = {
          op: 0,
          shardId
        };
        const promise = new Promise((resolve2) => this.connectPromises.set(shardId, resolve2));
        worker.postMessage(payload);
        promises.push(promise);
      }
      await Promise.all(promises);
    }
    async destroy(options = {}) {
      const promises = [];
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const payload = {
          op: 1,
          shardId,
          options
        };
        promises.push(new Promise((resolve2) => this.destroyPromises.set(shardId, resolve2)).then(async () => worker.terminate()));
        worker.postMessage(payload);
      }
      this.#workers = [];
      this.#workerByShardId.clear();
      await Promise.all(promises);
    }
    send(shardId, data) {
      const worker = this.#workerByShardId.get(shardId);
      if (!worker) {
        throw new Error(`No worker found for shard ${shardId}`);
      }
      const payload = {
        op: 2,
        shardId,
        payload: data
      };
      worker.postMessage(payload);
    }
    async fetchStatus() {
      const statuses = new import_collection.Collection;
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const nonce = Math.random();
        const payload = {
          op: 5,
          shardId,
          nonce
        };
        const promise = new Promise((resolve2) => this.fetchStatusPromises.set(nonce, resolve2));
        worker.postMessage(payload);
        const status = await promise;
        statuses.set(shardId, status);
      }
      return statuses;
    }
    async setupWorker(workerData2) {
      const worker = new import_node_worker_threads.Worker(this.resolveWorkerPath(), { workerData: workerData2 });
      await (0, import_node_events.once)(worker, "online");
      await this.waitForWorkerReady(worker);
      worker.on("error", (err) => {
        throw err;
      }).on("messageerror", (err) => {
        throw err;
      }).on("message", async (payload) => this.onMessage(worker, payload));
      this.#workers.push(worker);
      for (const shardId of workerData2.shardIds) {
        this.#workerByShardId.set(shardId, worker);
      }
    }
    resolveWorkerPath() {
      const path = this.options.workerPath;
      if (!path) {
        return (0, import_node_path.join)(__dirname, "defaultWorker.js");
      }
      if ((0, import_node_path.isAbsolute)(path)) {
        return path;
      }
      if (/^\.\.?[/\\]/.test(path)) {
        return (0, import_node_path.resolve)(path);
      }
      try {
        return __require.resolve(path);
      } catch {
        return (0, import_node_path.resolve)(path);
      }
    }
    async waitForWorkerReady(worker) {
      return new Promise((resolve2) => {
        const handler = __name((payload) => {
          if (payload.op === 7) {
            resolve2();
            worker.off("message", handler);
          }
        }, "handler");
        worker.on("message", handler);
      });
    }
    async onMessage(worker, payload) {
      switch (payload.op) {
        case 0: {
          this.connectPromises.get(payload.shardId)?.();
          this.connectPromises.delete(payload.shardId);
          break;
        }
        case 1: {
          this.destroyPromises.get(payload.shardId)?.();
          this.destroyPromises.delete(payload.shardId);
          break;
        }
        case 2: {
          this.manager.emit(payload.event, { ...payload.data, shardId: payload.shardId });
          break;
        }
        case 3: {
          const session = await this.manager.options.retrieveSessionInfo(payload.shardId);
          const response = {
            op: 3,
            nonce: payload.nonce,
            session
          };
          worker.postMessage(response);
          break;
        }
        case 4: {
          await this.manager.options.updateSessionInfo(payload.shardId, payload.session);
          break;
        }
        case 5: {
          const throttler = await this.ensureThrottler();
          try {
            const controller = new AbortController;
            this.waitForIdentifyControllers.set(payload.nonce, controller);
            await throttler.waitForIdentify(payload.shardId, controller.signal);
          } catch {
            return;
          }
          const response = {
            op: 4,
            nonce: payload.nonce,
            ok: true
          };
          worker.postMessage(response);
          break;
        }
        case 6: {
          this.fetchStatusPromises.get(payload.nonce)?.(payload.status);
          this.fetchStatusPromises.delete(payload.nonce);
          break;
        }
        case 7: {
          break;
        }
        case 8: {
          this.waitForIdentifyControllers.get(payload.nonce)?.abort();
          this.waitForIdentifyControllers.delete(payload.nonce);
          const response = {
            op: 4,
            nonce: payload.nonce,
            ok: false
          };
          worker.postMessage(response);
          break;
        }
      }
    }
    async ensureThrottler() {
      this.throttler ??= await this.manager.options.buildIdentifyThrottler(this.manager);
      return this.throttler;
    }
  };
  var WorkerContextFetchingStrategy = class {
    constructor(options) {
      this.options = options;
      if (import_node_worker_threads2.isMainThread) {
        throw new Error("Cannot instantiate WorkerContextFetchingStrategy on the main thread");
      }
      import_node_worker_threads2.parentPort.on("message", (payload) => {
        if (payload.op === 3) {
          this.sessionPromises.get(payload.nonce)?.(payload.session);
          this.sessionPromises.delete(payload.nonce);
        }
        if (payload.op === 4) {
          const promise = this.waitForIdentifyPromises.get(payload.nonce);
          if (payload.ok) {
            promise?.resolve();
          } else {
            promise?.reject(promise.signal.reason);
          }
          this.waitForIdentifyPromises.delete(payload.nonce);
        }
      });
    }
    static {
      __name(this, "WorkerContextFetchingStrategy");
    }
    sessionPromises = new import_collection2.Collection;
    waitForIdentifyPromises = new import_collection2.Collection;
    async retrieveSessionInfo(shardId) {
      const nonce = Math.random();
      const payload = {
        op: 3,
        shardId,
        nonce
      };
      const promise = new Promise((resolve2) => this.sessionPromises.set(nonce, resolve2));
      import_node_worker_threads2.parentPort.postMessage(payload);
      return promise;
    }
    updateSessionInfo(shardId, sessionInfo) {
      const payload = {
        op: 4,
        shardId,
        session: sessionInfo
      };
      import_node_worker_threads2.parentPort.postMessage(payload);
    }
    async waitForIdentify(shardId, signal) {
      const nonce = Math.random();
      const payload = {
        op: 5,
        nonce,
        shardId
      };
      const promise = new Promise((resolve2, reject) => this.waitForIdentifyPromises.set(nonce, { signal, resolve: resolve2, reject }));
      import_node_worker_threads2.parentPort.postMessage(payload);
      const listener = __name(() => {
        const payload2 = {
          op: 8,
          nonce
        };
        import_node_worker_threads2.parentPort.postMessage(payload2);
      }, "listener");
      signal.addEventListener("abort", listener);
      try {
        await promise;
      } finally {
        signal.removeEventListener("abort", listener);
      }
    }
  };
  var import_collection6 = require_dist10();
  var import_node_buffer = __require("buffer");
  var import_node_events2 = __require("events");
  var import_node_timers = __require("timers");
  var import_promises2 = __require("timers/promises");
  var import_node_url = __require("url");
  var import_node_util = __require("util");
  var import_node_zlib = __require("zlib");
  var import_collection5 = require_dist10();
  var import_util2 = require_dist();
  var import_async_queue2 = require_cjs();
  var import_async_event_emitter = require_dist4();
  var import_v102 = require_v106();
  var import_ws = require_ws();
  var import_node_process = __toESM2(__require("process"));
  var import_collection4 = require_dist10();
  var import_util = require_dist();
  var import_v10 = require_v106();
  var import_promises = __require("timers/promises");
  var import_collection3 = require_dist10();
  var import_async_queue = require_cjs();
  var SimpleIdentifyThrottler = class {
    constructor(maxConcurrency) {
      this.maxConcurrency = maxConcurrency;
    }
    static {
      __name(this, "SimpleIdentifyThrottler");
    }
    states = new import_collection3.Collection;
    async waitForIdentify(shardId, signal) {
      const key = shardId % this.maxConcurrency;
      const state = this.states.ensure(key, () => {
        return {
          queue: new import_async_queue.AsyncQueue,
          resetsAt: Number.POSITIVE_INFINITY
        };
      });
      await state.queue.wait({ signal });
      try {
        const diff = state.resetsAt - Date.now();
        if (diff <= 5000) {
          const time = diff + Math.random() * 1500;
          await (0, import_promises.setTimeout)(time);
        }
        state.resetsAt = Date.now() + 5000;
      } finally {
        state.queue.shift();
      }
    }
  };
  var Encoding = ((Encoding2) => {
    Encoding2["JSON"] = "json";
    return Encoding2;
  })(Encoding || {});
  var CompressionMethod = ((CompressionMethod2) => {
    CompressionMethod2["ZlibStream"] = "zlib-stream";
    return CompressionMethod2;
  })(CompressionMethod || {});
  var DefaultDeviceProperty = `@discordjs/ws 1.0.2`;
  var getDefaultSessionStore = (0, import_util.lazy)(() => new import_collection4.Collection);
  var DefaultWebSocketManagerOptions = {
    async buildIdentifyThrottler(manager) {
      const info = await manager.fetchGatewayInformation();
      return new SimpleIdentifyThrottler(info.session_start_limit.max_concurrency);
    },
    buildStrategy: (manager) => new SimpleShardingStrategy(manager),
    shardCount: null,
    shardIds: null,
    largeThreshold: null,
    initialPresence: null,
    identifyProperties: {
      browser: DefaultDeviceProperty,
      device: DefaultDeviceProperty,
      os: import_node_process.default.platform
    },
    version: import_v10.APIVersion,
    encoding: "json",
    compression: null,
    retrieveSessionInfo(shardId) {
      const store = getDefaultSessionStore();
      return store.get(shardId) ?? null;
    },
    updateSessionInfo(shardId, info) {
      const store = getDefaultSessionStore();
      if (info) {
        store.set(shardId, info);
      } else {
        store.delete(shardId);
      }
    },
    handshakeTimeout: 30000,
    helloTimeout: 60000,
    readyTimeout: 15000
  };
  var ImportantGatewayOpcodes = new Set([
    import_v10.GatewayOpcodes.Heartbeat,
    import_v10.GatewayOpcodes.Identify,
    import_v10.GatewayOpcodes.Resume
  ]);
  __name(getInitialSendRateLimitState, "getInitialSendRateLimitState");
  var getZlibSync = (0, import_util2.lazy)(async () => import("zlib-sync").then((mod) => mod.default).catch(() => null));
  var WebSocketShardEvents = ((WebSocketShardEvents2) => {
    WebSocketShardEvents2["Closed"] = "closed";
    WebSocketShardEvents2["Debug"] = "debug";
    WebSocketShardEvents2["Dispatch"] = "dispatch";
    WebSocketShardEvents2["Error"] = "error";
    WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
    WebSocketShardEvents2["Hello"] = "hello";
    WebSocketShardEvents2["Ready"] = "ready";
    WebSocketShardEvents2["Resumed"] = "resumed";
    return WebSocketShardEvents2;
  })(WebSocketShardEvents || {});
  var WebSocketShardStatus = ((WebSocketShardStatus2) => {
    WebSocketShardStatus2[WebSocketShardStatus2["Idle"] = 0] = "Idle";
    WebSocketShardStatus2[WebSocketShardStatus2["Connecting"] = 1] = "Connecting";
    WebSocketShardStatus2[WebSocketShardStatus2["Resuming"] = 2] = "Resuming";
    WebSocketShardStatus2[WebSocketShardStatus2["Ready"] = 3] = "Ready";
    return WebSocketShardStatus2;
  })(WebSocketShardStatus || {});
  var WebSocketShardDestroyRecovery = ((WebSocketShardDestroyRecovery2) => {
    WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Reconnect"] = 0] = "Reconnect";
    WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Resume"] = 1] = "Resume";
    return WebSocketShardDestroyRecovery2;
  })(WebSocketShardDestroyRecovery || {});
  var CloseCodes = ((CloseCodes2) => {
    CloseCodes2[CloseCodes2["Normal"] = 1000] = "Normal";
    CloseCodes2[CloseCodes2["Resuming"] = 4200] = "Resuming";
    return CloseCodes2;
  })(CloseCodes || {});
  var WebSocketConstructor = import_ws.WebSocket;
  var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter {
    static {
      __name(this, "WebSocketShard");
    }
    connection = null;
    useIdentifyCompress = false;
    inflate = null;
    textDecoder = new import_node_util.TextDecoder;
    replayedEvents = 0;
    isAck = true;
    sendRateLimitState = getInitialSendRateLimitState();
    initialHeartbeatTimeoutController = null;
    heartbeatInterval = null;
    lastHeartbeatAt = -1;
    initialConnectResolved = false;
    failedToConnectDueToNetworkError = false;
    sendQueue = new import_async_queue2.AsyncQueue;
    timeoutAbortControllers = new import_collection5.Collection;
    strategy;
    id;
    #status = 0;
    get status() {
      return this.#status;
    }
    constructor(strategy, id) {
      super();
      this.strategy = strategy;
      this.id = id;
    }
    async connect() {
      const controller = new AbortController;
      let promise;
      if (!this.initialConnectResolved) {
        promise = Promise.race([
          (0, import_node_events2.once)(this, "ready", { signal: controller.signal }),
          (0, import_node_events2.once)(this, "resumed", { signal: controller.signal })
        ]);
      }
      this.internalConnect();
      try {
        await promise;
      } catch ({ error }) {
        throw error;
      } finally {
        controller.abort();
      }
      this.initialConnectResolved = true;
    }
    async internalConnect() {
      if (this.#status !== 0) {
        throw new Error("Tried to connect a shard that wasn't idle");
      }
      const { version: version2, encoding, compression } = this.strategy.options;
      const params = new import_node_url.URLSearchParams({ v: version2, encoding });
      if (compression) {
        const zlib = await getZlibSync();
        if (zlib) {
          params.append("compress", compression);
          this.inflate = new zlib.Inflate({
            chunkSize: 65535,
            to: "string"
          });
        } else if (!this.useIdentifyCompress) {
          this.useIdentifyCompress = true;
          console.warn("WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress");
        }
      }
      const session = await this.strategy.retrieveSessionInfo(this.id);
      const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
      this.debug([`Connecting to ${url}`]);
      const connection = new WebSocketConstructor(url, {
        handshakeTimeout: this.strategy.options.handshakeTimeout ?? undefined
      });
      connection.binaryType = "arraybuffer";
      connection.onmessage = (event) => {
        this.onMessage(event.data, event.data instanceof ArrayBuffer);
      };
      connection.onerror = (event) => {
        this.onError(event.error);
      };
      connection.onclose = (event) => {
        this.onClose(event.code);
      };
      this.connection = connection;
      this.#status = 1;
      this.sendRateLimitState = getInitialSendRateLimitState();
      const { ok } = await this.waitForEvent("hello", this.strategy.options.helloTimeout);
      if (!ok) {
        return;
      }
      if (session?.shardCount === this.strategy.options.shardCount) {
        await this.resume(session);
      } else {
        await this.identify();
      }
    }
    async destroy(options = {}) {
      if (this.#status === 0) {
        this.debug(["Tried to destroy a shard that was idle"]);
        return;
      }
      if (!options.code) {
        options.code = options.recover === 1 ? 4200 : 1000;
      }
      this.debug([
        "Destroying shard",
        `Reason: ${options.reason ?? "none"}`,
        `Code: ${options.code}`,
        `Recover: ${options.recover === undefined ? "none" : WebSocketShardDestroyRecovery[options.recover]}`
      ]);
      this.isAck = true;
      if (this.heartbeatInterval) {
        (0, import_node_timers.clearInterval)(this.heartbeatInterval);
      }
      if (this.initialHeartbeatTimeoutController) {
        this.initialHeartbeatTimeoutController.abort();
        this.initialHeartbeatTimeoutController = null;
      }
      this.lastHeartbeatAt = -1;
      for (const controller of this.timeoutAbortControllers.values()) {
        controller.abort();
      }
      this.timeoutAbortControllers.clear();
      this.failedToConnectDueToNetworkError = false;
      if (options.recover !== 1) {
        await this.strategy.updateSessionInfo(this.id, null);
      }
      if (this.connection) {
        this.connection.onmessage = null;
        this.connection.onclose = null;
        const shouldClose = this.connection.readyState === import_ws.WebSocket.OPEN;
        this.debug([
          "Connection status during destroy",
          `Needs closing: ${shouldClose}`,
          `Ready state: ${this.connection.readyState}`
        ]);
        if (shouldClose) {
          let outerResolve;
          const promise = new Promise((resolve2) => {
            outerResolve = resolve2;
          });
          this.connection.onclose = outerResolve;
          this.connection.close(options.code, options.reason);
          await promise;
          this.emit("closed", { code: options.code });
        }
        this.connection.onerror = null;
      } else {
        this.debug(["Destroying a shard that has no connection; please open an issue on GitHub"]);
      }
      this.#status = 0;
      if (options.recover !== undefined) {
        await (0, import_promises2.setTimeout)(500);
        return this.internalConnect();
      }
    }
    async waitForEvent(event, timeoutDuration) {
      this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
      const timeoutController = new AbortController;
      const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration).unref() : null;
      this.timeoutAbortControllers.set(event, timeoutController);
      const closeController = new AbortController;
      try {
        const closed = await Promise.race([
          (0, import_node_events2.once)(this, event, { signal: timeoutController.signal }).then(() => false),
          (0, import_node_events2.once)(this, "closed", { signal: closeController.signal }).then(() => true)
        ]);
        return { ok: !closed };
      } catch {
        this.destroy({
          code: 1000,
          reason: "Something timed out or went wrong while waiting for an event",
          recover: 0
        });
        return { ok: false };
      } finally {
        if (timeout) {
          (0, import_node_timers.clearTimeout)(timeout);
        }
        this.timeoutAbortControllers.delete(event);
        if (!closeController.signal.aborted) {
          closeController.abort();
        }
      }
    }
    async send(payload) {
      if (!this.connection) {
        throw new Error("WebSocketShard wasn't connected");
      }
      if (this.#status !== 3 && !ImportantGatewayOpcodes.has(payload.op)) {
        this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
        try {
          await (0, import_node_events2.once)(this, "ready");
        } catch {
          return this.send(payload);
        }
      }
      await this.sendQueue.wait();
      if (--this.sendRateLimitState.remaining <= 0) {
        const now = Date.now();
        if (this.sendRateLimitState.resetAt > now) {
          const sleepFor = this.sendRateLimitState.resetAt - now;
          this.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);
          const controller = new AbortController;
          const interrupted = await Promise.race([
            (0, import_promises2.setTimeout)(sleepFor).then(() => false),
            (0, import_node_events2.once)(this, "closed", { signal: controller.signal }).then(() => true)
          ]);
          if (interrupted) {
            this.debug(["Connection closed while waiting for the send rate limit to reset, re-queueing payload"]);
            this.sendQueue.shift();
            return this.send(payload);
          }
          controller.abort();
        }
        this.sendRateLimitState = getInitialSendRateLimitState();
      }
      this.sendQueue.shift();
      this.connection.send(JSON.stringify(payload));
    }
    async identify() {
      this.debug(["Waiting for identify throttle"]);
      const controller = new AbortController;
      const closeHandler = __name(() => {
        controller.abort();
      }, "closeHandler");
      this.on("closed", closeHandler);
      try {
        await this.strategy.waitForIdentify(this.id, controller.signal);
      } catch {
        if (controller.signal.aborted) {
          this.debug(["Was waiting for an identify, but the shard closed in the meantime"]);
          return;
        }
        this.debug([
          "IContextFetchingStrategy#waitForIdentify threw an unknown error.",
          "If you're using a custom strategy, this is probably nothing to worry about.",
          "If you're not, please open an issue on GitHub."
        ]);
        await this.destroy({
          reason: "Identify throttling logic failed",
          recover: 1
        });
      } finally {
        this.off("closed", closeHandler);
      }
      this.debug([
        "Identifying",
        `shard id: ${this.id.toString()}`,
        `shard count: ${this.strategy.options.shardCount}`,
        `intents: ${this.strategy.options.intents}`,
        `compression: ${this.inflate ? "zlib-stream" : this.useIdentifyCompress ? "identify" : "none"}`
      ]);
      const d = {
        token: this.strategy.options.token,
        properties: this.strategy.options.identifyProperties,
        intents: this.strategy.options.intents,
        compress: this.useIdentifyCompress,
        shard: [this.id, this.strategy.options.shardCount]
      };
      if (this.strategy.options.largeThreshold) {
        d.large_threshold = this.strategy.options.largeThreshold;
      }
      if (this.strategy.options.initialPresence) {
        d.presence = this.strategy.options.initialPresence;
      }
      await this.send({
        op: import_v102.GatewayOpcodes.Identify,
        d
      });
      await this.waitForEvent("ready", this.strategy.options.readyTimeout);
    }
    async resume(session) {
      this.debug([
        "Resuming session",
        `resume url: ${session.resumeURL}`,
        `sequence: ${session.sequence}`,
        `shard id: ${this.id.toString()}`
      ]);
      this.#status = 2;
      this.replayedEvents = 0;
      return this.send({
        op: import_v102.GatewayOpcodes.Resume,
        d: {
          token: this.strategy.options.token,
          seq: session.sequence,
          session_id: session.sessionId
        }
      });
    }
    async heartbeat(requested = false) {
      if (!this.isAck && !requested) {
        return this.destroy({ reason: "Zombie connection", recover: 1 });
      }
      const session = await this.strategy.retrieveSessionInfo(this.id);
      await this.send({
        op: import_v102.GatewayOpcodes.Heartbeat,
        d: session?.sequence ?? null
      });
      this.lastHeartbeatAt = Date.now();
      this.isAck = false;
    }
    async unpackMessage(data, isBinary) {
      if (!isBinary) {
        try {
          return JSON.parse(data);
        } catch {
          return null;
        }
      }
      const decompressable = new Uint8Array(data);
      if (this.useIdentifyCompress) {
        return new Promise((resolve2, reject) => {
          (0, import_node_zlib.inflate)(decompressable, { chunkSize: 65535 }, (err, result) => {
            if (err) {
              reject(err);
              return;
            }
            resolve2(JSON.parse(this.textDecoder.decode(result)));
          });
        });
      }
      if (this.inflate) {
        const l = decompressable.length;
        const flush = l >= 4 && decompressable[l - 4] === 0 && decompressable[l - 3] === 0 && decompressable[l - 2] === 255 && decompressable[l - 1] === 255;
        const zlib = await getZlibSync();
        this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
        if (this.inflate.err) {
          this.emit("error", {
            error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`)
          });
        }
        if (!flush) {
          return null;
        }
        const { result } = this.inflate;
        if (!result) {
          return null;
        }
        return JSON.parse(typeof result === "string" ? result : this.textDecoder.decode(result));
      }
      this.debug([
        "Received a message we were unable to decompress",
        `isBinary: ${isBinary.toString()}`,
        `useIdentifyCompress: ${this.useIdentifyCompress.toString()}`,
        `inflate: ${Boolean(this.inflate).toString()}`
      ]);
      return null;
    }
    async onMessage(data, isBinary) {
      const payload = await this.unpackMessage(data, isBinary);
      if (!payload) {
        return;
      }
      switch (payload.op) {
        case import_v102.GatewayOpcodes.Dispatch: {
          if (this.#status === 2) {
            this.replayedEvents++;
          }
          switch (payload.t) {
            case import_v102.GatewayDispatchEvents.Ready: {
              this.#status = 3;
              const session2 = {
                sequence: payload.s,
                sessionId: payload.d.session_id,
                shardId: this.id,
                shardCount: this.strategy.options.shardCount,
                resumeURL: payload.d.resume_gateway_url
              };
              await this.strategy.updateSessionInfo(this.id, session2);
              this.emit("ready", { data: payload.d });
              break;
            }
            case import_v102.GatewayDispatchEvents.Resumed: {
              this.#status = 3;
              this.debug([`Resumed and replayed ${this.replayedEvents} events`]);
              this.emit("resumed");
              break;
            }
            default: {
              break;
            }
          }
          const session = await this.strategy.retrieveSessionInfo(this.id);
          if (session) {
            if (payload.s > session.sequence) {
              await this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });
            }
          } else {
            this.debug([
              `Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`
            ]);
          }
          this.emit("dispatch", { data: payload });
          break;
        }
        case import_v102.GatewayOpcodes.Heartbeat: {
          await this.heartbeat(true);
          break;
        }
        case import_v102.GatewayOpcodes.Reconnect: {
          await this.destroy({
            reason: "Told to reconnect by Discord",
            recover: 1
          });
          break;
        }
        case import_v102.GatewayOpcodes.InvalidSession: {
          this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);
          const session = await this.strategy.retrieveSessionInfo(this.id);
          if (payload.d && session) {
            await this.resume(session);
          } else {
            await this.destroy({
              reason: "Invalid session",
              recover: 0
            });
          }
          break;
        }
        case import_v102.GatewayOpcodes.Hello: {
          this.emit("hello");
          const jitter = Math.random();
          const firstWait = Math.floor(payload.d.heartbeat_interval * jitter);
          this.debug([`Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`]);
          try {
            const controller = new AbortController;
            this.initialHeartbeatTimeoutController = controller;
            await (0, import_promises2.setTimeout)(firstWait, undefined, { signal: controller.signal });
          } catch {
            this.debug(["Cancelled initial heartbeat due to #destroy being called"]);
            return;
          } finally {
            this.initialHeartbeatTimeoutController = null;
          }
          await this.heartbeat();
          this.debug([`First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`]);
          this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
          break;
        }
        case import_v102.GatewayOpcodes.HeartbeatAck: {
          this.isAck = true;
          const ackAt = Date.now();
          this.emit("heartbeat", {
            ackAt,
            heartbeatAt: this.lastHeartbeatAt,
            latency: ackAt - this.lastHeartbeatAt
          });
          break;
        }
      }
    }
    onError(error) {
      if ("code" in error && ["ECONNRESET", "ECONNREFUSED"].includes(error.code)) {
        this.debug(["Failed to connect to the gateway URL specified due to a network error"]);
        this.failedToConnectDueToNetworkError = true;
        return;
      }
      this.emit("error", { error });
    }
    async onClose(code) {
      this.emit("closed", { code });
      switch (code) {
        case 1000: {
          return this.destroy({
            code,
            reason: "Got disconnected by Discord",
            recover: 0
          });
        }
        case 4200: {
          break;
        }
        case import_v102.GatewayCloseCodes.UnknownError: {
          this.debug([`An unknown error occurred: ${code}`]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.UnknownOpcode: {
          this.debug(["An invalid opcode was sent to Discord."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.DecodeError: {
          this.debug(["An invalid payload was sent to Discord."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.NotAuthenticated: {
          this.debug(["A request was somehow sent before the identify/resume payload."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.AuthenticationFailed: {
          this.emit("error", {
            error: new Error("Authentication failed")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.AlreadyAuthenticated: {
          this.debug(["More than one auth payload was sent."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.InvalidSeq: {
          this.debug(["An invalid sequence was sent."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.RateLimited: {
          this.debug(["The WebSocket rate limit has been hit, this should never happen"]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.SessionTimedOut: {
          this.debug(["Session timed out."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.InvalidShard: {
          this.emit("error", {
            error: new Error("Invalid shard")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.ShardingRequired: {
          this.emit("error", {
            error: new Error("Sharding is required")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.InvalidAPIVersion: {
          this.emit("error", {
            error: new Error("Used an invalid API version")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.InvalidIntents: {
          this.emit("error", {
            error: new Error("Used invalid intents")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.DisallowedIntents: {
          this.emit("error", {
            error: new Error("Used disallowed intents")
          });
          return this.destroy({ code });
        }
        default: {
          this.debug([
            `The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? "reconnect" : "resume"}.`
          ]);
          return this.destroy({
            code,
            recover: this.failedToConnectDueToNetworkError ? 0 : 1
          });
        }
      }
    }
    debug(messages) {
      const message = `${messages[0]}${messages.length > 1 ? `
${messages.slice(1).map((m) => `	${m}`).join("\n")}` : ""}`;
      this.emit("debug", { message });
    }
  };
  var SimpleShardingStrategy = class {
    static {
      __name(this, "SimpleShardingStrategy");
    }
    manager;
    shards = new import_collection6.Collection;
    constructor(manager) {
      this.manager = manager;
    }
    async spawn(shardIds) {
      const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
      for (const shardId of shardIds) {
        const strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);
        const shard = new WebSocketShard(strategy, shardId);
        for (const event of Object.values(WebSocketShardEvents)) {
          shard.on(event, (payload) => this.manager.emit(event, { ...payload, shardId }));
        }
        this.shards.set(shardId, shard);
      }
    }
    async connect() {
      const promises = [];
      for (const shard of this.shards.values()) {
        promises.push(shard.connect());
      }
      await Promise.all(promises);
    }
    async destroy(options) {
      const promises = [];
      for (const shard of this.shards.values()) {
        promises.push(shard.destroy(options));
      }
      await Promise.all(promises);
      this.shards.clear();
    }
    async send(shardId, payload) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} not found`);
      }
      return shard.send(payload);
    }
    async fetchStatus() {
      return this.shards.mapValues((shard) => shard.status);
    }
  };
  var import_node_worker_threads3 = __require("worker_threads");
  var import_collection7 = require_dist10();
  var WorkerBootstrapper = class {
    static {
      __name(this, "WorkerBootstrapper");
    }
    data = import_node_worker_threads3.workerData;
    shards = new import_collection7.Collection;
    constructor() {
      if (import_node_worker_threads3.isMainThread) {
        throw new Error("Expected WorkerBootstrap to not be used within the main thread");
      }
    }
    async connect(shardId) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} does not exist`);
      }
      await shard.connect();
    }
    async destroy(shardId, options) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} does not exist`);
      }
      await shard.destroy(options);
    }
    setupThreadEvents() {
      import_node_worker_threads3.parentPort.on("messageerror", (err) => {
        throw err;
      }).on("message", async (payload) => {
        switch (payload.op) {
          case 0: {
            await this.connect(payload.shardId);
            const response = {
              op: 0,
              shardId: payload.shardId
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
          case 1: {
            await this.destroy(payload.shardId, payload.options);
            const response = {
              op: 1,
              shardId: payload.shardId
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
          case 2: {
            const shard = this.shards.get(payload.shardId);
            if (!shard) {
              throw new RangeError(`Shard ${payload.shardId} does not exist`);
            }
            await shard.send(payload.payload);
            break;
          }
          case 3: {
            break;
          }
          case 4: {
            break;
          }
          case 5: {
            const shard = this.shards.get(payload.shardId);
            if (!shard) {
              throw new Error(`Shard ${payload.shardId} does not exist`);
            }
            const response = {
              op: 6,
              status: shard.status,
              nonce: payload.nonce
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
        }
      });
    }
    async bootstrap(options = {}) {
      for (const shardId of this.data.shardIds) {
        const shard = new WebSocketShard(new WorkerContextFetchingStrategy(this.data), shardId);
        for (const event of options.forwardEvents ?? Object.values(WebSocketShardEvents)) {
          shard.on(event, (data) => {
            const payload = {
              op: 2,
              event,
              data,
              shardId
            };
            import_node_worker_threads3.parentPort.postMessage(payload);
          });
        }
        await options.shardCallback?.(shard);
        this.shards.set(shardId, shard);
      }
      this.setupThreadEvents();
      const message = {
        op: 7
      };
      import_node_worker_threads3.parentPort.postMessage(message);
    }
  };
  var import_util3 = require_dist();
  var import_async_event_emitter2 = require_dist4();
  var import_v103 = require_v106();
  var WebSocketManager = class extends import_async_event_emitter2.AsyncEventEmitter {
    static {
      __name(this, "WebSocketManager");
    }
    options;
    gatewayInformation = null;
    shardIds = null;
    strategy;
    constructor(options) {
      super();
      this.options = { ...DefaultWebSocketManagerOptions, ...options };
      this.strategy = this.options.buildStrategy(this);
    }
    async fetchGatewayInformation(force = false) {
      if (this.gatewayInformation) {
        if (this.gatewayInformation.expiresAt <= Date.now()) {
          this.gatewayInformation = null;
        } else if (!force) {
          return this.gatewayInformation.data;
        }
      }
      const data = await this.options.rest.get(import_v103.Routes.gatewayBot());
      this.gatewayInformation = { data, expiresAt: Date.now() + (data.session_start_limit.reset_after || 5000) };
      return this.gatewayInformation.data;
    }
    async updateShardCount(shardCount) {
      await this.strategy.destroy({ reason: "User is adjusting their shards" });
      this.options.shardCount = shardCount;
      const shardIds = await this.getShardIds(true);
      await this.strategy.spawn(shardIds);
      return this;
    }
    async getShardCount() {
      if (this.options.shardCount) {
        return this.options.shardCount;
      }
      const shardIds = await this.getShardIds();
      return Math.max(...shardIds) + 1;
    }
    async getShardIds(force = false) {
      if (this.shardIds && !force) {
        return this.shardIds;
      }
      let shardIds;
      if (this.options.shardIds) {
        if (Array.isArray(this.options.shardIds)) {
          shardIds = this.options.shardIds;
        } else {
          const { start, end } = this.options.shardIds;
          shardIds = [...(0, import_util3.range)({ start, end: end + 1 })];
        }
      } else {
        const data = await this.fetchGatewayInformation();
        shardIds = [...(0, import_util3.range)(this.options.shardCount ?? data.shards)];
      }
      this.shardIds = shardIds;
      return shardIds;
    }
    async connect() {
      const shardCount = await this.getShardCount();
      await this.updateShardCount(shardCount);
      const shardIds = await this.getShardIds();
      const data = await this.fetchGatewayInformation();
      if (data.session_start_limit.remaining < shardIds.length) {
        throw new Error(`Not enough sessions remaining to spawn ${shardIds.length} shards; only ${data.session_start_limit.remaining} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`);
      }
      await this.strategy.connect();
    }
    destroy(options) {
      return this.strategy.destroy(options);
    }
    send(shardId, payload) {
      return this.strategy.send(shardId, payload);
    }
    fetchStatus() {
      return this.strategy.fetchStatus();
    }
  };
  var version = "1.0.2";
});

// node_modules/discord.js/src/util/WebSocketShardEvents.js
var require_WebSocketShardEvents = __commonJS((exports, module) => {
  module.exports = {
    Close: "close",
    Destroyed: "destroyed",
    InvalidSession: "invalidSession",
    Ready: "ready",
    Resumed: "resumed",
    AllReady: "allReady"
  };
});

// node_modules/discord.js/src/client/websocket/WebSocketShard.js
var require_WebSocketShard = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var process2 = __require("node:process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { GatewayIntentBits } = require_v106();
  var Status = require_Status();
  var WebSocketShardEvents = require_WebSocketShardEvents();
  var deprecationEmittedForImportant = false;

  class WebSocketShard extends EventEmitter {
    constructor(manager, id) {
      super();
      this.manager = manager;
      this.id = id;
      this.status = Status.Idle;
      this.closeSequence = 0;
      this.ping = -1;
      this.lastPingTimestamp = -1;
      Object.defineProperty(this, "expectedGuilds", { value: null, writable: true });
      Object.defineProperty(this, "readyTimeout", { value: null, writable: true });
      Object.defineProperty(this, "sessionInfo", { value: null, writable: true });
    }
    debug(message) {
      this.manager.debug(message, this.id);
    }
    emitClose(event = {
      code: 1011,
      reason: "INTERNAL_ERROR",
      wasClean: false
    }) {
      this.debug(`[CLOSE]
    Event Code: ${event.code}
    Clean     : ${event.wasClean}
    Reason    : ${event.reason ?? "No reason received"}`);
      this.emit(WebSocketShardEvents.Close, event);
    }
    onReadyPacket(packet) {
      if (!packet) {
        this.debug(`Received broken packet: '${packet}'.`);
        return;
      }
      this.emit(WebSocketShardEvents.Ready);
      this.expectedGuilds = new Set(packet.guilds.map((guild) => guild.id));
      this.status = Status.WaitingForGuilds;
    }
    gotGuild(guildId) {
      this.expectedGuilds.delete(guildId);
      this.checkReady();
    }
    checkReady() {
      if (this.readyTimeout) {
        clearTimeout2(this.readyTimeout);
        this.readyTimeout = null;
      }
      if (!this.expectedGuilds.size) {
        this.debug("Shard received all its guilds. Marking as fully ready.");
        this.status = Status.Ready;
        this.emit(WebSocketShardEvents.AllReady);
        return;
      }
      const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits.Guilds);
      const { waitGuildTimeout } = this.manager.client.options;
      this.readyTimeout = setTimeout2(() => {
        this.debug(`Shard ${hasGuildsIntent ? "did" : "will"} not receive any more guild packets` + `${hasGuildsIntent ? ` in ${waitGuildTimeout} ms` : ""}.\nUnavailable guild count: ${this.expectedGuilds.size}`);
        this.readyTimeout = null;
        this.status = Status.Ready;
        this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);
      }, hasGuildsIntent ? waitGuildTimeout : 0).unref();
    }
    send(data, important = false) {
      if (important && !deprecationEmittedForImportant) {
        process2.emitWarning("Sending important payloads explicitly is deprecated. They are determined by their opcode implicitly now.", "DeprecationWarning");
        deprecationEmittedForImportant = true;
      }
      this.manager._ws.send(this.id, data);
    }
  }
  module.exports = WebSocketShard;
});

// node_modules/discord.js/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js
var require_APPLICATION_COMMAND_PERMISSIONS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ApplicationCommandPermissionsUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_ACTION_EXECUTION.js
var require_AUTO_MODERATION_ACTION_EXECUTION = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationActionExecution.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_CREATE.js
var require_AUTO_MODERATION_RULE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_DELETE.js
var require_AUTO_MODERATION_RULE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_UPDATE.js
var require_AUTO_MODERATION_RULE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js
var require_CHANNEL_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ChannelCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js
var require_CHANNEL_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ChannelDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js
var require_CHANNEL_PINS_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const channel = client.channels.cache.get(data.channel_id);
    const time = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
    if (channel) {
      channel.lastPinTimestamp = time;
      client.emit(Events.ChannelPinsUpdate, channel, time);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js
var require_CHANNEL_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.ChannelUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_AUDIT_LOG_ENTRY_CREATE.js
var require_GUILD_AUDIT_LOG_ENTRY_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildAuditLogEntryCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js
var require_GUILD_BAN_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildBanAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js
var require_GUILD_BAN_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildBanRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js
var require_GUILD_CREATE = __commonJS((exports, module) => {
  var Events = require_Events();
  var Status = require_Status();
  module.exports = (client, { d: data }, shard) => {
    let guild = client.guilds.cache.get(data.id);
    if (guild) {
      if (!guild.available && !data.unavailable) {
        guild._patch(data);
        client.emit(Events.GuildAvailable, guild);
      }
    } else {
      data.shardId = shard.id;
      guild = client.guilds._add(data);
      if (client.ws.status === Status.Ready) {
        client.emit(Events.GuildCreate, guild);
      }
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js
var require_GUILD_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js
var require_GUILD_EMOJIS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildEmojisUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js
var require_GUILD_INTEGRATIONS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildIntegrationsUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js
var require_GUILD_MEMBERS_CHUNK = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const members = new Collection;
    for (const member of data.members)
      members.set(member.user.id, guild.members._add(member));
    if (data.presences) {
      for (const presence of data.presences)
        guild.presences._add(Object.assign(presence, { guild }));
    }
    client.emit(Events.GuildMembersChunk, members, guild, {
      index: data.chunk_index,
      count: data.chunk_count,
      notFound: data.not_found,
      nonce: data.nonce
    });
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js
var require_GUILD_MEMBER_ADD = __commonJS((exports, module) => {
  var Events = require_Events();
  var Status = require_Status();
  module.exports = (client, { d: data }, shard) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (guild) {
      guild.memberCount++;
      const member = guild.members._add(data);
      if (shard.status === Status.Ready) {
        client.emit(Events.GuildMemberAdd, member);
      }
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js
var require_GUILD_MEMBER_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet, shard) => {
    client.actions.GuildMemberRemove.handle(packet.d, shard);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js
var require_GUILD_MEMBER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet, shard) => {
    client.actions.GuildMemberUpdate.handle(packet.d, shard);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js
var require_GUILD_ROLE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js
var require_GUILD_ROLE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js
var require_GUILD_ROLE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js
var require_GUILD_SCHEDULED_EVENT_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js
var require_GUILD_SCHEDULED_EVENT_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js
var require_GUILD_SCHEDULED_EVENT_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js
var require_GUILD_SCHEDULED_EVENT_USER_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUserAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js
var require_GUILD_SCHEDULED_EVENT_USER_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUserRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js
var require_GUILD_STICKERS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildStickersUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js
var require_GUILD_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INTERACTION_CREATE.js
var require_INTERACTION_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InteractionCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js
var require_INVITE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InviteCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js
var require_INVITE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InviteDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js
var require_MESSAGE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js
var require_MESSAGE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js
var require_MESSAGE_DELETE_BULK = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageDeleteBulk.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js
var require_MESSAGE_REACTION_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js
var require_MESSAGE_REACTION_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js
var require_MESSAGE_REACTION_REMOVE_ALL = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemoveAll.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js
var require_MESSAGE_REACTION_REMOVE_EMOJI = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemoveEmoji.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js
var require_MESSAGE_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.MessageUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.MessageUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js
var require_PRESENCE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.PresenceUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/structures/ClientUser.js
var require_ClientUser = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var User = require_User();
  var DataResolver = require_DataResolver();

  class ClientUser extends User {
    _patch(data) {
      super._patch(data);
      if ("verified" in data) {
        this.verified = data.verified;
      }
      if ("mfa_enabled" in data) {
        this.mfaEnabled = typeof data.mfa_enabled === "boolean" ? data.mfa_enabled : null;
      } else {
        this.mfaEnabled ??= null;
      }
      if ("token" in data)
        this.client.token = data.token;
    }
    get presence() {
      return this.client.presence;
    }
    async edit({ username, avatar }) {
      const data = await this.client.rest.patch(Routes.user(), {
        body: { username, avatar: avatar && await DataResolver.resolveImage(avatar) }
      });
      this.client.token = data.token;
      this.client.rest.setToken(data.token);
      const { updated } = this.client.actions.UserUpdate.handle(data);
      return updated ?? this;
    }
    setUsername(username) {
      return this.edit({ username });
    }
    setAvatar(avatar) {
      return this.edit({ avatar });
    }
    setPresence(data) {
      return this.client.presence.set(data);
    }
    setStatus(status, shardId) {
      return this.setPresence({ status, shardId });
    }
    setActivity(name, options = {}) {
      if (!name)
        return this.setPresence({ activities: [], shardId: options.shardId });
      const activity = Object.assign({}, options, typeof name === "object" ? name : { name });
      return this.setPresence({ activities: [activity], shardId: activity.shardId });
    }
    setAFK(afk = true, shardId) {
      return this.setPresence({ afk, shardId });
    }
  }
  module.exports = ClientUser;
});

// node_modules/discord.js/src/client/websocket/handlers/READY.js
var require_READY = __commonJS((exports, module) => {
  var ClientApplication = require_ClientApplication();
  var ClientUser;
  module.exports = (client, { d: data }, shard) => {
    if (client.user) {
      client.user._patch(data.user);
    } else {
      ClientUser ??= require_ClientUser();
      client.user = new ClientUser(client, data.user);
      client.users.cache.set(client.user.id, client.user);
    }
    for (const guild of data.guilds) {
      guild.shardId = shard.id;
      client.guilds._add(guild);
    }
    if (client.application) {
      client.application._patch(data.application);
    } else {
      client.application = new ClientApplication(client, data.application);
    }
    shard.checkReady();
  };
});

// node_modules/discord.js/src/client/websocket/handlers/RESUMED.js
var require_RESUMED = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet, shard) => {
    const replayed = shard.sessionInfo.sequence - shard.closeSequence;
    client.emit(Events.ShardResume, shard.id, replayed);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js
var require_STAGE_INSTANCE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js
var require_STAGE_INSTANCE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js
var require_STAGE_INSTANCE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_CREATE.js
var require_THREAD_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_DELETE.js
var require_THREAD_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_LIST_SYNC.js
var require_THREAD_LIST_SYNC = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadListSync.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js
var require_THREAD_MEMBERS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadMembersUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js
var require_THREAD_MEMBER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadMemberUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_UPDATE.js
var require_THREAD_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.ThreadUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js
var require_TYPING_START = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.TypingStart.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js
var require_USER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.UserUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js
var require_VOICE_SERVER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.emit("debug", `[VOICE] received voice server: ${JSON.stringify(packet)}`);
    client.voice.onVoiceServer(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js
var require_VOICE_STATE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.VoiceStateUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js
var require_WEBHOOKS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.WebhooksUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/index.js
var require_handlers = __commonJS((exports, module) => {
  var handlers = Object.fromEntries([
    ["APPLICATION_COMMAND_PERMISSIONS_UPDATE", require_APPLICATION_COMMAND_PERMISSIONS_UPDATE()],
    ["AUTO_MODERATION_ACTION_EXECUTION", require_AUTO_MODERATION_ACTION_EXECUTION()],
    ["AUTO_MODERATION_RULE_CREATE", require_AUTO_MODERATION_RULE_CREATE()],
    ["AUTO_MODERATION_RULE_DELETE", require_AUTO_MODERATION_RULE_DELETE()],
    ["AUTO_MODERATION_RULE_UPDATE", require_AUTO_MODERATION_RULE_UPDATE()],
    ["CHANNEL_CREATE", require_CHANNEL_CREATE()],
    ["CHANNEL_DELETE", require_CHANNEL_DELETE()],
    ["CHANNEL_PINS_UPDATE", require_CHANNEL_PINS_UPDATE()],
    ["CHANNEL_UPDATE", require_CHANNEL_UPDATE()],
    ["GUILD_AUDIT_LOG_ENTRY_CREATE", require_GUILD_AUDIT_LOG_ENTRY_CREATE()],
    ["GUILD_BAN_ADD", require_GUILD_BAN_ADD()],
    ["GUILD_BAN_REMOVE", require_GUILD_BAN_REMOVE()],
    ["GUILD_CREATE", require_GUILD_CREATE()],
    ["GUILD_DELETE", require_GUILD_DELETE()],
    ["GUILD_EMOJIS_UPDATE", require_GUILD_EMOJIS_UPDATE()],
    ["GUILD_INTEGRATIONS_UPDATE", require_GUILD_INTEGRATIONS_UPDATE()],
    ["GUILD_MEMBERS_CHUNK", require_GUILD_MEMBERS_CHUNK()],
    ["GUILD_MEMBER_ADD", require_GUILD_MEMBER_ADD()],
    ["GUILD_MEMBER_REMOVE", require_GUILD_MEMBER_REMOVE()],
    ["GUILD_MEMBER_UPDATE", require_GUILD_MEMBER_UPDATE()],
    ["GUILD_ROLE_CREATE", require_GUILD_ROLE_CREATE()],
    ["GUILD_ROLE_DELETE", require_GUILD_ROLE_DELETE()],
    ["GUILD_ROLE_UPDATE", require_GUILD_ROLE_UPDATE()],
    ["GUILD_SCHEDULED_EVENT_CREATE", require_GUILD_SCHEDULED_EVENT_CREATE()],
    ["GUILD_SCHEDULED_EVENT_DELETE", require_GUILD_SCHEDULED_EVENT_DELETE()],
    ["GUILD_SCHEDULED_EVENT_UPDATE", require_GUILD_SCHEDULED_EVENT_UPDATE()],
    ["GUILD_SCHEDULED_EVENT_USER_ADD", require_GUILD_SCHEDULED_EVENT_USER_ADD()],
    ["GUILD_SCHEDULED_EVENT_USER_REMOVE", require_GUILD_SCHEDULED_EVENT_USER_REMOVE()],
    ["GUILD_STICKERS_UPDATE", require_GUILD_STICKERS_UPDATE()],
    ["GUILD_UPDATE", require_GUILD_UPDATE()],
    ["INTERACTION_CREATE", require_INTERACTION_CREATE()],
    ["INVITE_CREATE", require_INVITE_CREATE()],
    ["INVITE_DELETE", require_INVITE_DELETE()],
    ["MESSAGE_CREATE", require_MESSAGE_CREATE()],
    ["MESSAGE_DELETE", require_MESSAGE_DELETE()],
    ["MESSAGE_DELETE_BULK", require_MESSAGE_DELETE_BULK()],
    ["MESSAGE_REACTION_ADD", require_MESSAGE_REACTION_ADD()],
    ["MESSAGE_REACTION_REMOVE", require_MESSAGE_REACTION_REMOVE()],
    ["MESSAGE_REACTION_REMOVE_ALL", require_MESSAGE_REACTION_REMOVE_ALL()],
    ["MESSAGE_REACTION_REMOVE_EMOJI", require_MESSAGE_REACTION_REMOVE_EMOJI()],
    ["MESSAGE_UPDATE", require_MESSAGE_UPDATE()],
    ["PRESENCE_UPDATE", require_PRESENCE_UPDATE()],
    ["READY", require_READY()],
    ["RESUMED", require_RESUMED()],
    ["STAGE_INSTANCE_CREATE", require_STAGE_INSTANCE_CREATE()],
    ["STAGE_INSTANCE_DELETE", require_STAGE_INSTANCE_DELETE()],
    ["STAGE_INSTANCE_UPDATE", require_STAGE_INSTANCE_UPDATE()],
    ["THREAD_CREATE", require_THREAD_CREATE()],
    ["THREAD_DELETE", require_THREAD_DELETE()],
    ["THREAD_LIST_SYNC", require_THREAD_LIST_SYNC()],
    ["THREAD_MEMBERS_UPDATE", require_THREAD_MEMBERS_UPDATE()],
    ["THREAD_MEMBER_UPDATE", require_THREAD_MEMBER_UPDATE()],
    ["THREAD_UPDATE", require_THREAD_UPDATE()],
    ["TYPING_START", require_TYPING_START()],
    ["USER_UPDATE", require_USER_UPDATE()],
    ["VOICE_SERVER_UPDATE", require_VOICE_SERVER_UPDATE()],
    ["VOICE_STATE_UPDATE", require_VOICE_STATE_UPDATE()],
    ["WEBHOOKS_UPDATE", require_WEBHOOKS_UPDATE()]
  ]);
  module.exports = handlers;
});

// node_modules/discord.js/src/client/websocket/WebSocketManager.js
var require_WebSocketManager = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var process2 = __require("node:process");
  var { setImmediate: setImmediate2 } = __require("node:timers");
  var { Collection } = require_dist7();
  var {
    WebSocketManager: WSWebSocketManager,
    WebSocketShardEvents: WSWebSocketShardEvents,
    CompressionMethod,
    CloseCodes
  } = require_dist11();
  var { GatewayCloseCodes, GatewayDispatchEvents } = require_v106();
  var WebSocketShard = require_WebSocketShard();
  var PacketHandlers = require_handlers();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var Events = require_Events();
  var Status = require_Status();
  var WebSocketShardEvents = require_WebSocketShardEvents();
  var zlib;
  try {
    zlib = (()=>{throw new Error(`Cannot require module "zlib-sync"`);})();
  } catch {
  }
  var BeforeReadyWhitelist = [
    GatewayDispatchEvents.Ready,
    GatewayDispatchEvents.Resumed,
    GatewayDispatchEvents.GuildCreate,
    GatewayDispatchEvents.GuildDelete,
    GatewayDispatchEvents.GuildMembersChunk,
    GatewayDispatchEvents.GuildMemberAdd,
    GatewayDispatchEvents.GuildMemberRemove
  ];
  var WaitingForGuildEvents = [GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete];
  var UNRESUMABLE_CLOSE_CODES = [
    CloseCodes.Normal,
    GatewayCloseCodes.AlreadyAuthenticated,
    GatewayCloseCodes.InvalidSeq
  ];
  var reasonIsDeprecated = "the reason property is deprecated, use the code property to determine the reason";
  var deprecationEmittedForInvalidSessionEvent = false;
  var deprecationEmittedForDestroyedEvent = false;

  class WebSocketManager extends EventEmitter {
    constructor(client) {
      super();
      Object.defineProperty(this, "client", { value: client });
      this.gateway = null;
      this.shards = new Collection;
      Object.defineProperty(this, "packetQueue", { value: [] });
      this.status = Status.Idle;
      this.destroyed = false;
      this._ws = null;
    }
    get ping() {
      const sum = this.shards.reduce((a, b) => a + b.ping, 0);
      return sum / this.shards.size;
    }
    debug(message, shardId) {
      this.client.emit(Events.Debug, `[WS => ${typeof shardId === "number" ? `Shard ${shardId}` : "Manager"}] ${message}`);
    }
    async connect() {
      const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);
      const { shards, shardCount, intents, ws } = this.client.options;
      if (this._ws && this._ws.options.token !== this.client.token) {
        await this._ws.destroy({ code: CloseCodes.Normal, reason: "Login with differing token requested" });
        this._ws = null;
      }
      if (!this._ws) {
        const wsOptions = {
          intents: intents.bitfield,
          rest: this.client.rest,
          token: this.client.token,
          largeThreshold: ws.large_threshold,
          version: ws.version,
          shardIds: shards === "auto" ? null : shards,
          shardCount: shards === "auto" ? null : shardCount,
          initialPresence: ws.presence,
          retrieveSessionInfo: (shardId) => this.shards.get(shardId).sessionInfo,
          updateSessionInfo: (shardId, sessionInfo) => {
            this.shards.get(shardId).sessionInfo = sessionInfo;
          },
          compression: zlib ? CompressionMethod.ZlibStream : null
        };
        if (ws.buildIdentifyThrottler)
          wsOptions.buildIdentifyThrottler = ws.buildIdentifyThrottler;
        if (ws.buildStrategy)
          wsOptions.buildStrategy = ws.buildStrategy;
        this._ws = new WSWebSocketManager(wsOptions);
        this.attachEvents();
      }
      const {
        url: gatewayURL,
        shards: recommendedShards,
        session_start_limit: sessionStartLimit
      } = await this._ws.fetchGatewayInformation().catch((error) => {
        throw error.status === 401 ? invalidToken : error;
      });
      const { total, remaining } = sessionStartLimit;
      this.debug(`Fetched Gateway Information
    URL: ${gatewayURL}
    Recommended Shards: ${recommendedShards}`);
      this.debug(`Session Limit Information
    Total: ${total}
    Remaining: ${remaining}`);
      this.gateway = `${gatewayURL}/`;
      this.client.options.shardCount = await this._ws.getShardCount();
      this.client.options.shards = await this._ws.getShardIds();
      this.totalShards = this.client.options.shards.length;
      for (const id of this.client.options.shards) {
        if (!this.shards.has(id)) {
          const shard = new WebSocketShard(this, id);
          this.shards.set(id, shard);
          shard.on(WebSocketShardEvents.AllReady, (unavailableGuilds) => {
            this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);
            this.checkShardsReady();
          });
          shard.status = Status.Connecting;
        }
      }
      await this._ws.connect();
      this.shards.forEach((shard) => {
        if (shard.listenerCount(WebSocketShardEvents.InvalidSession) > 0 && !deprecationEmittedForInvalidSessionEvent) {
          process2.emitWarning("The WebSocketShard#invalidSession event is deprecated and will never emit.", "DeprecationWarning");
          deprecationEmittedForInvalidSessionEvent = true;
        }
        if (shard.listenerCount(WebSocketShardEvents.Destroyed) > 0 && !deprecationEmittedForDestroyedEvent) {
          process2.emitWarning("The WebSocketShard#destroyed event is deprecated and will never emit.", "DeprecationWarning");
          deprecationEmittedForDestroyedEvent = true;
        }
      });
    }
    attachEvents() {
      this._ws.on(WSWebSocketShardEvents.Debug, ({ message, shardId }) => this.debug(message, shardId));
      this._ws.on(WSWebSocketShardEvents.Dispatch, ({ data, shardId }) => {
        this.client.emit(Events.Raw, data, shardId);
        this.emit(data.t, data.d, shardId);
        const shard = this.shards.get(shardId);
        this.handlePacket(data, shard);
        if (shard.status === Status.WaitingForGuilds && WaitingForGuildEvents.includes(data.t)) {
          shard.gotGuild(data.d.id);
        }
      });
      this._ws.on(WSWebSocketShardEvents.Ready, ({ data, shardId }) => {
        this.shards.get(shardId).onReadyPacket(data);
      });
      this._ws.on(WSWebSocketShardEvents.Closed, ({ code, shardId }) => {
        const shard = this.shards.get(shardId);
        shard.emit(WebSocketShardEvents.Close, { code, reason: reasonIsDeprecated, wasClean: true });
        if (UNRESUMABLE_CLOSE_CODES.includes(code) && this.destroyed) {
          shard.status = Status.Disconnected;
          this.client.emit(Events.ShardDisconnect, { code, reason: reasonIsDeprecated, wasClean: true }, shardId);
          this.debug(`Shard not resumable: ${code} (${GatewayCloseCodes[code] ?? CloseCodes[code]})`, shardId);
          return;
        }
        this.shards.get(shardId).status = Status.Connecting;
        this.client.emit(Events.ShardReconnecting, shardId);
      });
      this._ws.on(WSWebSocketShardEvents.Hello, ({ shardId }) => {
        const shard = this.shards.get(shardId);
        if (shard.sessionInfo) {
          shard.closeSequence = shard.sessionInfo.sequence;
          shard.status = Status.Resuming;
        } else {
          shard.status = Status.Identifying;
        }
      });
      this._ws.on(WSWebSocketShardEvents.Resumed, ({ shardId }) => {
        const shard = this.shards.get(shardId);
        shard.status = Status.Ready;
        shard.emit(WebSocketShardEvents.Resumed);
      });
      this._ws.on(WSWebSocketShardEvents.HeartbeatComplete, ({ heartbeatAt, latency, shardId }) => {
        this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`, shardId);
        const shard = this.shards.get(shardId);
        shard.lastPingTimestamp = heartbeatAt;
        shard.ping = latency;
      });
      this._ws.on(WSWebSocketShardEvents.Error, ({ error, shardId }) => {
        this.client.emit(Events.ShardError, error, shardId);
      });
    }
    broadcast(packet) {
      for (const shardId of this.shards.keys())
        this._ws.send(shardId, packet);
    }
    async destroy() {
      if (this.destroyed)
        return;
      this.debug(Object.assign(new Error, { name: "Manager was destroyed:" }).stack);
      this.destroyed = true;
      await this._ws?.destroy({ code: CloseCodes.Normal, reason: "Manager was destroyed" });
    }
    handlePacket(packet, shard) {
      if (packet && this.status !== Status.Ready) {
        if (!BeforeReadyWhitelist.includes(packet.t)) {
          this.packetQueue.push({ packet, shard });
          return false;
        }
      }
      if (this.packetQueue.length) {
        const item = this.packetQueue.shift();
        setImmediate2(() => {
          this.handlePacket(item.packet, item.shard);
        }).unref();
      }
      if (packet && PacketHandlers[packet.t]) {
        PacketHandlers[packet.t](this.client, packet, shard);
      }
      return true;
    }
    checkShardsReady() {
      if (this.status === Status.Ready)
        return;
      if (this.shards.size !== this.totalShards || this.shards.some((shard) => shard.status !== Status.Ready)) {
        return;
      }
      this.triggerClientReady();
    }
    triggerClientReady() {
      this.status = Status.Ready;
      this.client.readyTimestamp = Date.now();
      this.client.emit(Events.ClientReady, this.client);
      this.handlePacket();
    }
  }
  module.exports = WebSocketManager;
});

// node_modules/discord.js/src/managers/BaseGuildEmojiManager.js
var require_BaseGuildEmojiManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var { parseEmoji } = require_Util();

  class BaseGuildEmojiManager extends CachedManager {
    constructor(client, iterable) {
      super(client, GuildEmoji, iterable);
    }
    resolve(emoji) {
      if (emoji instanceof ReactionEmoji)
        return super.resolve(emoji.id);
      return super.resolve(emoji);
    }
    resolveId(emoji) {
      if (emoji instanceof ReactionEmoji)
        return emoji.id;
      return super.resolveId(emoji);
    }
    resolveIdentifier(emoji) {
      const emojiResolvable = this.resolve(emoji);
      if (emojiResolvable)
        return emojiResolvable.identifier;
      if (emoji instanceof ReactionEmoji)
        return emoji.identifier;
      if (typeof emoji === "string") {
        const res = parseEmoji(emoji);
        if (res?.name.length) {
          emoji = `${res.animated ? "a:" : ""}${res.name}${res.id ? `:${res.id}` : ""}`;
        }
        if (!emoji.includes("%"))
          return encodeURIComponent(emoji);
        return emoji;
      }
      return null;
    }
  }
  module.exports = BaseGuildEmojiManager;
});

// node_modules/discord.js/src/managers/ChannelManager.js
var require_ChannelManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { BaseChannel } = require_BaseChannel();
  var { createChannel } = require_Channels();
  var { ThreadChannelTypes } = require_Constants();
  var Events = require_Events();
  var cacheWarningEmitted = false;

  class ChannelManager extends CachedManager {
    constructor(client, iterable) {
      super(client, BaseChannel, iterable);
      const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;
      if (!cacheWarningEmitted && !defaultCaching) {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
    }
    _add(data, guild, { cache = true, allowUnknownGuild = false } = {}) {
      const existing = this.cache.get(data.id);
      if (existing) {
        if (cache)
          existing._patch(data);
        guild?.channels?._add(existing);
        if (ThreadChannelTypes.includes(existing.type)) {
          existing.parent?.threads?._add(existing);
        }
        return existing;
      }
      const channel = createChannel(this.client, data, guild, { allowUnknownGuild });
      if (!channel) {
        this.client.emit(Events.Debug, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);
        return null;
      }
      if (cache && !allowUnknownGuild)
        this.cache.set(channel.id, channel);
      return channel;
    }
    _remove(id) {
      const channel = this.cache.get(id);
      channel?.guild?.channels.cache.delete(id);
      for (const [code, invite] of channel?.guild?.invites.cache ?? []) {
        if (invite.channelId === id)
          channel.guild.invites.cache.delete(code);
      }
      channel?.parent?.threads?.cache.delete(id);
      this.cache.delete(id);
    }
    async fetch(id, { allowUnknownGuild = false, cache = true, force = false } = {}) {
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.channel(id));
      return this._add(data, null, { cache, allowUnknownGuild });
    }
  }
  module.exports = ChannelManager;
});

// node_modules/discord.js/src/sharding/ShardClientUtil.js
var require_ShardClientUtil = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { calculateShardId } = require_dist();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var Events = require_Events();
  var { makeError, makePlainError } = require_Util();

  class ShardClientUtil {
    constructor(client, mode) {
      this.client = client;
      this.mode = mode;
      this.parentPort = null;
      switch (mode) {
        case "process":
          process2.on("message", this._handleMessage.bind(this));
          client.on(Events.ShardReady, () => {
            process2.send({ _ready: true });
          });
          client.on(Events.ShardDisconnect, () => {
            process2.send({ _disconnect: true });
          });
          client.on(Events.ShardReconnecting, () => {
            process2.send({ _reconnecting: true });
          });
          client.on(Events.ShardResume, () => {
            process2.send({ _resume: true });
          });
          break;
        case "worker":
          this.parentPort = __require("node:worker_threads").parentPort;
          this.parentPort.on("message", this._handleMessage.bind(this));
          client.on(Events.ShardReady, () => {
            this.parentPort.postMessage({ _ready: true });
          });
          client.on(Events.ShardDisconnect, () => {
            this.parentPort.postMessage({ _disconnect: true });
          });
          client.on(Events.ShardReconnecting, () => {
            this.parentPort.postMessage({ _reconnecting: true });
          });
          client.on(Events.ShardResume, () => {
            this.parentPort.postMessage({ _resume: true });
          });
          break;
      }
    }
    get ids() {
      return this.client.options.shards;
    }
    get count() {
      return this.client.options.shardCount;
    }
    send(message) {
      return new Promise((resolve, reject) => {
        switch (this.mode) {
          case "process":
            process2.send(message, (err) => {
              if (err)
                reject(err);
              else
                resolve();
            });
            break;
          case "worker":
            this.parentPort.postMessage(message);
            resolve();
            break;
        }
      });
    }
    fetchClientValues(prop, shard) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort ?? process2;
        const listener = (message) => {
          if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard)
            return;
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(parent);
        parent.on("message", listener);
        this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch((err) => {
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          reject(err);
        });
      });
    }
    broadcastEval(script2, options = {}) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort ?? process2;
        if (typeof script2 !== "function") {
          reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));
          return;
        }
        script2 = `(${script2})(this, ${JSON.stringify(options.context)})`;
        const listener = (message) => {
          if (message?._sEval !== script2 || message._sEvalShard !== options.shard)
            return;
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(parent);
        parent.on("message", listener);
        this.send({ _sEval: script2, _sEvalShard: options.shard }).catch((err) => {
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          reject(err);
        });
      });
    }
    respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {
      return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });
    }
    async _handleMessage(message) {
      if (!message)
        return;
      if (message._fetchProp) {
        try {
          const props = message._fetchProp.split(".");
          let value = this.client;
          for (const prop of props)
            value = value[prop];
          this._respond("fetchProp", { _fetchProp: message._fetchProp, _result: value });
        } catch (err) {
          this._respond("fetchProp", { _fetchProp: message._fetchProp, _error: makePlainError(err) });
        }
      } else if (message._eval) {
        try {
          this._respond("eval", { _eval: message._eval, _result: await this.client._eval(message._eval) });
        } catch (err) {
          this._respond("eval", { _eval: message._eval, _error: makePlainError(err) });
        }
      }
    }
    _respond(type, message) {
      this.send(message).catch((err) => {
        const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);
        error.stack = err.stack;
        this.client.emit(Events.Error, error);
      });
    }
    static singleton(client, mode) {
      if (!this._singleton) {
        this._singleton = new this(client, mode);
      } else {
        client.emit(Events.Warn, "Multiple clients created in child process/worker; only the first will handle sharding helpers.");
      }
      return this._singleton;
    }
    static shardIdForGuildId(guildId, shardCount) {
      const shard = calculateShardId(guildId, shardCount);
      if (shard < 0)
        throw new DiscordjsError(ErrorCodes.ShardingShardMiscalculation, shard, guildId, shardCount);
      return shard;
    }
    incrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners - 1);
      }
    }
  }
  module.exports = ShardClientUtil;
});

// node_modules/discord.js/src/structures/GuildAuditLogs.js
var require_GuildAuditLogs = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var ApplicationCommand = require_ApplicationCommand();
  var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  var Integration = require_Integration();
  var Webhook = require_Webhook();
  var { flatten } = require_Util();

  class GuildAuditLogs {
    constructor(guild, data) {
      if (data.users)
        for (const user of data.users)
          guild.client.users._add(user);
      if (data.threads)
        for (const thread of data.threads)
          guild.client.channels._add(thread, guild);
      this.webhooks = new Collection;
      if (data.webhooks) {
        for (const hook of data.webhooks) {
          this.webhooks.set(hook.id, new Webhook(guild.client, hook));
        }
      }
      this.integrations = new Collection;
      if (data.integrations) {
        for (const integration of data.integrations) {
          this.integrations.set(integration.id, new Integration(guild.client, integration, guild));
        }
      }
      this.guildScheduledEvents = data.guild_scheduled_events.reduce((guildScheduledEvents, guildScheduledEvent) => guildScheduledEvents.set(guildScheduledEvent.id, guild.scheduledEvents._add(guildScheduledEvent)), new Collection);
      this.applicationCommands = new Collection;
      if (data.application_commands) {
        for (const command of data.application_commands) {
          this.applicationCommands.set(command.id, new ApplicationCommand(guild.client, command, guild));
        }
      }
      this.autoModerationRules = data.auto_moderation_rules.reduce((autoModerationRules, autoModerationRule) => autoModerationRules.set(autoModerationRule.id, guild.autoModerationRules._add(autoModerationRule)), new Collection);
      this.entries = new Collection;
      for (const item of data.audit_log_entries) {
        const entry = new GuildAuditLogsEntry(guild, item, this);
        this.entries.set(entry.id, entry);
      }
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = GuildAuditLogs;
});

// node_modules/discord.js/src/structures/GuildOnboardingPromptOption.js
var require_GuildOnboardingPromptOption = __commonJS((exports) => {
  var { Collection } = require_dist7();
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class GuildOnboardingPromptOption extends Base {
    constructor(client, data, guildId) {
      super(client);
      this.guildId = guildId;
      const guild = this.guild;
      this.id = data.id;
      this.channels = data.channel_ids.reduce((channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)), new Collection);
      this.roles = data.role_ids.reduce((roles, roleId) => roles.set(roleId, guild.roles.cache.get(roleId)), new Collection);
      this._emoji = data.emoji;
      this.title = data.title;
      this.description = data.description;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
    get emoji() {
      if (!this._emoji.id && !this._emoji.name)
        return null;
      return this.client.emojis.resolve(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
  }
  exports.GuildOnboardingPromptOption = GuildOnboardingPromptOption;
});

// node_modules/discord.js/src/structures/GuildOnboardingPrompt.js
var require_GuildOnboardingPrompt = __commonJS((exports) => {
  var { Collection } = require_dist7();
  var Base = require_Base();
  var { GuildOnboardingPromptOption } = require_GuildOnboardingPromptOption();

  class GuildOnboardingPrompt extends Base {
    constructor(client, data, guildId) {
      super(client);
      this.guildId = guildId;
      this.id = data.id;
      this.options = data.options.reduce((options, option) => options.set(option.id, new GuildOnboardingPromptOption(client, option, guildId)), new Collection);
      this.title = data.title;
      this.singleSelect = data.single_select;
      this.required = data.required;
      this.inOnboarding = data.in_onboarding;
      this.type = data.type;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
  }
  exports.GuildOnboardingPrompt = GuildOnboardingPrompt;
});

// node_modules/discord.js/src/structures/GuildOnboarding.js
var require_GuildOnboarding = __commonJS((exports) => {
  var { Collection } = require_dist7();
  var Base = require_Base();
  var { GuildOnboardingPrompt } = require_GuildOnboardingPrompt();

  class GuildOnboarding extends Base {
    constructor(client, data) {
      super(client);
      this.guildId = data.guild_id;
      const guild = this.guild;
      this.prompts = data.prompts.reduce((prompts, prompt) => prompts.set(prompt.id, new GuildOnboardingPrompt(client, prompt, this.guildId)), new Collection);
      this.defaultChannels = data.default_channel_ids.reduce((channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)), new Collection);
      this.enabled = data.enabled;
      this.mode = data.mode;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
  }
  exports.GuildOnboarding = GuildOnboarding;
});

// node_modules/discord.js/src/structures/GuildPreviewEmoji.js
var require_GuildPreviewEmoji = __commonJS((exports, module) => {
  var BaseGuildEmoji = require_BaseGuildEmoji();

  class GuildPreviewEmoji extends BaseGuildEmoji {
    constructor(client, data, guild) {
      super(client, data, guild);
      this.roles = data.roles;
    }
  }
  module.exports = GuildPreviewEmoji;
});

// node_modules/discord.js/src/structures/GuildPreview.js
var require_GuildPreview = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { DiscordSnowflake } = require_dist3();
  var { Routes } = require_v106();
  var Base = require_Base();
  var GuildPreviewEmoji = require_GuildPreviewEmoji();
  var { Sticker } = require_Sticker();

  class GuildPreview extends Base {
    constructor(client, data) {
      super(client);
      if (!data)
        return;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      }
      if ("splash" in data) {
        this.splash = data.splash;
      }
      if ("discovery_splash" in data) {
        this.discoverySplash = data.discovery_splash;
      }
      if ("features" in data) {
        this.features = data.features;
      }
      if ("approximate_member_count" in data) {
        this.approximateMemberCount = data.approximate_member_count;
      }
      if ("approximate_presence_count" in data) {
        this.approximatePresenceCount = data.approximate_presence_count;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if (!this.emojis) {
        this.emojis = new Collection;
      } else {
        this.emojis.clear();
      }
      for (const emoji of data.emojis) {
        this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));
      }
      this.stickers = data.stickers.reduce((stickers, sticker) => stickers.set(sticker.id, new Sticker(this.client, sticker)), new Collection);
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    splashURL(options = {}) {
      return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
    }
    discoverySplashURL(options = {}) {
      return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guildPreview(this.id));
      this._patch(data);
      return this;
    }
    toString() {
      return this.name;
    }
    toJSON() {
      const json = super.toJSON();
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      return json;
    }
  }
  module.exports = GuildPreview;
});

// node_modules/discord.js/src/managers/AutoModerationRuleManager.js
var require_AutoModerationRuleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var AutoModerationRule = require_AutoModerationRule();

  class AutoModerationRuleManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, AutoModerationRule, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({
      name,
      eventType,
      triggerType,
      triggerMetadata,
      actions,
      enabled,
      exemptRoles,
      exemptChannels,
      reason
    }) {
      const data = await this.client.rest.post(Routes.guildAutoModerationRules(this.guild.id), {
        body: {
          name,
          event_type: eventType,
          trigger_type: triggerType,
          trigger_metadata: triggerMetadata && {
            keyword_filter: triggerMetadata.keywordFilter,
            regex_patterns: triggerMetadata.regexPatterns,
            presets: triggerMetadata.presets,
            allow_list: triggerMetadata.allowList,
            mention_total_limit: triggerMetadata.mentionTotalLimit,
            mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
          },
          actions: actions.map((action) => ({
            type: action.type,
            metadata: {
              duration_seconds: action.metadata?.durationSeconds,
              channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
              custom_message: action.metadata?.customMessage
            }
          })),
          enabled,
          exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
          exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
        },
        reason
      });
      return this._add(data);
    }
    async edit(autoModerationRule, { name, eventType, triggerMetadata, actions, enabled, exemptRoles, exemptChannels, reason }) {
      const autoModerationRuleId = this.resolveId(autoModerationRule);
      const data = await this.client.rest.patch(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), {
        body: {
          name,
          event_type: eventType,
          trigger_metadata: triggerMetadata && {
            keyword_filter: triggerMetadata.keywordFilter,
            regex_patterns: triggerMetadata.regexPatterns,
            presets: triggerMetadata.presets,
            allow_list: triggerMetadata.allowList,
            mention_total_limit: triggerMetadata.mentionTotalLimit,
            mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
          },
          actions: actions?.map((action) => ({
            type: action.type,
            metadata: {
              duration_seconds: action.metadata?.durationSeconds,
              channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
              custom_message: action.metadata?.customMessage
            }
          })),
          enabled,
          exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
          exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
        },
        reason
      });
      return this._add(data);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { autoModerationRule, cache, force } = options;
      const resolvedAutoModerationRule = this.resolveId(autoModerationRule ?? options);
      if (resolvedAutoModerationRule) {
        return this._fetchSingle({ autoModerationRule: resolvedAutoModerationRule, cache, force });
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ autoModerationRule, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(autoModerationRule);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildAutoModerationRule(this.guild.id, autoModerationRule));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.guildAutoModerationRules(this.guild.id));
      return data.reduce((col, autoModerationRule) => col.set(autoModerationRule.id, this._add(autoModerationRule, options.cache)), new Collection);
    }
    async delete(autoModerationRule, reason) {
      const autoModerationRuleId = this.resolveId(autoModerationRule);
      await this.client.rest.delete(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), { reason });
    }
  }
  module.exports = AutoModerationRuleManager;
});

// node_modules/discord.js/src/managers/GuildApplicationCommandManager.js
var require_GuildApplicationCommandManager = __commonJS((exports, module) => {
  var ApplicationCommandManager = require_ApplicationCommandManager();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();

  class GuildApplicationCommandManager extends ApplicationCommandManager {
    constructor(guild, iterable) {
      super(guild.client, iterable);
      this.guild = guild;
      this.permissions = new ApplicationCommandPermissionsManager(this);
    }
  }
  module.exports = GuildApplicationCommandManager;
});

// node_modules/discord.js/src/managers/GuildBanManager.js
var require_GuildBanManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist7();
  var { makeURLSearchParams } = require_dist6();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var GuildBan = require_GuildBan();
  var { GuildMember } = require_GuildMember();
  var deprecationEmittedForDeleteMessageDays = false;

  class GuildBanManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildBan, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
    }
    resolve(ban) {
      return super.resolve(ban) ?? super.resolve(this.client.users.resolveId(ban));
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { user, cache, force, limit, before, after } = options;
      const resolvedUser = this.client.users.resolveId(user ?? options);
      if (resolvedUser)
        return this._fetchSingle({ user: resolvedUser, cache, force });
      if (!before && !after && !limit && cache === undefined) {
        return Promise.reject(new DiscordjsError(ErrorCodes.FetchBanResolveId));
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ user, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(user);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildBan(this.guild.id, user));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.guildBans(this.guild.id), {
        query: makeURLSearchParams(options)
      });
      return data.reduce((col, ban) => col.set(ban.user.id, this._add(ban, options.cache)), new Collection);
    }
    async create(user, options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsError(ErrorCodes.BanResolveId, true);
      if (options.deleteMessageDays !== undefined && !deprecationEmittedForDeleteMessageDays) {
        process2.emitWarning("The deleteMessageDays option for GuildBanManager#create() is deprecated. Use the deleteMessageSeconds option instead.", "DeprecationWarning");
        deprecationEmittedForDeleteMessageDays = true;
      }
      await this.client.rest.put(Routes.guildBan(this.guild.id, id), {
        body: {
          delete_message_seconds: options.deleteMessageSeconds ?? (options.deleteMessageDays ? options.deleteMessageDays * 24 * 60 * 60 : undefined)
        },
        reason: options.reason
      });
      if (user instanceof GuildMember)
        return user;
      const _user = this.client.users.resolve(id);
      if (_user) {
        return this.guild.members.resolve(_user) ?? _user;
      }
      return id;
    }
    async remove(user, reason) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsError(ErrorCodes.BanResolveId);
      await this.client.rest.delete(Routes.guildBan(this.guild.id, id), { reason });
      return this.client.users.resolve(user);
    }
  }
  module.exports = GuildBanManager;
});

// node_modules/discord.js/src/managers/GuildChannelManager.js
var require_GuildChannelManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist7();
  var { ChannelType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var GuildTextThreadManager = require_GuildTextThreadManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var GuildChannel = require_GuildChannel();
  var PermissionOverwrites = require_PermissionOverwrites();
  var ThreadChannel = require_ThreadChannel();
  var Webhook = require_Webhook();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();
  var { transformGuildForumTag, transformGuildDefaultReaction } = require_Channels();
  var { ThreadChannelTypes } = require_Constants();
  var DataResolver = require_DataResolver();
  var { setPosition } = require_Util();
  var cacheWarningEmitted = false;

  class GuildChannelManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildChannel, iterable);
      const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;
      if (!cacheWarningEmitted && !defaultCaching) {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.guild = guild;
    }
    get channelCountWithoutThreads() {
      return this.cache.reduce((acc, channel) => {
        if (ThreadChannelTypes.includes(channel.type))
          return acc;
        return ++acc;
      }, 0);
    }
    _add(channel) {
      const existing = this.cache.get(channel.id);
      if (existing)
        return existing;
      this.cache.set(channel.id, channel);
      return channel;
    }
    resolve(channel) {
      if (channel instanceof ThreadChannel)
        return super.resolve(channel.id);
      return super.resolve(channel);
    }
    resolveId(channel) {
      if (channel instanceof ThreadChannel)
        return super.resolveId(channel.id);
      return super.resolveId(channel);
    }
    async addFollower(channel, targetChannel, reason) {
      const channelId = this.resolveId(channel);
      const targetChannelId = this.resolveId(targetChannel);
      if (!channelId || !targetChannelId)
        throw new Error(ErrorCodes.GuildChannelResolve);
      const { webhook_id } = await this.client.rest.post(Routes.channelFollowers(channelId), {
        body: { webhook_channel_id: targetChannelId },
        reason
      });
      return webhook_id;
    }
    async create({
      name,
      type,
      topic,
      nsfw,
      bitrate,
      userLimit,
      parent,
      permissionOverwrites,
      position,
      rateLimitPerUser,
      rtcRegion,
      videoQualityMode,
      defaultThreadRateLimitPerUser,
      availableTags,
      defaultReactionEmoji,
      defaultAutoArchiveDuration,
      defaultSortOrder,
      defaultForumLayout,
      reason
    }) {
      parent &&= this.client.channels.resolveId(parent);
      permissionOverwrites &&= permissionOverwrites.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
      const data = await this.client.rest.post(Routes.guildChannels(this.guild.id), {
        body: {
          name,
          topic,
          type,
          nsfw,
          bitrate,
          user_limit: userLimit,
          parent_id: parent,
          position,
          permission_overwrites: permissionOverwrites,
          rate_limit_per_user: rateLimitPerUser,
          rtc_region: rtcRegion,
          video_quality_mode: videoQualityMode,
          default_thread_rate_limit_per_user: defaultThreadRateLimitPerUser,
          available_tags: availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
          default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),
          default_auto_archive_duration: defaultAutoArchiveDuration,
          default_sort_order: defaultSortOrder,
          default_forum_layout: defaultForumLayout
        },
        reason
      });
      return this.client.actions.ChannelCreate.handle(data).channel;
    }
    async createWebhook({ channel, name, avatar, reason }) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      if (typeof avatar === "string" && !avatar.startsWith("data:")) {
        avatar = await DataResolver.resolveImage(avatar);
      }
      const data = await this.client.rest.post(Routes.channelWebhooks(id), {
        body: {
          name,
          avatar
        },
        reason
      });
      return new Webhook(this.client, data);
    }
    async edit(channel, options) {
      channel = this.resolve(channel);
      if (!channel)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const parent = options.parent && this.client.channels.resolveId(options.parent);
      if (options.position !== undefined) {
        await this.setPosition(channel, options.position, { position: options.position, reason: options.reason });
      }
      let permission_overwrites = options.permissionOverwrites?.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
      if (options.lockPermissions) {
        if (parent) {
          const newParent = this.guild.channels.resolve(parent);
          if (newParent?.type === ChannelType.GuildCategory) {
            permission_overwrites = newParent.permissionOverwrites.cache.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
          }
        } else if (channel.parent) {
          permission_overwrites = channel.parent.permissionOverwrites.cache.map((overwrite) => PermissionOverwrites.resolve(overwrite, this.guild));
        }
      }
      const newData = await this.client.rest.patch(Routes.channel(channel.id), {
        body: {
          name: (options.name ?? channel.name).trim(),
          type: options.type,
          topic: options.topic,
          nsfw: options.nsfw,
          bitrate: options.bitrate ?? channel.bitrate,
          user_limit: options.userLimit ?? channel.userLimit,
          rtc_region: "rtcRegion" in options ? options.rtcRegion : channel.rtcRegion,
          video_quality_mode: options.videoQualityMode,
          parent_id: parent,
          lock_permissions: options.lockPermissions,
          rate_limit_per_user: options.rateLimitPerUser,
          default_auto_archive_duration: options.defaultAutoArchiveDuration,
          permission_overwrites,
          available_tags: options.availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
          default_reaction_emoji: options.defaultReactionEmoji && transformGuildDefaultReaction(options.defaultReactionEmoji),
          default_thread_rate_limit_per_user: options.defaultThreadRateLimitPerUser,
          flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : undefined,
          default_sort_order: options.defaultSortOrder,
          default_forum_layout: options.defaultForumLayout
        },
        reason: options.reason
      });
      return this.client.actions.ChannelUpdate.handle(newData).updated;
    }
    async setPosition(channel, position, { relative, reason } = {}) {
      channel = this.resolve(channel);
      if (!channel)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const updatedChannels = await setPosition(channel, position, relative, this.guild._sortedChannels(channel), this.client, Routes.guildChannels(this.guild.id), reason);
      this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.guild.id,
        channels: updatedChannels
      });
      return channel;
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id && !force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      if (id) {
        const data2 = await this.client.rest.get(Routes.channel(id));
        if (this.guild.id !== data2.guild_id)
          throw new DiscordjsError(ErrorCodes.GuildChannelUnowned);
        return this.client.channels._add(data2, this.guild, { cache });
      }
      const data = await this.client.rest.get(Routes.guildChannels(this.guild.id));
      const channels = new Collection;
      for (const channel of data)
        channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));
      return channels;
    }
    async fetchWebhooks(channel) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const data = await this.client.rest.get(Routes.channelWebhooks(id));
      return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook(this.client, hook)), new Collection);
    }
    async setPositions(channelPositions) {
      channelPositions = channelPositions.map((channelPosition) => ({
        id: this.client.channels.resolveId(channelPosition.channel),
        position: channelPosition.position,
        lock_permissions: channelPosition.lockPermissions,
        parent_id: channelPosition.parent !== undefined ? this.resolveId(channelPosition.parent) : undefined
      }));
      await this.client.rest.patch(Routes.guildChannels(this.guild.id), { body: channelPositions });
      return this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.guild.id,
        channels: channelPositions
      }).guild;
    }
    async fetchActiveThreads(cache = true) {
      const data = await this.rawFetchGuildActiveThreads();
      return GuildTextThreadManager._mapThreads(data, this.client, { guild: this.guild, cache });
    }
    rawFetchGuildActiveThreads() {
      return this.client.rest.get(Routes.guildActiveThreads(this.guild.id));
    }
    async delete(channel, reason) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      await this.client.rest.delete(Routes.channel(id), { reason });
      this.client.actions.ChannelDelete.handle({ id });
    }
  }
  module.exports = GuildChannelManager;
});

// node_modules/discord.js/src/managers/GuildEmojiManager.js
var require_GuildEmojiManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { Routes, PermissionFlagsBits } = require_v106();
  var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var DataResolver = require_DataResolver();

  class GuildEmojiManager extends BaseGuildEmojiManager {
    constructor(guild, iterable) {
      super(guild.client, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({ attachment, name, roles, reason }) {
      attachment = await DataResolver.resolveImage(attachment);
      if (!attachment)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      const body = { image: attachment, name };
      if (roles) {
        if (!Array.isArray(roles) && !(roles instanceof Collection)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.roles", "Array or Collection of Roles or Snowflakes", true);
        }
        body.roles = [];
        for (const role of roles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "options.roles", role);
          }
          body.roles.push(resolvedRole);
        }
      }
      const emoji = await this.client.rest.post(Routes.guildEmojis(this.guild.id), { body, reason });
      return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const emoji = await this.client.rest.get(Routes.guildEmoji(this.guild.id, id));
        return this._add(emoji, cache);
      }
      const data = await this.client.rest.get(Routes.guildEmojis(this.guild.id));
      const emojis = new Collection;
      for (const emoji of data)
        emojis.set(emoji.id, this._add(emoji, cache));
      return emojis;
    }
    async delete(emoji, reason) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      await this.client.rest.delete(Routes.guildEmoji(this.guild.id, id), { reason });
    }
    async edit(emoji, options) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      const roles = options.roles?.map((role) => this.guild.roles.resolveId(role));
      const newData = await this.client.rest.patch(Routes.guildEmoji(this.guild.id, id), {
        body: {
          name: options.name,
          roles
        },
        reason: options.reason
      });
      const existing = this.cache.get(id);
      if (existing) {
        const clone = existing._clone();
        clone._patch(newData);
        return clone;
      }
      return this._add(newData);
    }
    async fetchAuthor(emoji) {
      emoji = this.resolve(emoji);
      if (!emoji)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      if (emoji.managed) {
        throw new DiscordjsError(ErrorCodes.EmojiManaged);
      }
      const { me } = this.guild.members;
      if (!me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      if (!me.permissions.has(PermissionFlagsBits.ManageGuildExpressions)) {
        throw new DiscordjsError(ErrorCodes.MissingManageGuildExpressionsPermission, this.guild);
      }
      const data = await this.client.rest.get(Routes.guildEmoji(this.guild.id, emoji.id));
      emoji._patch(data);
      return emoji.author;
    }
  }
  module.exports = GuildEmojiManager;
});

// node_modules/discord.js/src/managers/GuildInviteManager.js
var require_GuildInviteManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var Invite = require_Invite();
  var DataResolver = require_DataResolver();

  class GuildInviteManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Invite, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.code, extras: [this.guild] });
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      if (typeof options === "string") {
        const code = DataResolver.resolveInviteCode(options);
        if (!code)
          return Promise.reject(new DiscordjsError(ErrorCodes.InviteResolveCode));
        return this._fetchSingle({ code, cache: true });
      }
      if (!options.code) {
        if (options.channelId) {
          const id = this.guild.channels.resolveId(options.channelId);
          if (!id)
            return Promise.reject(new DiscordjsError(ErrorCodes.GuildChannelResolve));
          return this._fetchChannelMany(id, options.cache);
        }
        if ("cache" in options)
          return this._fetchMany(options.cache);
        return Promise.reject(new DiscordjsError(ErrorCodes.InviteResolveCode));
      }
      return this._fetchSingle({
        ...options,
        code: DataResolver.resolveInviteCode(options.code)
      });
    }
    async _fetchSingle({ code, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(code);
        if (existing)
          return existing;
      }
      const invites = await this._fetchMany(cache);
      const invite = invites.get(code);
      if (!invite)
        throw new DiscordjsError(ErrorCodes.InviteNotFound);
      return invite;
    }
    async _fetchMany(cache) {
      const data = await this.client.rest.get(Routes.guildInvites(this.guild.id));
      return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection);
    }
    async _fetchChannelMany(channelId, cache) {
      const data = await this.client.rest.get(Routes.channelInvites(channelId));
      return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection);
    }
    async create(channel, { temporary, maxAge, maxUses, unique, targetUser, targetApplication, targetType, reason } = {}) {
      const id = this.guild.channels.resolveId(channel);
      if (!id)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      const invite = await this.client.rest.post(Routes.channelInvites(id), {
        body: {
          temporary,
          max_age: maxAge,
          max_uses: maxUses,
          unique,
          target_user_id: this.client.users.resolveId(targetUser),
          target_application_id: targetApplication?.id ?? targetApplication?.applicationId ?? targetApplication,
          target_type: targetType
        },
        reason
      });
      return new Invite(this.client, invite);
    }
    async delete(invite, reason) {
      const code = DataResolver.resolveInviteCode(invite);
      await this.client.rest.delete(Routes.invite(code), { reason });
    }
  }
  module.exports = GuildInviteManager;
});

// node_modules/discord.js/src/managers/GuildMemberManager.js
var require_GuildMemberManager = __commonJS((exports, module) => {
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { Collection } = require_dist7();
  var { makeURLSearchParams } = require_dist6();
  var { DiscordSnowflake } = require_dist3();
  var { Routes, GatewayOpcodes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors2();
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
  var { GuildMember } = require_GuildMember();
  var { Role } = require_Role();
  var Events = require_Events();
  var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
  var Partials = require_Partials();

  class GuildMemberManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildMember, iterable);
      this.guild = guild;
    }
    _add(data, cache = true) {
      return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
    }
    resolve(member) {
      const memberResolvable = super.resolve(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveId(member);
      if (userResolvable)
        return super.resolve(userResolvable);
      return null;
    }
    resolveId(member) {
      const memberResolvable = super.resolveId(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveId(member);
      return this.cache.has(userResolvable) ? userResolvable : null;
    }
    async add(user, options) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      if (!options.force) {
        const cachedUser = this.cache.get(userId);
        if (cachedUser)
          return cachedUser;
      }
      const resolvedOptions = {
        access_token: options.accessToken,
        nick: options.nick,
        mute: options.mute,
        deaf: options.deaf
      };
      if (options.roles) {
        if (!Array.isArray(options.roles) && !(options.roles instanceof Collection)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.roles", "Array or Collection of Roles or Snowflakes", true);
        }
        const resolvedRoles = [];
        for (const role of options.roles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "options.roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        resolvedOptions.roles = resolvedRoles;
      }
      const data = await this.client.rest.put(Routes.guildMember(this.guild.id, userId), { body: resolvedOptions });
      return data instanceof Uint8Array ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);
    }
    get me() {
      return this.resolve(this.client.user.id) ?? (this.client.options.partials.includes(Partials.GuildMember) ? this._add({ user: { id: this.client.user.id } }, true) : null);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { user: users, limit, withPresences, cache, force } = options;
      const resolvedUser = this.client.users.resolveId(users ?? options);
      if (resolvedUser && !limit && !withPresences)
        return this._fetchSingle({ user: resolvedUser, cache, force });
      const resolvedUsers = users?.map?.((user) => this.client.users.resolveId(user)) ?? resolvedUser ?? undefined;
      return this._fetchMany({ ...options, users: resolvedUsers });
    }
    async _fetchSingle({ user, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(user);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildMember(this.guild.id, user));
      return this._add(data, cache);
    }
    _fetchMany({
      limit = 0,
      withPresences: presences,
      users,
      query,
      time = 120000,
      nonce = DiscordSnowflake.generate().toString()
    } = {}) {
      if (nonce.length > 32)
        return Promise.reject(new DiscordjsRangeError(ErrorCodes.MemberFetchNonceLength));
      return new Promise((resolve, reject) => {
        if (!query && !users)
          query = "";
        this.guild.shard.send({
          op: GatewayOpcodes.RequestGuildMembers,
          d: {
            guild_id: this.guild.id,
            presences,
            user_ids: users,
            query,
            nonce,
            limit
          }
        });
        const fetchedMembers = new Collection;
        let i = 0;
        const handler = (members, _, chunk) => {
          if (chunk.nonce !== nonce)
            return;
          timeout.refresh();
          i++;
          for (const member of members.values()) {
            fetchedMembers.set(member.id, member);
          }
          if (members.size < 1000 || limit && fetchedMembers.size >= limit || i === chunk.count) {
            clearTimeout2(timeout);
            this.client.removeListener(Events.GuildMembersChunk, handler);
            this.client.decrementMaxListeners();
            resolve(users && !Array.isArray(users) && fetchedMembers.size ? fetchedMembers.first() : fetchedMembers);
          }
        };
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.GuildMembersChunk, handler);
          this.client.decrementMaxListeners();
          reject(new DiscordjsError(ErrorCodes.GuildMembersTimeout));
        }, time).unref();
        this.client.incrementMaxListeners();
        this.client.on(Events.GuildMembersChunk, handler);
      });
    }
    fetchMe(options) {
      return this.fetch({ ...options, user: this.client.user.id });
    }
    async search({ query, limit, cache = true } = {}) {
      const data = await this.client.rest.get(Routes.guildMembersSearch(this.guild.id), {
        query: makeURLSearchParams({ query, limit })
      });
      return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection);
    }
    async list({ after, limit, cache = true } = {}) {
      const query = makeURLSearchParams({ limit, after });
      const data = await this.client.rest.get(Routes.guildMembers(this.guild.id), { query });
      return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection);
    }
    async edit(user, { reason, ...options }) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      if (options.channel) {
        options.channel = this.guild.channels.resolve(options.channel);
        if (!(options.channel instanceof BaseGuildVoiceChannel)) {
          throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);
        }
        options.channel_id = options.channel.id;
        options.channel = undefined;
      } else if (options.channel === null) {
        options.channel_id = null;
        options.channel = undefined;
      }
      options.roles &&= options.roles.map((role) => role instanceof Role ? role.id : role);
      if (options.communicationDisabledUntil !== undefined) {
        options.communication_disabled_until = options.communicationDisabledUntil != null ? new Date(options.communicationDisabledUntil).toISOString() : options.communicationDisabledUntil;
      }
      if (options.flags !== undefined) {
        options.flags = GuildMemberFlagsBitField.resolve(options.flags);
      }
      let endpoint;
      if (id === this.client.user.id) {
        const keys = Object.keys(options);
        if (keys.length === 1 && keys[0] === "nick")
          endpoint = Routes.guildMember(this.guild.id);
        else
          endpoint = Routes.guildMember(this.guild.id, id);
      } else {
        endpoint = Routes.guildMember(this.guild.id, id);
      }
      const d = await this.client.rest.patch(endpoint, { body: options, reason });
      const clone = this.cache.get(id)?._clone();
      clone?._patch(d);
      return clone ?? this._add(d, false);
    }
    async prune({ days, dry = false, count: compute_prune_count, roles = [], reason } = {}) {
      if (typeof days !== "number")
        throw new DiscordjsTypeError(ErrorCodes.PruneDaysType);
      const query = { days };
      const resolvedRoles = [];
      for (const role of roles) {
        const resolvedRole = this.guild.roles.resolveId(role);
        if (!resolvedRole) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "options.roles", role);
        }
        resolvedRoles.push(resolvedRole);
      }
      if (resolvedRoles.length) {
        query.include_roles = dry ? resolvedRoles.join(",") : resolvedRoles;
      }
      const endpoint = Routes.guildPrune(this.guild.id);
      const { pruned } = await (dry ? this.client.rest.get(endpoint, { query: makeURLSearchParams(query), reason }) : this.client.rest.post(endpoint, { body: { ...query, compute_prune_count }, reason }));
      return pruned;
    }
    async kick(user, reason) {
      const id = this.client.users.resolveId(user);
      if (!id)
        return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable"));
      await this.client.rest.delete(Routes.guildMember(this.guild.id, id), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? id;
    }
    ban(user, options) {
      return this.guild.bans.create(user, options);
    }
    unban(user, reason) {
      return this.guild.bans.remove(user, reason);
    }
    async addRole(options) {
      const { user, role, reason } = options;
      const userId = this.guild.members.resolveId(user);
      const roleId = this.guild.roles.resolveId(role);
      await this.client.rest.put(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
    }
    async removeRole(options) {
      const { user, role, reason } = options;
      const userId = this.guild.members.resolveId(user);
      const roleId = this.guild.roles.resolveId(role);
      await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
    }
  }
  module.exports = GuildMemberManager;
});

// node_modules/discord.js/src/managers/GuildScheduledEventManager.js
var require_GuildScheduledEventManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { makeURLSearchParams } = require_dist6();
  var { GuildScheduledEventEntityType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var DataResolver = require_DataResolver();

  class GuildScheduledEventManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildScheduledEvent, iterable);
      this.guild = guild;
    }
    async create(options) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      let {
        privacyLevel,
        entityType,
        channel,
        name,
        scheduledStartTime,
        description,
        scheduledEndTime,
        entityMetadata,
        reason,
        image
      } = options;
      let entity_metadata, channel_id;
      if (entityType === GuildScheduledEventEntityType.External) {
        channel_id = channel === undefined ? channel : null;
        entity_metadata = { location: entityMetadata?.location };
      } else {
        channel_id = this.guild.channels.resolveId(channel);
        if (!channel_id)
          throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);
        entity_metadata = entityMetadata === undefined ? entityMetadata : null;
      }
      const data = await this.client.rest.post(Routes.guildScheduledEvents(this.guild.id), {
        body: {
          channel_id,
          name,
          privacy_level: privacyLevel,
          scheduled_start_time: new Date(scheduledStartTime).toISOString(),
          scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
          description,
          entity_type: entityType,
          entity_metadata,
          image: image && await DataResolver.resolveImage(image)
        },
        reason
      });
      return this._add(data);
    }
    async fetch(options = {}) {
      const id = this.resolveId(options.guildScheduledEvent ?? options);
      if (id) {
        if (!options.force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data2 = await this.client.rest.get(Routes.guildScheduledEvent(this.guild.id, id), {
          query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true })
        });
        return this._add(data2, options.cache);
      }
      const data = await this.client.rest.get(Routes.guildScheduledEvents(this.guild.id), {
        query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true })
      });
      return data.reduce((coll, rawGuildScheduledEventData) => coll.set(rawGuildScheduledEventData.id, this.guild.scheduledEvents._add(rawGuildScheduledEventData, options.cache)), new Collection);
    }
    async edit(guildScheduledEvent, options) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      let {
        privacyLevel,
        entityType,
        channel,
        status,
        name,
        scheduledStartTime,
        description,
        scheduledEndTime,
        entityMetadata,
        reason,
        image
      } = options;
      let entity_metadata;
      if (entityMetadata) {
        entity_metadata = {
          location: entityMetadata.location
        };
      }
      const data = await this.client.rest.patch(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId), {
        body: {
          channel_id: channel === undefined ? channel : this.guild.channels.resolveId(channel),
          name,
          privacy_level: privacyLevel,
          scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : undefined,
          scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
          description,
          entity_type: entityType,
          status,
          image: image && await DataResolver.resolveImage(image),
          entity_metadata
        },
        reason
      });
      return this._add(data);
    }
    async delete(guildScheduledEvent) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      await this.client.rest.delete(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId));
    }
    async fetchSubscribers(guildScheduledEvent, options = {}) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      const query = makeURLSearchParams({
        limit: options.limit,
        with_member: options.withMember,
        before: options.before,
        after: options.after
      });
      const data = await this.client.rest.get(Routes.guildScheduledEventUsers(this.guild.id, guildScheduledEventId), {
        query
      });
      return data.reduce((coll, rawData) => coll.set(rawData.user.id, {
        guildScheduledEventId: rawData.guild_scheduled_event_id,
        user: this.client.users._add(rawData.user),
        member: rawData.member ? this.guild.members._add({ ...rawData.member, user: rawData.user }) : null
      }), new Collection);
    }
  }
  module.exports = GuildScheduledEventManager;
});

// node_modules/discord.js/src/managers/GuildStickerManager.js
var require_GuildStickerManager = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var MessagePayload = require_MessagePayload();
  var { Sticker } = require_Sticker();

  class GuildStickerManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Sticker, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({ file, name, tags, description, reason } = {}) {
      const resolvedFile = await MessagePayload.resolveFile(file);
      if (!resolvedFile)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      file = { ...resolvedFile, key: "file" };
      const body = { name, tags, description: description ?? "" };
      const sticker = await this.client.rest.post(Routes.guildStickers(this.guild.id), {
        appendToFormData: true,
        body,
        files: [file],
        reason
      });
      return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;
    }
    async edit(sticker, options = {}) {
      const stickerId = this.resolveId(sticker);
      if (!stickerId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      const d = await this.client.rest.patch(Routes.guildSticker(this.guild.id, stickerId), {
        body: options,
        reason: options.reason
      });
      const existing = this.cache.get(stickerId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      return this._add(d);
    }
    async delete(sticker, reason) {
      sticker = this.resolveId(sticker);
      if (!sticker)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      await this.client.rest.delete(Routes.guildSticker(this.guild.id, sticker), { reason });
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const sticker = await this.client.rest.get(Routes.guildSticker(this.guild.id, id));
        return this._add(sticker, cache);
      }
      const data = await this.client.rest.get(Routes.guildStickers(this.guild.id));
      return new Collection(data.map((sticker) => [sticker.id, this._add(sticker, cache)]));
    }
    async fetchUser(sticker) {
      sticker = this.resolve(sticker);
      if (!sticker)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      const data = await this.client.rest.get(Routes.guildSticker(this.guild.id, sticker.id));
      sticker._patch(data);
      return sticker.user;
    }
  }
  module.exports = GuildStickerManager;
});

// node_modules/discord.js/src/util/ActivityFlagsBitField.js
var require_ActivityFlagsBitField = __commonJS((exports, module) => {
  var { ActivityFlags } = require_v106();
  var BitField = require_BitField();

  class ActivityFlagsBitField extends BitField {
    static Flags = ActivityFlags;
  }
  module.exports = ActivityFlagsBitField;
});

// node_modules/discord.js/src/structures/Presence.js
var require_Presence = __commonJS((exports) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();
  var ActivityFlagsBitField = require_ActivityFlagsBitField();
  var { flatten } = require_Util();

  class Presence extends Base {
    constructor(client, data = {}) {
      super(client);
      this.userId = data.user.id;
      this.guild = data.guild ?? null;
      this._patch(data);
    }
    get user() {
      return this.client.users.resolve(this.userId);
    }
    get member() {
      return this.guild.members.resolve(this.userId);
    }
    _patch(data) {
      if ("status" in data) {
        this.status = data.status;
      } else {
        this.status ??= "offline";
      }
      if ("activities" in data) {
        this.activities = data.activities.map((activity) => new Activity(this, activity));
      } else {
        this.activities ??= [];
      }
      if ("client_status" in data) {
        this.clientStatus = data.client_status;
      } else {
        this.clientStatus ??= null;
      }
      return this;
    }
    _clone() {
      const clone = Object.assign(Object.create(this), this);
      clone.activities = this.activities.map((activity) => activity._clone());
      return clone;
    }
    equals(presence) {
      return this === presence || presence && this.status === presence.status && this.activities.length === presence.activities.length && this.activities.every((activity, index) => activity.equals(presence.activities[index])) && this.clientStatus?.web === presence.clientStatus?.web && this.clientStatus?.mobile === presence.clientStatus?.mobile && this.clientStatus?.desktop === presence.clientStatus?.desktop;
    }
    toJSON() {
      return flatten(this);
    }
  }

  class Activity {
    constructor(presence, data) {
      Object.defineProperty(this, "presence", { value: presence });
      this.name = data.name;
      this.type = data.type;
      this.url = data.url ?? null;
      this.details = data.details ?? null;
      this.state = data.state ?? null;
      this.applicationId = data.application_id ?? null;
      this.timestamps = data.timestamps ? {
        start: data.timestamps.start ? new Date(Number(data.timestamps.start)) : null,
        end: data.timestamps.end ? new Date(Number(data.timestamps.end)) : null
      } : null;
      this.party = data.party ?? null;
      this.syncId = data.sync_id ?? null;
      this.assets = data.assets ? new RichPresenceAssets(this, data.assets) : null;
      this.flags = new ActivityFlagsBitField(data.flags).freeze();
      this.emoji = data.emoji ? new Emoji(presence.client, data.emoji) : null;
      this.buttons = data.buttons ?? [];
      this.createdTimestamp = data.created_at;
    }
    equals(activity) {
      return this === activity || activity && this.name === activity.name && this.type === activity.type && this.url === activity.url && this.state === activity.state && this.details === activity.details && this.emoji?.id === activity.emoji?.id && this.emoji?.name === activity.emoji?.name;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toString() {
      return this.name;
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
  }

  class RichPresenceAssets {
    constructor(activity, assets) {
      Object.defineProperty(this, "activity", { value: activity });
      this.largeText = assets.large_text ?? null;
      this.smallText = assets.small_text ?? null;
      this.largeImage = assets.large_image ?? null;
      this.smallImage = assets.small_image ?? null;
    }
    smallImageURL(options = {}) {
      if (!this.smallImage)
        return null;
      if (this.smallImage.includes(":")) {
        const [platform, id] = this.smallImage.split(":");
        switch (platform) {
          case "mp":
            return `https://media.discordapp.net/${id}`;
          default:
            return null;
        }
      }
      return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.smallImage, options);
    }
    largeImageURL(options = {}) {
      if (!this.largeImage)
        return null;
      if (this.largeImage.includes(":")) {
        const [platform, id] = this.largeImage.split(":");
        switch (platform) {
          case "mp":
            return `https://media.discordapp.net/${id}`;
          case "spotify":
            return `https://i.scdn.co/image/${id}`;
          case "youtube":
            return `https://i.ytimg.com/vi/${id}/hqdefault_live.jpg`;
          case "twitch":
            return `https://static-cdn.jtvnw.net/previews-ttv/live_user_${id}.png`;
          default:
            return null;
        }
      }
      return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.largeImage, options);
    }
  }
  exports.Presence = Presence;
  exports.Activity = Activity;
  exports.RichPresenceAssets = RichPresenceAssets;
});

// node_modules/discord.js/src/managers/PresenceManager.js
var require_PresenceManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var { Presence } = require_Presence();

  class PresenceManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Presence, iterable);
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.user.id });
    }
    resolve(presence) {
      const presenceResolvable = super.resolve(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const UserResolvable = this.client.users.resolveId(presence);
      return super.resolve(UserResolvable);
    }
    resolveId(presence) {
      const presenceResolvable = super.resolveId(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const userResolvable = this.client.users.resolveId(presence);
      return this.cache.has(userResolvable) ? userResolvable : null;
    }
  }
  module.exports = PresenceManager;
});

// node_modules/discord.js/src/managers/RoleManager.js
var require_RoleManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist7();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Role } = require_Role();
  var DataResolver = require_DataResolver();
  var PermissionsBitField = require_PermissionsBitField();
  var { setPosition, resolveColor } = require_Util();
  var cacheWarningEmitted = false;

  class RoleManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Role, iterable);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id && !force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildRoles(this.guild.id));
      const roles = new Collection;
      for (const role of data)
        roles.set(role.id, this._add(role, cache));
      return id ? roles.get(id) ?? null : roles;
    }
    async create(options = {}) {
      let { name, color, hoist, permissions, position, mentionable, reason, icon, unicodeEmoji } = options;
      color &&= resolveColor(color);
      if (permissions !== undefined)
        permissions = new PermissionsBitField(permissions);
      if (icon) {
        const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;
        icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);
        if (typeof icon !== "string")
          icon = undefined;
      }
      const data = await this.client.rest.post(Routes.guildRoles(this.guild.id), {
        body: {
          name,
          color,
          hoist,
          permissions,
          mentionable,
          icon,
          unicode_emoji: unicodeEmoji
        },
        reason
      });
      const { role } = this.client.actions.GuildRoleCreate.handle({
        guild_id: this.guild.id,
        role: data
      });
      if (position)
        return this.setPosition(role, position, { reason });
      return role;
    }
    async edit(role, options) {
      role = this.resolve(role);
      if (!role)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "RoleResolvable");
      if (typeof options.position === "number") {
        await this.setPosition(role, options.position, { reason: options.reason });
      }
      let icon = options.icon;
      if (icon) {
        const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;
        icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);
        if (typeof icon !== "string")
          icon = undefined;
      }
      const body = {
        name: options.name,
        color: options.color === undefined ? undefined : resolveColor(options.color),
        hoist: options.hoist,
        permissions: options.permissions === undefined ? undefined : new PermissionsBitField(options.permissions),
        mentionable: options.mentionable,
        icon,
        unicode_emoji: options.unicodeEmoji
      };
      const d = await this.client.rest.patch(Routes.guildRole(this.guild.id, role.id), { body, reason: options.reason });
      const clone = role._clone();
      clone._patch(d);
      return clone;
    }
    async delete(role, reason) {
      const id = this.resolveId(role);
      await this.client.rest.delete(Routes.guildRole(this.guild.id, id), { reason });
      this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });
    }
    async setPosition(role, position, { relative, reason } = {}) {
      role = this.resolve(role);
      if (!role)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "RoleResolvable");
      const updatedRoles = await setPosition(role, position, relative, this.guild._sortedRoles(), this.client, Routes.guildRoles(this.guild.id), reason);
      this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.guild.id,
        roles: updatedRoles
      });
      return role;
    }
    async setPositions(rolePositions) {
      rolePositions = rolePositions.map((rolePosition) => ({
        id: this.resolveId(rolePosition.role),
        position: rolePosition.position
      }));
      await this.client.rest.patch(Routes.guildRoles(this.guild.id), { body: rolePositions });
      return this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.guild.id,
        roles: rolePositions
      }).guild;
    }
    comparePositions(role1, role2) {
      const resolvedRole1 = this.resolve(role1);
      const resolvedRole2 = this.resolve(role2);
      if (!resolvedRole1 || !resolvedRole2) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "Role nor a Snowflake");
      }
      const role1Position = resolvedRole1.position;
      const role2Position = resolvedRole2.position;
      if (role1Position === role2Position) {
        return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));
      }
      return role1Position - role2Position;
    }
    botRoleFor(user) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        return null;
      return this.cache.find((role) => role.tags?.botId === userId) ?? null;
    }
    get everyone() {
      return this.cache.get(this.guild.id);
    }
    get premiumSubscriberRole() {
      return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
    }
    get highest() {
      return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
    }
  }
  module.exports = RoleManager;
});

// node_modules/discord.js/src/managers/StageInstanceManager.js
var require_StageInstanceManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var { StageInstance } = require_StageInstance();

  class StageInstanceManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, StageInstance, iterable);
      this.guild = guild;
    }
    async create(channel, options) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const { guildScheduledEvent, topic, privacyLevel, sendStartNotification } = options;
      const guildScheduledEventId = guildScheduledEvent && this.resolveId(guildScheduledEvent);
      const data = await this.client.rest.post(Routes.stageInstances(), {
        body: {
          channel_id: channelId,
          topic,
          privacy_level: privacyLevel,
          send_start_notification: sendStartNotification,
          guild_scheduled_event_id: guildScheduledEventId
        }
      });
      return this._add(data);
    }
    async fetch(channel, { cache = true, force = false } = {}) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      if (!force) {
        const existing = this.cache.find((stageInstance) => stageInstance.channelId === channelId);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.stageInstance(channelId));
      return this._add(data, cache);
    }
    async edit(channel, options) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      let { topic, privacyLevel } = options;
      const data = await this.client.rest.patch(Routes.stageInstance(channelId), {
        body: {
          topic,
          privacy_level: privacyLevel
        }
      });
      if (this.cache.has(data.id)) {
        const clone = this.cache.get(data.id)._clone();
        clone._patch(data);
        return clone;
      }
      return this._add(data);
    }
    async delete(channel) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      await this.client.rest.delete(Routes.stageInstance(channelId));
    }
  }
  module.exports = StageInstanceManager;
});

// node_modules/discord.js/src/managers/VoiceStateManager.js
var require_VoiceStateManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var VoiceState = require_VoiceState();

  class VoiceStateManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, VoiceState, iterable);
      this.guild = guild;
    }
    _add(data, cache = true) {
      const existing = this.cache.get(data.user_id);
      if (existing)
        return existing._patch(data);
      const entry = new this.holds(this.guild, data);
      if (cache)
        this.cache.set(data.user_id, entry);
      return entry;
    }
  }
  module.exports = VoiceStateManager;
});

// node_modules/discord.js/src/util/SystemChannelFlagsBitField.js
var require_SystemChannelFlagsBitField = __commonJS((exports, module) => {
  var { GuildSystemChannelFlags } = require_v106();
  var BitField = require_BitField();

  class SystemChannelFlagsBitField extends BitField {
    static Flags = GuildSystemChannelFlags;
  }
  module.exports = SystemChannelFlagsBitField;
});

// node_modules/discord.js/src/structures/Guild.js
var require_Guild = __commonJS((exports) => {
  var { Collection } = require_dist7();
  var { makeURLSearchParams } = require_dist6();
  var { DiscordSnowflake } = require_dist3();
  var { ChannelType, GuildPremiumTier, Routes, GuildFeature } = require_v106();
  var AnonymousGuild = require_AnonymousGuild();
  var GuildAuditLogs = require_GuildAuditLogs();
  var { GuildOnboarding } = require_GuildOnboarding();
  var GuildPreview = require_GuildPreview();
  var GuildTemplate = require_GuildTemplate();
  var Integration = require_Integration();
  var Webhook = require_Webhook();
  var WelcomeScreen = require_WelcomeScreen();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var AutoModerationRuleManager = require_AutoModerationRuleManager();
  var GuildApplicationCommandManager = require_GuildApplicationCommandManager();
  var GuildBanManager = require_GuildBanManager();
  var GuildChannelManager = require_GuildChannelManager();
  var GuildEmojiManager = require_GuildEmojiManager();
  var GuildInviteManager = require_GuildInviteManager();
  var GuildMemberManager = require_GuildMemberManager();
  var GuildScheduledEventManager = require_GuildScheduledEventManager();
  var GuildStickerManager = require_GuildStickerManager();
  var PresenceManager = require_PresenceManager();
  var RoleManager = require_RoleManager();
  var StageInstanceManager = require_StageInstanceManager();
  var VoiceStateManager = require_VoiceStateManager();
  var DataResolver = require_DataResolver();
  var Status = require_Status();
  var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  var { discordSort, getSortableGroupTypes, resolvePartialEmoji } = require_Util();

  class Guild extends AnonymousGuild {
    constructor(client, data) {
      super(client, data, false);
      this.commands = new GuildApplicationCommandManager(this);
      this.members = new GuildMemberManager(this);
      this.channels = new GuildChannelManager(this);
      this.bans = new GuildBanManager(this);
      this.roles = new RoleManager(this);
      this.presences = new PresenceManager(this.client);
      this.voiceStates = new VoiceStateManager(this);
      this.stageInstances = new StageInstanceManager(this);
      this.invites = new GuildInviteManager(this);
      this.scheduledEvents = new GuildScheduledEventManager(this);
      this.autoModerationRules = new AutoModerationRuleManager(this);
      if (!data)
        return;
      if (data.unavailable) {
        this.available = false;
      } else {
        this._patch(data);
        if (!data.channels)
          this.available = false;
      }
      this.shardId = data.shardId;
    }
    get shard() {
      return this.client.ws.shards.get(this.shardId);
    }
    _patch(data) {
      super._patch(data);
      this.id = data.id;
      if ("name" in data)
        this.name = data.name;
      if ("icon" in data)
        this.icon = data.icon;
      if ("unavailable" in data) {
        this.available = !data.unavailable;
      } else {
        this.available ??= true;
      }
      if ("discovery_splash" in data) {
        this.discoverySplash = data.discovery_splash;
      }
      if ("member_count" in data) {
        this.memberCount = data.member_count;
      }
      if ("large" in data) {
        this.large = Boolean(data.large);
      }
      if ("premium_progress_bar_enabled" in data) {
        this.premiumProgressBarEnabled = data.premium_progress_bar_enabled;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      }
      if ("afk_timeout" in data) {
        this.afkTimeout = data.afk_timeout;
      }
      if ("afk_channel_id" in data) {
        this.afkChannelId = data.afk_channel_id;
      }
      if ("system_channel_id" in data) {
        this.systemChannelId = data.system_channel_id;
      }
      if ("premium_tier" in data) {
        this.premiumTier = data.premium_tier;
      }
      if ("widget_enabled" in data) {
        this.widgetEnabled = data.widget_enabled;
      } else {
        this.widgetEnabled ??= null;
      }
      if ("widget_channel_id" in data) {
        this.widgetChannelId = data.widget_channel_id;
      } else {
        this.widgetChannelId ??= null;
      }
      if ("explicit_content_filter" in data) {
        this.explicitContentFilter = data.explicit_content_filter;
      }
      if ("mfa_level" in data) {
        this.mfaLevel = data.mfa_level;
      }
      if ("joined_at" in data) {
        this.joinedTimestamp = Date.parse(data.joined_at);
      }
      if ("default_message_notifications" in data) {
        this.defaultMessageNotifications = data.default_message_notifications;
      }
      if ("system_channel_flags" in data) {
        this.systemChannelFlags = new SystemChannelFlagsBitField(data.system_channel_flags).freeze();
      }
      if ("max_members" in data) {
        this.maximumMembers = data.max_members;
      } else {
        this.maximumMembers ??= null;
      }
      if ("max_presences" in data) {
        this.maximumPresences = data.max_presences;
      } else {
        this.maximumPresences ??= null;
      }
      if ("max_video_channel_users" in data) {
        this.maxVideoChannelUsers = data.max_video_channel_users;
      } else {
        this.maxVideoChannelUsers ??= null;
      }
      if ("max_stage_video_channel_users" in data) {
        this.maxStageVideoChannelUsers = data.max_stage_video_channel_users;
      } else {
        this.maxStageVideoChannelUsers ??= null;
      }
      if ("approximate_member_count" in data) {
        this.approximateMemberCount = data.approximate_member_count;
      } else {
        this.approximateMemberCount ??= null;
      }
      if ("approximate_presence_count" in data) {
        this.approximatePresenceCount = data.approximate_presence_count;
      } else {
        this.approximatePresenceCount ??= null;
      }
      this.vanityURLUses ??= null;
      if ("rules_channel_id" in data) {
        this.rulesChannelId = data.rules_channel_id;
      }
      if ("public_updates_channel_id" in data) {
        this.publicUpdatesChannelId = data.public_updates_channel_id;
      }
      if ("preferred_locale" in data) {
        this.preferredLocale = data.preferred_locale;
      }
      if ("safety_alerts_channel_id" in data) {
        this.safetyAlertsChannelId = data.safety_alerts_channel_id;
      } else {
        this.safetyAlertsChannelId ??= null;
      }
      if (data.channels) {
        this.channels.cache.clear();
        for (const rawChannel of data.channels) {
          this.client.channels._add(rawChannel, this);
        }
      }
      if (data.threads) {
        for (const rawThread of data.threads) {
          this.client.channels._add(rawThread, this);
        }
      }
      if (data.roles) {
        this.roles.cache.clear();
        for (const role of data.roles)
          this.roles._add(role);
      }
      if (data.members) {
        this.members.cache.clear();
        for (const guildUser of data.members)
          this.members._add(guildUser);
      }
      if ("owner_id" in data) {
        this.ownerId = data.owner_id;
      }
      if (data.presences) {
        for (const presence of data.presences) {
          this.presences._add(Object.assign(presence, { guild: this }));
        }
      }
      if (data.stage_instances) {
        this.stageInstances.cache.clear();
        for (const stageInstance of data.stage_instances) {
          this.stageInstances._add(stageInstance);
        }
      }
      if (data.guild_scheduled_events) {
        this.scheduledEvents.cache.clear();
        for (const scheduledEvent of data.guild_scheduled_events) {
          this.scheduledEvents._add(scheduledEvent);
        }
      }
      if (data.voice_states) {
        this.voiceStates.cache.clear();
        for (const voiceState of data.voice_states) {
          this.voiceStates._add(voiceState);
        }
      }
      if (!this.emojis) {
        this.emojis = new GuildEmojiManager(this);
        if (data.emojis)
          for (const emoji of data.emojis)
            this.emojis._add(emoji);
      } else if (data.emojis) {
        this.client.actions.GuildEmojisUpdate.handle({
          guild_id: this.id,
          emojis: data.emojis
        });
      }
      if (!this.stickers) {
        this.stickers = new GuildStickerManager(this);
        if (data.stickers)
          for (const sticker of data.stickers)
            this.stickers._add(sticker);
      } else if (data.stickers) {
        this.client.actions.GuildStickersUpdate.handle({
          guild_id: this.id,
          stickers: data.stickers
        });
      }
    }
    get joinedAt() {
      return new Date(this.joinedTimestamp);
    }
    discoverySplashURL(options = {}) {
      return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
    }
    async fetchOwner(options) {
      if (!this.ownerId) {
        throw new DiscordjsError(ErrorCodes.FetchOwnerId);
      }
      const member = await this.members.fetch({ ...options, user: this.ownerId });
      return member;
    }
    get afkChannel() {
      return this.client.channels.resolve(this.afkChannelId);
    }
    get systemChannel() {
      return this.client.channels.resolve(this.systemChannelId);
    }
    get widgetChannel() {
      return this.client.channels.resolve(this.widgetChannelId);
    }
    get rulesChannel() {
      return this.client.channels.resolve(this.rulesChannelId);
    }
    get publicUpdatesChannel() {
      return this.client.channels.resolve(this.publicUpdatesChannelId);
    }
    get safetyAlertsChannel() {
      return this.client.channels.resolve(this.safetyAlertsChannelId);
    }
    get maximumBitrate() {
      if (this.features.includes(GuildFeature.VIPRegions)) {
        return 384000;
      }
      switch (this.premiumTier) {
        case GuildPremiumTier.Tier1:
          return 128000;
        case GuildPremiumTier.Tier2:
          return 256000;
        case GuildPremiumTier.Tier3:
          return 384000;
        default:
          return 96000;
      }
    }
    async fetchIntegrations() {
      const data = await this.client.rest.get(Routes.guildIntegrations(this.id));
      return data.reduce((collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)), new Collection);
    }
    async fetchTemplates() {
      const templates = await this.client.rest.get(Routes.guildTemplates(this.id));
      return templates.reduce((col, data) => col.set(data.code, new GuildTemplate(this.client, data)), new Collection);
    }
    async fetchWelcomeScreen() {
      const data = await this.client.rest.get(Routes.guildWelcomeScreen(this.id));
      return new WelcomeScreen(this, data);
    }
    async createTemplate(name, description) {
      const data = await this.client.rest.post(Routes.guildTemplates(this.id), { body: { name, description } });
      return new GuildTemplate(this.client, data);
    }
    async fetchPreview() {
      const data = await this.client.rest.get(Routes.guildPreview(this.id));
      return new GuildPreview(this.client, data);
    }
    async fetchVanityData() {
      const data = await this.client.rest.get(Routes.guildVanityUrl(this.id));
      this.vanityURLCode = data.code;
      this.vanityURLUses = data.uses;
      return data;
    }
    async fetchWebhooks() {
      const apiHooks = await this.client.rest.get(Routes.guildWebhooks(this.id));
      const hooks = new Collection;
      for (const hook of apiHooks)
        hooks.set(hook.id, new Webhook(this.client, hook));
      return hooks;
    }
    fetchWidget() {
      return this.client.fetchGuildWidget(this.id);
    }
    async fetchWidgetSettings() {
      const data = await this.client.rest.get(Routes.guildWidgetSettings(this.id));
      this.widgetEnabled = data.enabled;
      this.widgetChannelId = data.channel_id;
      return {
        enabled: data.enabled,
        channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null
      };
    }
    widgetImageURL(style) {
      return this.client.guilds.widgetImageURL(this.id, style);
    }
    async fetchAuditLogs({ before, after, limit, user, type } = {}) {
      const query = makeURLSearchParams({
        before: before?.id ?? before,
        after: after?.id ?? after,
        limit,
        action_type: type
      });
      if (user) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
        query.set("user_id", userId);
      }
      const data = await this.client.rest.get(Routes.guildAuditLog(this.id), { query });
      return new GuildAuditLogs(this, data);
    }
    async fetchOnboarding() {
      const data = await this.client.rest.get(Routes.guildOnboarding(this.id));
      return new GuildOnboarding(this.client, data);
    }
    async edit({
      verificationLevel,
      defaultMessageNotifications,
      explicitContentFilter,
      afkChannel,
      afkTimeout,
      icon,
      owner,
      splash,
      discoverySplash,
      banner,
      systemChannel,
      systemChannelFlags,
      rulesChannel,
      publicUpdatesChannel,
      preferredLocale,
      premiumProgressBarEnabled,
      safetyAlertsChannel,
      ...options
    }) {
      const data = await this.client.rest.patch(Routes.guild(this.id), {
        body: {
          ...options,
          verification_level: verificationLevel,
          default_message_notifications: defaultMessageNotifications,
          explicit_content_filter: explicitContentFilter,
          afk_channel_id: afkChannel && this.client.channels.resolveId(afkChannel),
          afk_timeout: afkTimeout,
          icon: icon && await DataResolver.resolveImage(icon),
          owner_id: owner && this.client.users.resolveId(owner),
          splash: splash && await DataResolver.resolveImage(splash),
          discovery_splash: discoverySplash && await DataResolver.resolveImage(discoverySplash),
          banner: banner && await DataResolver.resolveImage(banner),
          system_channel_id: systemChannel && this.client.channels.resolveId(systemChannel),
          system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags),
          rules_channel_id: rulesChannel && this.client.channels.resolveId(rulesChannel),
          public_updates_channel_id: publicUpdatesChannel && this.client.channels.resolveId(publicUpdatesChannel),
          preferred_locale: preferredLocale,
          premium_progress_bar_enabled: premiumProgressBarEnabled,
          safety_alerts_channel_id: safetyAlertsChannel && this.client.channels.resolveId(safetyAlertsChannel)
        },
        reason: options.reason
      });
      return this.client.actions.GuildUpdate.handle(data).updated;
    }
    async editOnboarding(options) {
      const newData = await this.client.rest.put(Routes.guildOnboarding(this.id), {
        body: {
          prompts: options.prompts?.map((prompt) => ({
            id: prompt.id ?? DiscordSnowflake.generate().toString(),
            title: prompt.title,
            single_select: prompt.singleSelect,
            required: prompt.required,
            in_onboarding: prompt.inOnboarding,
            type: prompt.type,
            options: prompt.options.map((option) => {
              const emoji = resolvePartialEmoji(option.emoji);
              return {
                id: option.id,
                channel_ids: option.channels?.map((channel) => this.channels.resolveId(channel)),
                role_ids: option.roles?.map((role) => this.roles.resolveId(role)),
                title: option.title,
                description: option.description,
                emoji_animated: emoji?.animated,
                emoji_id: emoji?.id,
                emoji_name: emoji?.name
              };
            })
          })),
          default_channel_ids: options.defaultChannels?.map((channel) => this.channels.resolveId(channel)),
          enabled: options.enabled,
          mode: options.mode
        },
        reason: options.reason
      });
      return new GuildOnboarding(this.client, newData);
    }
    async editWelcomeScreen(options) {
      const { enabled, description, welcomeChannels } = options;
      const welcome_channels = welcomeChannels?.map((welcomeChannelData) => {
        const emoji = this.emojis.resolve(welcomeChannelData.emoji);
        return {
          emoji_id: emoji?.id,
          emoji_name: emoji?.name ?? welcomeChannelData.emoji,
          channel_id: this.channels.resolveId(welcomeChannelData.channel),
          description: welcomeChannelData.description
        };
      });
      const patchData = await this.client.rest.patch(Routes.guildWelcomeScreen(this.id), {
        body: {
          welcome_channels,
          description,
          enabled
        }
      });
      return new WelcomeScreen(this, patchData);
    }
    setExplicitContentFilter(explicitContentFilter, reason) {
      return this.edit({ explicitContentFilter, reason });
    }
    setDefaultMessageNotifications(defaultMessageNotifications, reason) {
      return this.edit({ defaultMessageNotifications, reason });
    }
    setSystemChannelFlags(systemChannelFlags, reason) {
      return this.edit({ systemChannelFlags, reason });
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setVerificationLevel(verificationLevel, reason) {
      return this.edit({ verificationLevel, reason });
    }
    setAFKChannel(afkChannel, reason) {
      return this.edit({ afkChannel, reason });
    }
    setSystemChannel(systemChannel, reason) {
      return this.edit({ systemChannel, reason });
    }
    setAFKTimeout(afkTimeout, reason) {
      return this.edit({ afkTimeout, reason });
    }
    setIcon(icon, reason) {
      return this.edit({ icon, reason });
    }
    setOwner(owner, reason) {
      return this.edit({ owner, reason });
    }
    setSplash(splash, reason) {
      return this.edit({ splash, reason });
    }
    setDiscoverySplash(discoverySplash, reason) {
      return this.edit({ discoverySplash, reason });
    }
    setBanner(banner, reason) {
      return this.edit({ banner, reason });
    }
    setRulesChannel(rulesChannel, reason) {
      return this.edit({ rulesChannel, reason });
    }
    setPublicUpdatesChannel(publicUpdatesChannel, reason) {
      return this.edit({ publicUpdatesChannel, reason });
    }
    setPreferredLocale(preferredLocale, reason) {
      return this.edit({ preferredLocale, reason });
    }
    setPremiumProgressBarEnabled(enabled = true, reason) {
      return this.edit({ premiumProgressBarEnabled: enabled, reason });
    }
    setSafetyAlertsChannel(safetyAlertsChannel, reason) {
      return this.edit({ safetyAlertsChannel, reason });
    }
    async setWidgetSettings(settings, reason) {
      await this.client.rest.patch(Routes.guildWidgetSettings(this.id), {
        body: {
          enabled: settings.enabled,
          channel_id: this.channels.resolveId(settings.channel)
        },
        reason
      });
      return this;
    }
    async setMFALevel(level, reason) {
      await this.client.rest.post(Routes.guildMFA(this.id), {
        body: {
          level
        },
        reason
      });
      return this;
    }
    async leave() {
      if (this.ownerId === this.client.user.id)
        throw new DiscordjsError(ErrorCodes.GuildOwned);
      await this.client.rest.delete(Routes.userGuild(this.id));
      return this;
    }
    async delete() {
      await this.client.rest.delete(Routes.guild(this.id));
      return this;
    }
    async disableInvites(disabled = true) {
      const features = this.features.filter((feature) => feature !== GuildFeature.InvitesDisabled);
      if (disabled)
        features.push(GuildFeature.InvitesDisabled);
      return this.edit({ features });
    }
    equals(guild) {
      return guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.discoverySplash === guild.discoverySplash && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerId === guild.ownerId && this.verificationLevel === guild.verificationLevel && (this.features === guild.features || this.features.length === guild.features.length && this.features.every((feat, i) => feat === guild.features[i]));
    }
    toJSON() {
      const json = super.toJSON({
        available: false,
        createdTimestamp: true,
        nameAcronym: true,
        presences: false,
        voiceStates: false
      });
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      json.discoverySplashURL = this.discoverySplashURL();
      json.bannerURL = this.bannerURL();
      return json;
    }
    get voiceAdapterCreator() {
      return (methods) => {
        this.client.voice.adapters.set(this.id, methods);
        return {
          sendPayload: (data) => {
            if (this.shard.status !== Status.Ready)
              return false;
            this.shard.send(data);
            return true;
          },
          destroy: () => {
            this.client.voice.adapters.delete(this.id);
          }
        };
      };
    }
    _sortedRoles() {
      return discordSort(this.roles.cache);
    }
    _sortedChannels(channel) {
      const channelIsCategory = channel.type === ChannelType.GuildCategory;
      const types = getSortableGroupTypes(channel.type);
      return discordSort(this.channels.cache.filter(({ parentId, type }) => types.includes(type) && (channelIsCategory || parentId === channel.parentId)));
    }
  }
  exports.Guild = Guild;
});

// node_modules/discord.js/src/structures/OAuth2Guild.js
var require_OAuth2Guild = __commonJS((exports, module) => {
  var BaseGuild = require_BaseGuild();
  var PermissionsBitField = require_PermissionsBitField();

  class OAuth2Guild extends BaseGuild {
    constructor(client, data) {
      super(client, data);
      this.owner = data.owner;
      this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();
    }
  }
  module.exports = OAuth2Guild;
});

// node_modules/discord.js/src/managers/GuildManager.js
var require_GuildManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { Collection } = require_dist7();
  var { makeURLSearchParams } = require_dist6();
  var { Routes, RouteBases } = require_v106();
  var CachedManager = require_CachedManager();
  var ShardClientUtil = require_ShardClientUtil();
  var { Guild } = require_Guild();
  var GuildChannel = require_GuildChannel();
  var GuildEmoji = require_GuildEmoji();
  var { GuildMember } = require_GuildMember();
  var Invite = require_Invite();
  var OAuth2Guild = require_OAuth2Guild();
  var { Role } = require_Role();
  var DataResolver = require_DataResolver();
  var Events = require_Events();
  var PermissionsBitField = require_PermissionsBitField();
  var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  var { resolveColor } = require_Util();
  var cacheWarningEmitted = false;

  class GuildManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Guild, iterable);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
    }
    resolve(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {
        return super.resolve(guild.guild);
      }
      return super.resolve(guild);
    }
    resolveId(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {
        return super.resolveId(guild.guild.id);
      }
      return super.resolveId(guild);
    }
    async create({
      name,
      icon = null,
      verificationLevel,
      defaultMessageNotifications,
      explicitContentFilter,
      roles = [],
      channels = [],
      afkChannelId,
      afkTimeout,
      systemChannelId,
      systemChannelFlags
    }) {
      const data = await this.client.rest.post(Routes.guilds(), {
        body: {
          name,
          icon: icon && await DataResolver.resolveImage(icon),
          verification_level: verificationLevel,
          default_message_notifications: defaultMessageNotifications,
          explicit_content_filter: explicitContentFilter,
          roles: roles.map(({ color, permissions, ...options }) => ({
            ...options,
            color: color && resolveColor(color),
            permissions: permissions === undefined ? undefined : PermissionsBitField.resolve(permissions).toString()
          })),
          channels: channels.map(({
            parentId,
            userLimit,
            rtcRegion,
            videoQualityMode,
            permissionOverwrites,
            rateLimitPerUser,
            ...options
          }) => ({
            ...options,
            parent_id: parentId,
            user_limit: userLimit,
            rtc_region: rtcRegion,
            video_quality_mode: videoQualityMode,
            permission_overwrites: permissionOverwrites?.map(({ allow, deny, ...permissionOverwriteOptions }) => ({
              ...permissionOverwriteOptions,
              allow: allow === undefined ? undefined : PermissionsBitField.resolve(allow).toString(),
              deny: deny === undefined ? undefined : PermissionsBitField.resolve(deny).toString()
            })),
            rate_limit_per_user: rateLimitPerUser
          })),
          afk_channel_id: afkChannelId,
          afk_timeout: afkTimeout,
          system_channel_id: systemChannelId,
          system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags)
        }
      });
      return this.client.guilds.cache.get(data.id) ?? new Promise((resolve) => {
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            clearTimeout2(timeout);
            this.client.decrementMaxListeners();
            resolve(guild);
          }
        };
        this.client.incrementMaxListeners();
        this.client.once(Events.GuildCreate, handleGuild);
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.GuildCreate, handleGuild);
          this.client.decrementMaxListeners();
          resolve(this.client.guilds._add(data));
        }, 1e4).unref();
      });
    }
    async fetch(options = {}) {
      const id = this.resolveId(options) ?? this.resolveId(options.guild);
      if (id) {
        if (!options.force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data2 = await this.client.rest.get(Routes.guild(id), {
          query: makeURLSearchParams({ with_counts: options.withCounts ?? true })
        });
        data2.shardId = ShardClientUtil.shardIdForGuildId(id, this.client.options.shardCount);
        return this._add(data2, options.cache);
      }
      const data = await this.client.rest.get(Routes.userGuilds(), { query: makeURLSearchParams(options) });
      return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection);
    }
    widgetImageURL(guild, style) {
      const urlSearchParams = String(makeURLSearchParams({ style }));
      return `${RouteBases.api}${Routes.guildWidgetImage(this.resolveId(guild))}${urlSearchParams ? `?${urlSearchParams}` : ""}`;
    }
  }
  module.exports = GuildManager;
});

// node_modules/discord.js/src/managers/UserManager.js
var require_UserManager = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var { GuildMember } = require_GuildMember();
  var { Message } = require_Message();
  var ThreadMember = require_ThreadMember();
  var User = require_User();

  class UserManager extends CachedManager {
    constructor(client, iterable) {
      super(client, User, iterable);
    }
    dmChannel(userId) {
      return this.client.channels.cache.find((channel) => channel.type === ChannelType.DM && channel.recipientId === userId) ?? null;
    }
    async createDM(user, { cache = true, force = false } = {}) {
      const id = this.resolveId(user);
      if (!force) {
        const dmChannel = this.dmChannel(id);
        if (dmChannel && !dmChannel.partial)
          return dmChannel;
      }
      const data = await this.client.rest.post(Routes.userChannels(), { body: { recipient_id: id } });
      return this.client.channels._add(data, null, { cache });
    }
    async deleteDM(user) {
      const id = this.resolveId(user);
      const dmChannel = this.dmChannel(id);
      if (!dmChannel)
        throw new DiscordjsError(ErrorCodes.UserNoDMChannel);
      await this.client.rest.delete(Routes.channel(dmChannel.id));
      this.client.channels._remove(dmChannel.id);
      return dmChannel;
    }
    async fetch(user, { cache = true, force = false } = {}) {
      const id = this.resolveId(user);
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.user(id));
      return this._add(data, cache);
    }
    async fetchFlags(user, options) {
      return (await this.fetch(user, options)).flags;
    }
    async send(user, options) {
      return (await this.createDM(user)).send(options);
    }
    resolve(user) {
      if (user instanceof GuildMember || user instanceof ThreadMember)
        return user.user;
      if (user instanceof Message)
        return user.author;
      return super.resolve(user);
    }
    resolveId(user) {
      if (user instanceof ThreadMember)
        return user.id;
      if (user instanceof GuildMember)
        return user.user.id;
      if (user instanceof Message)
        return user.author.id;
      return super.resolveId(user);
    }
  }
  module.exports = UserManager;
});

// node_modules/discord.js/src/structures/ClientPresence.js
var require_ClientPresence = __commonJS((exports, module) => {
  var { GatewayOpcodes, ActivityType } = require_v106();
  var { Presence } = require_Presence();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class ClientPresence extends Presence {
    constructor(client, data = {}) {
      super(client, Object.assign(data, { status: data.status ?? "online", user: { id: null } }));
    }
    set(presence) {
      const packet = this._parse(presence);
      this._patch(packet);
      if (presence.shardId === undefined) {
        this.client.ws.broadcast({ op: GatewayOpcodes.PresenceUpdate, d: packet });
      } else if (Array.isArray(presence.shardId)) {
        for (const shardId of presence.shardId) {
          this.client.ws.shards.get(shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
        }
      } else {
        this.client.ws.shards.get(presence.shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
      }
      return this;
    }
    _parse({ status, since, afk, activities }) {
      const data = {
        activities: [],
        afk: typeof afk === "boolean" ? afk : false,
        since: typeof since === "number" && !Number.isNaN(since) ? since : null,
        status: status ?? this.status
      };
      if (activities?.length) {
        for (const [i, activity] of activities.entries()) {
          if (typeof activity.name !== "string") {
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, `activities[${i}].name`, "string");
          }
          activity.type ??= ActivityType.Playing;
          if (activity.type === ActivityType.Custom && !activity.state) {
            activity.state = activity.name;
            activity.name = "Custom Status";
          }
          data.activities.push({
            type: activity.type,
            name: activity.name,
            state: activity.state,
            url: activity.url
          });
        }
      } else if (!activities && (status || afk || since) && this.activities.length) {
        data.activities.push(...this.activities.map((activity) => ({
          name: activity.name,
          state: activity.state ?? undefined,
          type: activity.type,
          url: activity.url ?? undefined
        })));
      }
      return data;
    }
  }
  module.exports = ClientPresence;
});

// node_modules/discord.js/src/structures/StickerPack.js
var require_StickerPack = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();
  var { Sticker } = require_Sticker();

  class StickerPack extends Base {
    constructor(client, pack) {
      super(client);
      this.id = pack.id;
      this.stickers = new Collection(pack.stickers.map((sticker) => [sticker.id, new Sticker(client, sticker)]));
      this.name = pack.name;
      this.skuId = pack.sku_id;
      this.coverStickerId = pack.cover_sticker_id ?? null;
      this.description = pack.description;
      this.bannerId = pack.banner_asset_id ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get coverSticker() {
      return this.coverStickerId && this.stickers.get(this.coverStickerId);
    }
    bannerURL(options = {}) {
      return this.bannerId && this.client.rest.cdn.stickerPackBanner(this.bannerId, options);
    }
  }
  module.exports = StickerPack;
});

// node_modules/discord.js/src/structures/VoiceRegion.js
var require_VoiceRegion = __commonJS((exports, module) => {
  var { flatten } = require_Util();

  class VoiceRegion {
    constructor(data) {
      this.id = data.id;
      this.name = data.name;
      this.deprecated = data.deprecated;
      this.optimal = data.optimal;
      this.custom = data.custom;
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = VoiceRegion;
});

// node_modules/discord.js/src/structures/WidgetMember.js
var require_WidgetMember = __commonJS((exports, module) => {
  var Base = require_Base();

  class WidgetMember extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.username = data.username;
      this.discriminator = data.discriminator;
      this.avatar = data.avatar;
      this.status = data.status;
      this.deaf = data.deaf ?? null;
      this.mute = data.mute ?? null;
      this.selfDeaf = data.self_deaf ?? null;
      this.selfMute = data.self_mute ?? null;
      this.suppress = data.suppress ?? null;
      this.channelId = data.channel_id ?? null;
      this.avatarURL = data.avatar_url;
      this.activity = data.activity ?? null;
    }
  }
  module.exports = WidgetMember;
});

// node_modules/discord.js/src/structures/Widget.js
var require_Widget = __commonJS((exports, module) => {
  var { Collection } = require_dist7();
  var { Routes } = require_v106();
  var Base = require_Base();
  var WidgetMember = require_WidgetMember();

  class Widget extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("instant_invite" in data) {
        this.instantInvite = data.instant_invite;
      }
      this.channels = new Collection;
      for (const channel of data.channels) {
        this.channels.set(channel.id, channel);
      }
      this.members = new Collection;
      for (const member of data.members) {
        this.members.set(member.id, new WidgetMember(this.client, member));
      }
      if ("presence_count" in data) {
        this.presenceCount = data.presence_count;
      }
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guildWidgetJSON(this.id));
      this._patch(data);
      return this;
    }
    imageURL(style) {
      return this.client.guilds.widgetImageURL(this.id, style);
    }
  }
  module.exports = Widget;
});

// node_modules/discord.js/src/util/IntentsBitField.js
var require_IntentsBitField = __commonJS((exports, module) => {
  var { GatewayIntentBits } = require_v106();
  var BitField = require_BitField();

  class IntentsBitField extends BitField {
    static Flags = GatewayIntentBits;
  }
  module.exports = IntentsBitField;
});

// node_modules/discord.js/src/util/Sweepers.js
var require_Sweepers = __commonJS((exports, module) => {
  var { setInterval: setInterval2, clearInterval: clearInterval2 } = __require("node:timers");
  var { ThreadChannelTypes, SweeperKeys } = require_Constants();
  var Events = require_Events();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class Sweepers {
    constructor(client, options) {
      Object.defineProperty(this, "client", { value: client });
      this.options = options;
      this.intervals = Object.fromEntries(SweeperKeys.map((key) => [key, null]));
      for (const key of SweeperKeys) {
        if (!(key in options))
          continue;
        this._validateProperties(key);
        const clonedOptions = { ...this.options[key] };
        if (!("filter" in clonedOptions)) {
          switch (key) {
            case "invites":
              clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);
              break;
            case "messages":
              clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);
              break;
            case "threads":
              clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);
          }
        }
        this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);
      }
    }
    sweepApplicationCommands(filter) {
      const { guilds, items: guildCommands } = this._sweepGuildDirectProp("commands", filter, { emit: false });
      const globalCommands = this.client.application?.commands.cache.sweep(filter) ?? 0;
      this.client.emit(Events.CacheSweep, `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`);
      return guildCommands + globalCommands;
    }
    sweepAutoModerationRules(filter) {
      return this._sweepGuildDirectProp("autoModerationRules", filter).items;
    }
    sweepBans(filter) {
      return this._sweepGuildDirectProp("bans", filter).items;
    }
    sweepEmojis(filter) {
      return this._sweepGuildDirectProp("emojis", filter).items;
    }
    sweepInvites(filter) {
      return this._sweepGuildDirectProp("invites", filter).items;
    }
    sweepGuildMembers(filter) {
      return this._sweepGuildDirectProp("members", filter, { outputName: "guild members" }).items;
    }
    sweepMessages(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let channels = 0;
      let messages = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!channel.isTextBased())
          continue;
        channels++;
        messages += channel.messages.cache.sweep(filter);
      }
      this.client.emit(Events.CacheSweep, `Swept ${messages} messages in ${channels} text-based channels.`);
      return messages;
    }
    sweepPresences(filter) {
      return this._sweepGuildDirectProp("presences", filter).items;
    }
    sweepReactions(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let channels = 0;
      let messages = 0;
      let reactions = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!channel.isTextBased())
          continue;
        channels++;
        for (const message of channel.messages.cache.values()) {
          messages++;
          reactions += message.reactions.cache.sweep(filter);
        }
      }
      this.client.emit(Events.CacheSweep, `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`);
      return reactions;
    }
    sweepStageInstances(filter) {
      return this._sweepGuildDirectProp("stageInstances", filter, { outputName: "stage instances" }).items;
    }
    sweepStickers(filter) {
      return this._sweepGuildDirectProp("stickers", filter).items;
    }
    sweepThreadMembers(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let threads = 0;
      let members = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!ThreadChannelTypes.includes(channel.type))
          continue;
        threads++;
        members += channel.members.cache.sweep(filter);
      }
      this.client.emit(Events.CacheSweep, `Swept ${members} thread members in ${threads} threads.`);
      return members;
    }
    sweepThreads(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let threads = 0;
      for (const [key, val] of this.client.channels.cache.entries()) {
        if (!ThreadChannelTypes.includes(val.type))
          continue;
        if (filter(val, key, this.client.channels.cache)) {
          threads++;
          this.client.channels._remove(key);
        }
      }
      this.client.emit(Events.CacheSweep, `Swept ${threads} threads.`);
      return threads;
    }
    sweepUsers(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      const users = this.client.users.cache.sweep(filter);
      this.client.emit(Events.CacheSweep, `Swept ${users} users.`);
      return users;
    }
    sweepVoiceStates(filter) {
      return this._sweepGuildDirectProp("voiceStates", filter, { outputName: "voice states" }).items;
    }
    destroy() {
      for (const key of SweeperKeys) {
        if (this.intervals[key])
          clearInterval2(this.intervals[key]);
      }
    }
    static filterByLifetime({
      lifetime = 14400,
      getComparisonTimestamp = (e) => e?.createdTimestamp,
      excludeFromSweep = () => false
    } = {}) {
      if (typeof lifetime !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "lifetime", "number");
      }
      if (typeof getComparisonTimestamp !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "getComparisonTimestamp", "function");
      }
      if (typeof excludeFromSweep !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "excludeFromSweep", "function");
      }
      return () => {
        if (lifetime <= 0)
          return null;
        const lifetimeMs = lifetime * 1000;
        const now = Date.now();
        return (entry, key, coll) => {
          if (excludeFromSweep(entry, key, coll)) {
            return false;
          }
          const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);
          if (!comparisonTimestamp || typeof comparisonTimestamp !== "number")
            return false;
          return now - comparisonTimestamp > lifetimeMs;
        };
      };
    }
    static archivedThreadSweepFilter(lifetime = 14400) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (e) => e.archiveTimestamp,
        excludeFromSweep: (e) => !e.archived
      });
    }
    static expiredInviteSweepFilter(lifetime = 14400) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (i) => i.expiresTimestamp
      });
    }
    static outdatedMessageSweepFilter(lifetime = 3600) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (m) => m.editedTimestamp ?? m.createdTimestamp
      });
    }
    _sweepGuildDirectProp(key, filter, { emit = true, outputName } = {}) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let guilds = 0;
      let items = 0;
      for (const guild of this.client.guilds.cache.values()) {
        const { cache } = guild[key];
        guilds++;
        items += cache.sweep(filter);
      }
      if (emit) {
        this.client.emit(Events.CacheSweep, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);
      }
      return { guilds, items };
    }
    _validateProperties(key) {
      const props = this.options[key];
      if (typeof props !== "object") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}`, "object", true);
      }
      if (typeof props.interval !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.interval`, "number");
      }
      if (["invites", "messages", "threads"].includes(key) && !("filter" in props)) {
        if (typeof props.lifetime !== "number") {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.lifetime`, "number");
        }
        return;
      }
      if (typeof props.filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.filter`, "function");
      }
    }
    _initInterval(intervalKey, sweepKey, opts) {
      if (opts.interval <= 0 || opts.interval === Infinity)
        return;
      this.intervals[intervalKey] = setInterval2(() => {
        const sweepFn = opts.filter();
        if (sweepFn === null)
          return;
        if (typeof sweepFn !== "function")
          throw new DiscordjsTypeError(ErrorCodes.SweepFilterReturn);
        this[sweepKey](sweepFn);
      }, opts.interval * 1000).unref();
    }
  }
  module.exports = Sweepers;
});

// node_modules/discord.js/src/client/Client.js
var require_Client = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist7();
  var { makeURLSearchParams } = require_dist6();
  var { OAuth2Scopes, Routes } = require_v106();
  var BaseClient = require_BaseClient();
  var ActionsManager = require_ActionsManager();
  var ClientVoiceManager = require_ClientVoiceManager();
  var WebSocketManager = require_WebSocketManager();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors2();
  var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  var ChannelManager = require_ChannelManager();
  var GuildManager = require_GuildManager();
  var UserManager = require_UserManager();
  var ShardClientUtil = require_ShardClientUtil();
  var ClientPresence = require_ClientPresence();
  var GuildPreview = require_GuildPreview();
  var GuildTemplate = require_GuildTemplate();
  var Invite = require_Invite();
  var { Sticker } = require_Sticker();
  var StickerPack = require_StickerPack();
  var VoiceRegion = require_VoiceRegion();
  var Webhook = require_Webhook();
  var Widget = require_Widget();
  var DataResolver = require_DataResolver();
  var Events = require_Events();
  var IntentsBitField = require_IntentsBitField();
  var Options = require_Options();
  var PermissionsBitField = require_PermissionsBitField();
  var Status = require_Status();
  var Sweepers = require_Sweepers();
  var deprecationEmittedForPremiumStickerPacks = false;

  class Client extends BaseClient {
    constructor(options) {
      super(options);
      const data = __require("node:worker_threads").workerData ?? process2.env;
      const defaults = Options.createDefault();
      if (this.options.shards === defaults.shards) {
        if ("SHARDS" in data) {
          this.options.shards = JSON.parse(data.SHARDS);
        }
      }
      if (this.options.shardCount === defaults.shardCount) {
        if ("SHARD_COUNT" in data) {
          this.options.shardCount = Number(data.SHARD_COUNT);
        } else if (Array.isArray(this.options.shards)) {
          this.options.shardCount = this.options.shards.length;
        }
      }
      const typeofShards = typeof this.options.shards;
      if (typeofShards === "undefined" && typeof this.options.shardCount === "number") {
        this.options.shards = Array.from({ length: this.options.shardCount }, (_, i) => i);
      }
      if (typeofShards === "number")
        this.options.shards = [this.options.shards];
      if (Array.isArray(this.options.shards)) {
        this.options.shards = [
          ...new Set(this.options.shards.filter((item) => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)))
        ];
      }
      this._validateOptions();
      this.ws = new WebSocketManager(this);
      this.actions = new ActionsManager(this);
      this.voice = new ClientVoiceManager(this);
      this.shard = process2.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process2.env.SHARDING_MANAGER_MODE) : null;
      this.users = new UserManager(this);
      this.guilds = new GuildManager(this);
      this.channels = new ChannelManager(this);
      this.sweepers = new Sweepers(this, this.options.sweepers);
      this.presence = new ClientPresence(this, this.options.presence);
      Object.defineProperty(this, "token", { writable: true });
      if (!this.token && "DISCORD_TOKEN" in process2.env) {
        this.token = process2.env.DISCORD_TOKEN;
      } else {
        this.token = null;
      }
      this.user = null;
      this.application = null;
      this.readyTimestamp = null;
    }
    get emojis() {
      const emojis = new BaseGuildEmojiManager(this);
      for (const guild of this.guilds.cache.values()) {
        if (guild.available)
          for (const emoji of guild.emojis.cache.values())
            emojis.cache.set(emoji.id, emoji);
      }
      return emojis;
    }
    get readyAt() {
      return this.readyTimestamp && new Date(this.readyTimestamp);
    }
    get uptime() {
      return this.readyTimestamp && Date.now() - this.readyTimestamp;
    }
    async login(token = this.token) {
      if (!token || typeof token !== "string")
        throw new DiscordjsError(ErrorCodes.TokenInvalid);
      this.token = token = token.replace(/^(Bot|Bearer)\s*/i, "");
      this.rest.setToken(token);
      this.emit(Events.Debug, `Provided token: ${this._censoredToken}`);
      if (this.options.presence) {
        this.options.ws.presence = this.presence._parse(this.options.presence);
      }
      this.emit(Events.Debug, "Preparing to connect to the gateway...");
      try {
        await this.ws.connect();
        return this.token;
      } catch (error) {
        await this.destroy();
        throw error;
      }
    }
    isReady() {
      return !this.ws.destroyed && this.ws.status === Status.Ready;
    }
    async destroy() {
      super.destroy();
      this.sweepers.destroy();
      await this.ws.destroy();
      this.token = null;
      this.rest.setToken(null);
    }
    async fetchInvite(invite, options) {
      const code = DataResolver.resolveInviteCode(invite);
      const query = makeURLSearchParams({
        with_counts: true,
        with_expiration: true,
        guild_scheduled_event_id: options?.guildScheduledEventId
      });
      const data = await this.rest.get(Routes.invite(code), { query });
      return new Invite(this, data);
    }
    async fetchGuildTemplate(template) {
      const code = DataResolver.resolveGuildTemplateCode(template);
      const data = await this.rest.get(Routes.template(code));
      return new GuildTemplate(this, data);
    }
    async fetchWebhook(id, token) {
      const data = await this.rest.get(Routes.webhook(id, token), { auth: token === undefined });
      return new Webhook(this, { token, ...data });
    }
    async fetchVoiceRegions() {
      const apiRegions = await this.rest.get(Routes.voiceRegions());
      const regions = new Collection;
      for (const region of apiRegions)
        regions.set(region.id, new VoiceRegion(region));
      return regions;
    }
    async fetchSticker(id) {
      const data = await this.rest.get(Routes.sticker(id));
      return new Sticker(this, data);
    }
    async fetchStickerPacks() {
      const data = await this.rest.get(Routes.stickerPacks());
      return new Collection(data.sticker_packs.map((stickerPack) => [stickerPack.id, new StickerPack(this, stickerPack)]));
    }
    fetchPremiumStickerPacks() {
      if (!deprecationEmittedForPremiumStickerPacks) {
        process2.emitWarning("The Client#fetchPremiumStickerPacks() method is deprecated. Use Client#fetchStickerPacks() instead.", "DeprecationWarning");
        deprecationEmittedForPremiumStickerPacks = true;
      }
      return this.fetchStickerPacks();
    }
    async fetchGuildPreview(guild) {
      const id = this.guilds.resolveId(guild);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
      const data = await this.rest.get(Routes.guildPreview(id));
      return new GuildPreview(this, data);
    }
    async fetchGuildWidget(guild) {
      const id = this.guilds.resolveId(guild);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
      const data = await this.rest.get(Routes.guildWidgetJSON(id));
      return new Widget(this, data);
    }
    generateInvite(options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      if (!this.application)
        throw new DiscordjsError(ErrorCodes.ClientNotReady, "generate an invite link");
      const { scopes } = options;
      if (scopes === undefined) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
      }
      if (!Array.isArray(scopes)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "scopes", "Array of Invite Scopes", true);
      }
      if (!scopes.some((scope) => [OAuth2Scopes.Bot, OAuth2Scopes.ApplicationsCommands].includes(scope))) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
      }
      if (!scopes.includes(OAuth2Scopes.Bot) && options.permissions) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidScopesWithPermissions);
      }
      const validScopes = Object.values(OAuth2Scopes);
      const invalidScope = scopes.find((scope) => !validScopes.includes(scope));
      if (invalidScope) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "scopes", invalidScope);
      }
      const query = makeURLSearchParams({
        client_id: this.application.id,
        scope: scopes.join(" "),
        disable_guild_select: options.disableGuildSelect
      });
      if (options.permissions) {
        const permissions = PermissionsBitField.resolve(options.permissions);
        if (permissions)
          query.set("permissions", permissions.toString());
      }
      if (options.guild) {
        const guildId = this.guilds.resolveId(options.guild);
        if (!guildId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.guild", "GuildResolvable");
        query.set("guild_id", guildId);
      }
      return `${this.options.rest.api}${Routes.oauth2Authorization()}?${query}`;
    }
    toJSON() {
      return super.toJSON({
        actions: false,
        presence: false
      });
    }
    get _censoredToken() {
      if (!this.token)
        return null;
      return this.token.split(".").map((val, i) => i > 1 ? val.replace(/./g, "*") : val).join(".");
    }
    _eval(script) {
      return eval(script);
    }
    _validateOptions(options = this.options) {
      if (options.intents === undefined) {
        throw new DiscordjsTypeError(ErrorCodes.ClientMissingIntents);
      } else {
        options.intents = new IntentsBitField(options.intents).freeze();
      }
      if (typeof options.shardCount !== "number" || isNaN(options.shardCount) || options.shardCount < 1) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardCount", "a number greater than or equal to 1");
      }
      if (options.shards && !(options.shards === "auto" || Array.isArray(options.shards))) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shards", "'auto', a number or array of numbers");
      }
      if (options.shards && !options.shards.length)
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidProvidedShards);
      if (typeof options.makeCache !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "makeCache", "a function");
      }
      if (typeof options.sweepers !== "object" || options.sweepers === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "sweepers", "an object");
      }
      if (!Array.isArray(options.partials)) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "partials", "an Array");
      }
      if (typeof options.waitGuildTimeout !== "number" || isNaN(options.waitGuildTimeout)) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "waitGuildTimeout", "a number");
      }
      if (typeof options.failIfNotExists !== "boolean") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "failIfNotExists", "a boolean");
      }
      if (typeof options.allowedMentions !== "object" && options.allowedMentions !== undefined || options.allowedMentions === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "allowedMentions", "an object");
      }
      if (typeof options.presence !== "object" || options.presence === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "presence", "an object");
      }
      if (typeof options.ws !== "object" || options.ws === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "ws", "an object");
      }
      if (typeof options.rest !== "object" || options.rest === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "rest", "an object");
      }
      if (typeof options.jsonTransformer !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "jsonTransformer", "a function");
      }
    }
  }
  module.exports = Client;
});

// node_modules/discord.js/src/util/ShardEvents.js
var require_ShardEvents = __commonJS((exports, module) => {
  module.exports = {
    Death: "death",
    Disconnect: "disconnect",
    Error: "error",
    Message: "message",
    Ready: "ready",
    Reconnecting: "reconnecting",
    Resume: "resume",
    Spawn: "spawn"
  };
});

// node_modules/discord.js/src/sharding/Shard.js
var require_Shard = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var path = __require("node:path");
  var process2 = __require("node:process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { setTimeout: sleep } = __require("node:timers/promises");
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var ShardEvents = require_ShardEvents();
  var { makeError, makePlainError } = require_Util();
  var childProcess = null;
  var Worker = null;

  class Shard extends EventEmitter {
    constructor(manager, id) {
      super();
      switch (manager.mode) {
        case "process":
          childProcess = __require("node:child_process");
          break;
        case "worker":
          Worker = __require("node:worker_threads").Worker;
          break;
      }
      this.manager = manager;
      this.id = id;
      this.silent = manager.silent;
      this.args = manager.shardArgs ?? [];
      this.execArgv = manager.execArgv;
      this.env = Object.assign({}, process2.env, {
        SHARDING_MANAGER: true,
        SHARDS: this.id,
        SHARD_COUNT: this.manager.totalShards,
        DISCORD_TOKEN: this.manager.token
      });
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals = new Map;
      this._fetches = new Map;
      this._exitListener = null;
    }
    spawn(timeout = 30000) {
      if (this.process)
        throw new DiscordjsError(ErrorCodes.ShardingProcessExists, this.id);
      if (this.worker)
        throw new DiscordjsError(ErrorCodes.ShardingWorkerExists, this.id);
      this._exitListener = this._handleExit.bind(this, undefined, timeout);
      switch (this.manager.mode) {
        case "process":
          this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {
            env: this.env,
            execArgv: this.execArgv,
            silent: this.silent
          }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
          break;
        case "worker":
          this.worker = new Worker(path.resolve(this.manager.file), { workerData: this.env }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
          break;
      }
      this._evals.clear();
      this._fetches.clear();
      const child = this.process ?? this.worker;
      this.emit(ShardEvents.Spawn, child);
      if (timeout === -1 || timeout === Infinity)
        return Promise.resolve(child);
      return new Promise((resolve, reject) => {
        const cleanup = () => {
          clearTimeout2(spawnTimeoutTimer);
          this.off("ready", onReady);
          this.off("disconnect", onDisconnect);
          this.off("death", onDeath);
        };
        const onReady = () => {
          cleanup();
          resolve(child);
        };
        const onDisconnect = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyDisconnected, this.id));
        };
        const onDeath = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyDied, this.id));
        };
        const onTimeout = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyTimeout, this.id));
        };
        const spawnTimeoutTimer = setTimeout2(onTimeout, timeout);
        this.once("ready", onReady);
        this.once("disconnect", onDisconnect);
        this.once("death", onDeath);
      });
    }
    kill() {
      if (this.process) {
        this.process.removeListener("exit", this._exitListener);
        this.process.kill();
      } else {
        this.worker.removeListener("exit", this._exitListener);
        this.worker.terminate();
      }
      this._handleExit(false);
    }
    async respawn({ delay = 500, timeout = 30000 } = {}) {
      this.kill();
      if (delay > 0)
        await sleep(delay);
      return this.spawn(timeout);
    }
    send(message) {
      return new Promise((resolve, reject) => {
        if (this.process) {
          this.process.send(message, (err) => {
            if (err)
              reject(err);
            else
              resolve(this);
          });
        } else {
          this.worker.postMessage(message);
          resolve(this);
        }
      });
    }
    fetchClientValue(prop) {
      if (!this.process && !this.worker) {
        return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));
      }
      if (this._fetches.has(prop))
        return this._fetches.get(prop);
      const promise = new Promise((resolve, reject) => {
        const child = this.process ?? this.worker;
        const listener = (message) => {
          if (message?._fetchProp !== prop)
            return;
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._fetches.delete(prop);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(child);
        child.on("message", listener);
        this.send({ _fetchProp: prop }).catch((err) => {
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._fetches.delete(prop);
          reject(err);
        });
      });
      this._fetches.set(prop, promise);
      return promise;
    }
    eval(script2, context) {
      const _eval = typeof script2 === "function" ? `(${script2})(this, ${JSON.stringify(context)})` : script2;
      if (!this.process && !this.worker) {
        return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));
      }
      if (this._evals.has(_eval))
        return this._evals.get(_eval);
      const promise = new Promise((resolve, reject) => {
        const child = this.process ?? this.worker;
        const listener = (message) => {
          if (message?._eval !== _eval)
            return;
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._evals.delete(_eval);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(child);
        child.on("message", listener);
        this.send({ _eval }).catch((err) => {
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._evals.delete(_eval);
          reject(err);
        });
      });
      this._evals.set(_eval, promise);
      return promise;
    }
    _handleMessage(message) {
      if (message) {
        if (message._ready) {
          this.ready = true;
          this.emit(ShardEvents.Ready);
          return;
        }
        if (message._disconnect) {
          this.ready = false;
          this.emit(ShardEvents.Disconnect);
          return;
        }
        if (message._reconnecting) {
          this.ready = false;
          this.emit(ShardEvents.Reconnecting);
          return;
        }
        if (message._resume) {
          this.ready = true;
          this.emit(ShardEvents.Resume);
          return;
        }
        if (message._sFetchProp) {
          const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };
          this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then((results) => this.send({ ...resp, _result: results }), (err) => this.send({ ...resp, _error: makePlainError(err) }));
          return;
        }
        if (message._sEval) {
          const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };
          this.manager._performOnShards("eval", [message._sEval], message._sEvalShard).then((results) => this.send({ ...resp, _result: results }), (err) => this.send({ ...resp, _error: makePlainError(err) }));
          return;
        }
        if (message._sRespawnAll) {
          const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;
          this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {
          });
          return;
        }
      }
      this.emit(ShardEvents.Message, message);
    }
    _handleExit(respawn = this.manager.respawn, timeout) {
      this.emit(ShardEvents.Death, this.process ?? this.worker);
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals.clear();
      this._fetches.clear();
      if (respawn)
        this.spawn(timeout).catch((err) => this.emit(ShardEvents.Error, err));
    }
    incrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners - 1);
      }
    }
  }
  module.exports = Shard;
});

// node_modules/discord.js/src/sharding/ShardingManager.js
var require_ShardingManager = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var fs = __require("node:fs");
  var path = __require("node:path");
  var process2 = __require("node:process");
  var { setTimeout: sleep } = __require("node:timers/promises");
  var { Collection } = require_dist7();
  var Shard = require_Shard();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors2();
  var { fetchRecommendedShardCount } = require_Util();

  class ShardingManager extends EventEmitter {
    constructor(file, options) {
      super();
      const _options = {
        totalShards: "auto",
        mode: "process",
        respawn: true,
        silent: false,
        shardArgs: [],
        execArgv: [],
        token: process2.env.DISCORD_TOKEN,
        ...options
      };
      this.file = file;
      if (!file)
        throw new DiscordjsError(ErrorCodes.ClientInvalidOption, "File", "specified.");
      if (!path.isAbsolute(file))
        this.file = path.resolve(process2.cwd(), file);
      const stats = fs.statSync(this.file);
      if (!stats.isFile())
        throw new DiscordjsError(ErrorCodes.ClientInvalidOption, "File", "a file");
      this.shardList = _options.shardList ?? "auto";
      if (this.shardList !== "auto") {
        if (!Array.isArray(this.shardList)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardList", "an array.");
        }
        this.shardList = [...new Set(this.shardList)];
        if (this.shardList.length < 1) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "shardList", "at least 1 id.");
        }
        if (this.shardList.some((shardId) => typeof shardId !== "number" || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardList", "an array of positive integers.");
        }
      }
      this.totalShards = _options.totalShards || "auto";
      if (this.totalShards !== "auto") {
        if (typeof this.totalShards !== "number" || isNaN(this.totalShards)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "a number.");
        }
        if (this.totalShards < 1) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "at least 1.");
        }
        if (!Number.isInteger(this.totalShards)) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "an integer.");
        }
      }
      this.mode = _options.mode;
      if (this.mode !== "process" && this.mode !== "worker") {
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Sharding mode", '"process" or "worker"');
      }
      this.respawn = _options.respawn;
      this.silent = _options.silent;
      this.shardArgs = _options.shardArgs;
      this.execArgv = _options.execArgv;
      this.token = _options.token?.replace(/^Bot\s*/i, "") ?? null;
      this.shards = new Collection;
      process2.env.SHARDING_MANAGER = true;
      process2.env.SHARDING_MANAGER_MODE = this.mode;
      process2.env.DISCORD_TOKEN = this.token;
    }
    createShard(id = this.shards.size) {
      const shard = new Shard(this, id);
      this.shards.set(id, shard);
      this.emit("shardCreate", shard);
      return shard;
    }
    async spawn({ amount = this.totalShards, delay = 5500, timeout = 30000 } = {}) {
      if (amount === "auto") {
        amount = await fetchRecommendedShardCount(this.token);
      } else {
        if (typeof amount !== "number" || isNaN(amount)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "a number.");
        }
        if (amount < 1)
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "at least 1.");
        if (!Number.isInteger(amount)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "an integer.");
        }
      }
      if (this.shards.size >= amount)
        throw new DiscordjsError(ErrorCodes.ShardingAlreadySpawned, this.shards.size);
      if (this.shardList === "auto" || this.totalShards === "auto" || this.totalShards !== amount) {
        this.shardList = [...Array(amount).keys()];
      }
      if (this.totalShards === "auto" || this.totalShards !== amount) {
        this.totalShards = amount;
      }
      if (this.shardList.some((shardId) => shardId >= amount)) {
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "bigger than the highest shardId in the shardList option.");
      }
      for (const shardId of this.shardList) {
        const promises = [];
        const shard = this.createShard(shardId);
        promises.push(shard.spawn(timeout));
        if (delay > 0 && this.shards.size !== this.shardList.length)
          promises.push(sleep(delay));
        await Promise.all(promises);
      }
      return this.shards;
    }
    broadcast(message) {
      const promises = [];
      for (const shard of this.shards.values())
        promises.push(shard.send(message));
      return Promise.all(promises);
    }
    broadcastEval(script2, options = {}) {
      if (typeof script2 !== "function") {
        return Promise.reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));
      }
      return this._performOnShards("eval", [`(${script2})(this, ${JSON.stringify(options.context)})`], options.shard);
    }
    fetchClientValues(prop, shard) {
      return this._performOnShards("fetchClientValue", [prop], shard);
    }
    _performOnShards(method, args, shard) {
      if (this.shards.size === 0)
        return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoShards));
      if (typeof shard === "number") {
        if (this.shards.has(shard))
          return this.shards.get(shard)[method](...args);
        return Promise.reject(new DiscordjsError(ErrorCodes.ShardingShardNotFound, shard));
      }
      if (this.shards.size !== this.shardList.length) {
        return Promise.reject(new DiscordjsError(ErrorCodes.ShardingInProcess));
      }
      const promises = [];
      for (const sh of this.shards.values())
        promises.push(sh[method](...args));
      return Promise.all(promises);
    }
    async respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {
      let s = 0;
      for (const shard of this.shards.values()) {
        const promises = [shard.respawn({ delay: respawnDelay, timeout })];
        if (++s < this.shards.size && shardDelay > 0)
          promises.push(sleep(shardDelay));
        await Promise.all(promises);
      }
      return this.shards;
    }
  }
  module.exports = ShardingManager;
});

// node_modules/discord.js/src/util/Formatters.js
var require_Formatters = __commonJS((exports, module) => {
  var { deprecate } = __require("node:util");
  var {
    blockQuote,
    bold,
    channelMention,
    codeBlock,
    formatEmoji,
    hideLinkEmbed,
    hyperlink,
    inlineCode,
    italic,
    quote,
    roleMention,
    spoiler,
    strikethrough,
    time,
    TimestampStyles,
    underscore,
    userMention
  } = require_dist8();

  class Formatters extends null {
    static blockQuote = deprecate(blockQuote, "Formatters.blockQuote() is deprecated. Import this method directly from discord.js instead.");
    static bold = deprecate(bold, "Formatters.bold() is deprecated. Import this method directly from discord.js instead.");
    static channelMention = deprecate(channelMention, "Formatters.channelMention() is deprecated. Import this method directly from discord.js instead.");
    static codeBlock = deprecate(codeBlock, "Formatters.codeBlock() is deprecated. Import this method directly from discord.js instead.");
    static formatEmoji = deprecate(formatEmoji, "Formatters.formatEmoji() is deprecated. Import this method directly from discord.js instead.");
    static hideLinkEmbed = deprecate(hideLinkEmbed, "Formatters.hideLinkEmbed() is deprecated. Import this method directly from discord.js instead.");
    static hyperlink = deprecate(hyperlink, "Formatters.hyperlink() is deprecated. Import this method directly from discord.js instead.");
    static inlineCode = deprecate(inlineCode, "Formatters.inlineCode() is deprecated. Import this method directly from discord.js instead.");
    static italic = deprecate(italic, "Formatters.italic() is deprecated. Import this method directly from discord.js instead.");
    static quote = deprecate(quote, "Formatters.quote() is deprecated. Import this method directly from discord.js instead.");
    static roleMention = deprecate(roleMention, "Formatters.roleMention() is deprecated. Import this method directly from discord.js instead.");
    static spoiler = deprecate(spoiler, "Formatters.spoiler() is deprecated. Import this method directly from discord.js instead.");
    static strikethrough = deprecate(strikethrough, "Formatters.strikethrough() is deprecated. Import this method directly from discord.js instead.");
    static time = deprecate(time, "Formatters.time() is deprecated. Import this method directly from discord.js instead.");
    static TimestampStyles = TimestampStyles;
    static underscore = deprecate(underscore, "Formatters.underscore() is deprecated. Import this method directly from discord.js instead.");
    static userMention = deprecate(userMention, "Formatters.userMention() is deprecated. Import this method directly from discord.js instead.");
  }
  module.exports = Formatters;
});

// node_modules/discord.js/src/structures/EmbedBuilder.js
var require_EmbedBuilder = __commonJS((exports, module) => {
  var { EmbedBuilder: BuildersEmbed, embedLength } = require_dist9();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolveColor } = require_Util();

  class EmbedBuilder extends BuildersEmbed {
    constructor(data) {
      super(toSnakeCase(data));
    }
    setColor(color) {
      return super.setColor(color && resolveColor(color));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
    get length() {
      return embedLength(this.data);
    }
  }
  module.exports = EmbedBuilder;
});

// node_modules/discord.js/src/structures/AttachmentBuilder.js
var require_AttachmentBuilder = __commonJS((exports, module) => {
  var { basename, flatten } = require_Util();

  class AttachmentBuilder {
    constructor(attachment, data = {}) {
      this.attachment = attachment;
      this.name = data.name;
      this.description = data.description;
    }
    setDescription(description) {
      this.description = description;
      return this;
    }
    setFile(attachment) {
      this.attachment = attachment;
      return this;
    }
    setName(name) {
      this.name = name;
      return this;
    }
    setSpoiler(spoiler = true) {
      if (spoiler === this.spoiler)
        return this;
      if (!spoiler) {
        while (this.spoiler) {
          this.name = this.name.slice("SPOILER_".length);
        }
        return this;
      }
      this.name = `SPOILER_${this.name}`;
      return this;
    }
    get spoiler() {
      return basename(this.name).startsWith("SPOILER_");
    }
    toJSON() {
      return flatten(this);
    }
    static from(other) {
      return new AttachmentBuilder(other.attachment, {
        name: other.name,
        description: other.description
      });
    }
  }
  module.exports = AttachmentBuilder;
});

// node_modules/discord.js/src/structures/ModalBuilder.js
var require_ModalBuilder = __commonJS((exports, module) => {
  var { ModalBuilder: BuildersModal, ComponentBuilder } = require_dist9();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class ModalBuilder extends BuildersModal {
    constructor({ components, ...data } = {}) {
      super({
        ...toSnakeCase(data),
        components: components?.map((component) => component instanceof ComponentBuilder ? component : toSnakeCase(component))
      });
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ModalBuilder;
});

// node_modules/discord.js/src/structures/SelectMenuBuilder.js
var require_SelectMenuBuilder = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  var deprecationEmitted = false;

  class SelectMenuBuilder2 extends StringSelectMenuBuilder {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuBuilder class is deprecated. Use StringSelectMenuBuilder instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuBuilder2;
});

// node_modules/discord.js/src/structures/SelectMenuComponent.js
var require_SelectMenuComponent = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuComponent = require_StringSelectMenuComponent();
  var deprecationEmitted = false;

  class SelectMenuComponent extends StringSelectMenuComponent {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuComponent class is deprecated. Use StringSelectMenuComponent instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuComponent;
});

// node_modules/discord.js/src/structures/SelectMenuInteraction.js
var require_SelectMenuInteraction = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  var deprecationEmitted = false;

  class SelectMenuInteraction extends StringSelectMenuInteraction {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuInteraction class is deprecated. Use StringSelectMenuInteraction instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuInteraction;
});

// node_modules/discord.js/src/structures/StringSelectMenuOptionBuilder.js
var require_StringSelectMenuOptionBuilder = __commonJS((exports, module) => {
  var { SelectMenuOptionBuilder: BuildersSelectMenuOption } = require_dist9();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class StringSelectMenuOptionBuilder extends BuildersSelectMenuOption {
    constructor({ emoji, ...data } = {}) {
      super(toSnakeCase({
        ...data,
        emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
      }));
    }
    setEmoji(emoji) {
      if (typeof emoji === "string") {
        return super.setEmoji(resolvePartialEmoji(emoji));
      }
      return super.setEmoji(emoji);
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = StringSelectMenuOptionBuilder;
});

// node_modules/discord.js/src/structures/SelectMenuOptionBuilder.js
var require_SelectMenuOptionBuilder = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
  var deprecationEmitted = false;

  class SelectMenuOptionBuilder2 extends StringSelectMenuOptionBuilder {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuOptionBuilder class is deprecated. Use StringSelectMenuOptionBuilder instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuOptionBuilder2;
});

// node_modules/discord.js/src/index.js
var require_src = __commonJS((exports) => {
  var { __exportStar } = require_tslib();
  exports.BaseClient = require_BaseClient();
  exports.Client = require_Client();
  exports.Shard = require_Shard();
  exports.ShardClientUtil = require_ShardClientUtil();
  exports.ShardingManager = require_ShardingManager();
  exports.WebhookClient = require_WebhookClient();
  exports.DiscordjsError = require_DJSError().DiscordjsError;
  exports.DiscordjsTypeError = require_DJSError().DiscordjsTypeError;
  exports.DiscordjsRangeError = require_DJSError().DiscordjsRangeError;
  exports.DiscordjsErrorCodes = require_ErrorCodes();
  exports.ActivityFlagsBitField = require_ActivityFlagsBitField();
  exports.ApplicationFlagsBitField = require_ApplicationFlagsBitField();
  exports.AttachmentFlagsBitField = require_AttachmentFlagsBitField();
  exports.BaseManager = require_BaseManager();
  exports.BitField = require_BitField();
  exports.ChannelFlagsBitField = require_ChannelFlagsBitField();
  exports.Collection = require_dist7().Collection;
  exports.Constants = require_Constants();
  exports.Colors = require_Colors();
  exports.DataResolver = require_DataResolver();
  exports.Events = require_Events();
  exports.Formatters = require_Formatters();
  exports.GuildMemberFlagsBitField = require_GuildMemberFlagsBitField().GuildMemberFlagsBitField;
  exports.IntentsBitField = require_IntentsBitField();
  exports.LimitedCollection = require_LimitedCollection();
  exports.MessageFlagsBitField = require_MessageFlagsBitField();
  exports.Options = require_Options();
  exports.Partials = require_Partials();
  exports.PermissionsBitField = require_PermissionsBitField();
  exports.RoleFlagsBitField = require_RoleFlagsBitField();
  exports.ShardEvents = require_ShardEvents();
  exports.Status = require_Status();
  exports.SnowflakeUtil = require_dist3().DiscordSnowflake;
  exports.Sweepers = require_Sweepers();
  exports.SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  exports.ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
  exports.UserFlagsBitField = require_UserFlagsBitField();
  __exportStar(require_Util(), exports);
  exports.WebSocketShardEvents = require_WebSocketShardEvents();
  exports.version = require_package().version;
  exports.ApplicationCommandManager = require_ApplicationCommandManager();
  exports.ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  exports.AutoModerationRuleManager = require_AutoModerationRuleManager();
  exports.BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  exports.CachedManager = require_CachedManager();
  exports.ChannelManager = require_ChannelManager();
  exports.ClientVoiceManager = require_ClientVoiceManager();
  exports.DataManager = require_DataManager();
  exports.DMMessageManager = require_DMMessageManager();
  exports.GuildApplicationCommandManager = require_GuildApplicationCommandManager();
  exports.GuildBanManager = require_GuildBanManager();
  exports.GuildChannelManager = require_GuildChannelManager();
  exports.GuildEmojiManager = require_GuildEmojiManager();
  exports.GuildEmojiRoleManager = require_GuildEmojiRoleManager();
  exports.GuildForumThreadManager = require_GuildForumThreadManager();
  exports.GuildInviteManager = require_GuildInviteManager();
  exports.GuildManager = require_GuildManager();
  exports.GuildMemberManager = require_GuildMemberManager();
  exports.GuildMemberRoleManager = require_GuildMemberRoleManager();
  exports.GuildMessageManager = require_GuildMessageManager();
  exports.GuildScheduledEventManager = require_GuildScheduledEventManager();
  exports.GuildStickerManager = require_GuildStickerManager();
  exports.GuildTextThreadManager = require_GuildTextThreadManager();
  exports.MessageManager = require_MessageManager();
  exports.PermissionOverwriteManager = require_PermissionOverwriteManager();
  exports.PresenceManager = require_PresenceManager();
  exports.ReactionManager = require_ReactionManager();
  exports.ReactionUserManager = require_ReactionUserManager();
  exports.RoleManager = require_RoleManager();
  exports.StageInstanceManager = require_StageInstanceManager();
  exports.ThreadManager = require_ThreadManager();
  exports.ThreadMemberManager = require_ThreadMemberManager();
  exports.UserManager = require_UserManager();
  exports.VoiceStateManager = require_VoiceStateManager();
  exports.WebSocketManager = require_WebSocketManager();
  exports.WebSocketShard = require_WebSocketShard();
  exports.ActionRow = require_ActionRow();
  exports.ActionRowBuilder = require_ActionRowBuilder();
  exports.Activity = require_Presence().Activity;
  exports.AnonymousGuild = require_AnonymousGuild();
  exports.Application = require_Application();
  exports.ApplicationCommand = require_ApplicationCommand();
  exports.ApplicationRoleConnectionMetadata = require_ApplicationRoleConnectionMetadata().ApplicationRoleConnectionMetadata;
  exports.AutocompleteInteraction = require_AutocompleteInteraction();
  exports.AutoModerationActionExecution = require_AutoModerationActionExecution();
  exports.AutoModerationRule = require_AutoModerationRule();
  exports.Base = require_Base();
  exports.BaseGuild = require_BaseGuild();
  exports.BaseGuildEmoji = require_BaseGuildEmoji();
  exports.BaseGuildTextChannel = require_BaseGuildTextChannel();
  exports.BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
  exports.ButtonBuilder = require_ButtonBuilder();
  exports.ButtonComponent = require_ButtonComponent();
  exports.ButtonInteraction = require_ButtonInteraction();
  exports.CategoryChannel = require_CategoryChannel();
  exports.BaseChannel = require_BaseChannel().BaseChannel;
  exports.ChatInputCommandInteraction = require_ChatInputCommandInteraction();
  exports.ClientApplication = require_ClientApplication();
  exports.ClientPresence = require_ClientPresence();
  exports.ClientUser = require_ClientUser();
  exports.CommandInteraction = require_CommandInteraction();
  exports.Collector = require_Collector();
  exports.CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  exports.Component = require_Component();
  exports.ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
  exports.DMChannel = require_DMChannel();
  exports.Embed = require_Embed();
  exports.EmbedBuilder = require_EmbedBuilder();
  exports.Emoji = require_Emoji().Emoji;
  exports.ForumChannel = require_ForumChannel();
  exports.Guild = require_Guild().Guild;
  exports.GuildAuditLogs = require_GuildAuditLogs();
  exports.GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  exports.GuildBan = require_GuildBan();
  exports.GuildChannel = require_GuildChannel();
  exports.GuildEmoji = require_GuildEmoji();
  exports.GuildMember = require_GuildMember().GuildMember;
  exports.GuildOnboarding = require_GuildOnboarding().GuildOnboarding;
  exports.GuildOnboardingPrompt = require_GuildOnboardingPrompt().GuildOnboardingPrompt;
  exports.GuildOnboardingPromptOption = require_GuildOnboardingPromptOption().GuildOnboardingPromptOption;
  exports.GuildPreview = require_GuildPreview();
  exports.GuildPreviewEmoji = require_GuildPreviewEmoji();
  exports.GuildScheduledEvent = require_GuildScheduledEvent().GuildScheduledEvent;
  exports.GuildTemplate = require_GuildTemplate();
  exports.Integration = require_Integration();
  exports.IntegrationApplication = require_IntegrationApplication();
  exports.BaseInteraction = require_BaseInteraction();
  exports.InteractionCollector = require_InteractionCollector();
  exports.InteractionResponse = require_InteractionResponse();
  exports.InteractionWebhook = require_InteractionWebhook();
  exports.Invite = require_Invite();
  exports.InviteStageInstance = require_InviteStageInstance();
  exports.InviteGuild = require_InviteGuild();
  exports.Message = require_Message().Message;
  exports.Attachment = require_Attachment();
  exports.AttachmentBuilder = require_AttachmentBuilder();
  exports.ModalBuilder = require_ModalBuilder();
  exports.MediaChannel = require_MediaChannel();
  exports.MessageCollector = require_MessageCollector();
  exports.MessageComponentInteraction = require_MessageComponentInteraction();
  exports.MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
  exports.MessageMentions = require_MessageMentions();
  exports.MessagePayload = require_MessagePayload();
  exports.MessageReaction = require_MessageReaction();
  exports.ModalSubmitInteraction = require_ModalSubmitInteraction();
  exports.ModalSubmitFields = require_ModalSubmitFields();
  exports.NewsChannel = require_NewsChannel();
  exports.OAuth2Guild = require_OAuth2Guild();
  exports.PartialGroupDMChannel = require_PartialGroupDMChannel();
  exports.PermissionOverwrites = require_PermissionOverwrites();
  exports.Presence = require_Presence().Presence;
  exports.ReactionCollector = require_ReactionCollector();
  exports.ReactionEmoji = require_ReactionEmoji();
  exports.RichPresenceAssets = require_Presence().RichPresenceAssets;
  exports.Role = require_Role().Role;
  exports.SelectMenuBuilder = require_SelectMenuBuilder();
  exports.ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
  exports.MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
  exports.RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
  exports.StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  exports.UserSelectMenuBuilder = require_UserSelectMenuBuilder();
  exports.BaseSelectMenuComponent = require_BaseSelectMenuComponent();
  exports.SelectMenuComponent = require_SelectMenuComponent();
  exports.ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
  exports.MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
  exports.RoleSelectMenuComponent = require_RoleSelectMenuComponent();
  exports.StringSelectMenuComponent = require_StringSelectMenuComponent();
  exports.UserSelectMenuComponent = require_UserSelectMenuComponent();
  exports.SelectMenuInteraction = require_SelectMenuInteraction();
  exports.ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
  exports.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  exports.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  exports.RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
  exports.StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  exports.UserSelectMenuInteraction = require_UserSelectMenuInteraction();
  exports.SelectMenuOptionBuilder = require_SelectMenuOptionBuilder();
  exports.StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
  exports.StageChannel = require_StageChannel();
  exports.StageInstance = require_StageInstance().StageInstance;
  exports.Sticker = require_Sticker().Sticker;
  exports.StickerPack = require_StickerPack();
  exports.Team = require_Team();
  exports.TeamMember = require_TeamMember();
  exports.TextChannel = require_TextChannel();
  exports.TextInputBuilder = require_TextInputBuilder();
  exports.TextInputComponent = require_TextInputComponent();
  exports.ThreadChannel = require_ThreadChannel();
  exports.ThreadMember = require_ThreadMember();
  exports.ThreadOnlyChannel = require_ThreadOnlyChannel();
  exports.Typing = require_Typing();
  exports.User = require_User();
  exports.UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
  exports.VoiceChannel = require_VoiceChannel();
  exports.VoiceRegion = require_VoiceRegion();
  exports.VoiceState = require_VoiceState();
  exports.Webhook = require_Webhook();
  exports.Widget = require_Widget();
  exports.WidgetMember = require_WidgetMember();
  exports.WelcomeChannel = require_WelcomeChannel();
  exports.WelcomeScreen = require_WelcomeScreen();
  __exportStar(require_v106(), exports);
  __exportStar(require_dist9(), exports);
  __exportStar(require_dist8(), exports);
  __exportStar(require_dist6(), exports);
  __exportStar(require_dist(), exports);
  __exportStar(require_dist11(), exports);
});

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction2 = __commonJS((exports) => {
  var isFunction = function(value) {
    return typeof value === "function";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isFunction = undefined;
  exports.isFunction = isFunction;
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS((exports) => {
  var createErrorClass = function(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createErrorClass = undefined;
  exports.createErrorClass = createErrorClass;
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnsubscriptionError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS((exports) => {
  var arrRemove = function(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.arrRemove = undefined;
  exports.arrRemove = arrRemove;
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS((exports) => {
  var isSubscription = function(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
  };
  var execFinalizer = function(finalizer) {
    if (isFunction_1.isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = undefined;
  var isFunction_1 = require_isFunction2();
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  var arrRemove_1 = require_arrRemove();
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next();!_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction_1.isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next();!_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== undefined ? errors : [];
                if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== undefined ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove_1.arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2;
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  exports.Subscription = Subscription;
  exports.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  exports.isSubscription = isSubscription;
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.config = undefined;
  exports.config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutProvider = undefined;
  exports.timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports.timeoutProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(undefined, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = exports.timeoutProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS((exports) => {
  var reportUnhandledError = function(err) {
    timeoutProvider_1.timeoutProvider.setTimeout(function() {
      var onUnhandledError = config_1.config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportUnhandledError = undefined;
  var config_1 = require_config();
  var timeoutProvider_1 = require_timeoutProvider();
  exports.reportUnhandledError = reportUnhandledError;
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop2 = __commonJS((exports) => {
  var noop = function() {
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noop = undefined;
  exports.noop = noop;
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS((exports) => {
  var errorNotification = function(error) {
    return createNotification("E", undefined, error);
  };
  var nextNotification = function(value) {
    return createNotification("N", value, undefined);
  };
  var createNotification = function(kind, value, error) {
    return {
      kind,
      value,
      error
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = undefined;
  exports.COMPLETE_NOTIFICATION = function() {
    return createNotification("C", undefined, undefined);
  }();
  exports.errorNotification = errorNotification;
  exports.nextNotification = nextNotification;
  exports.createNotification = createNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS((exports) => {
  var errorContext = function(cb) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context, errorThrown = _a.errorThrown, error = _a.error;
        context = null;
        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  };
  var captureError = function(err) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.captureError = exports.errorContext = undefined;
  var config_1 = require_config();
  var context = null;
  exports.errorContext = errorContext;
  exports.captureError = captureError;
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS((exports) => {
  var bind = function(fn, thisArg) {
    return _bind.call(fn, thisArg);
  };
  var handleUnhandledError = function(error) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      errorContext_1.captureError(error);
    } else {
      reportUnhandledError_1.reportUnhandledError(error);
    }
  };
  var defaultErrorHandler = function(err) {
    throw err;
  };
  var handleStoppedNotification = function(notification, subscriber) {
    var onStoppedNotification = config_1.config.onStoppedNotification;
    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = undefined;
  var isFunction_1 = require_isFunction2();
  var Subscription_1 = require_Subscription();
  var config_1 = require_config();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var noop_1 = require_noop2();
  var NotificationFactories_1 = require_NotificationFactories();
  var timeoutProvider_1 = require_timeoutProvider();
  var errorContext_1 = require_errorContext();
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (Subscription_1.isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = exports.EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription_1.Subscription);
  exports.Subscriber = Subscriber;
  var _bind = Function.prototype.bind;
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== undefined ? observerOrNext : undefined,
          error: error !== null && error !== undefined ? error : undefined,
          complete: complete !== null && complete !== undefined ? complete : undefined
        };
      } else {
        var context_1;
        if (_this && config_1.config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  exports.SafeSubscriber = SafeSubscriber;
  exports.EMPTY_OBSERVER = {
    closed: true,
    next: noop_1.noop,
    error: defaultErrorHandler,
    complete: noop_1.noop
  };
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observable = undefined;
  exports.observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS((exports) => {
  var identity = function(x) {
    return x;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.identity = undefined;
  exports.identity = identity;
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS((exports) => {
  var pipe = function() {
    var fns = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  };
  var pipeFromArray = function(fns) {
    if (fns.length === 0) {
      return identity_1.identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pipeFromArray = exports.pipe = undefined;
  var identity_1 = require_identity();
  exports.pipe = pipe;
  exports.pipeFromArray = pipeFromArray;
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS((exports) => {
  var getPromiseCtor = function(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== undefined ? promiseCtor : config_1.config.Promise) !== null && _a !== undefined ? _a : Promise;
  };
  var isObserver = function(value) {
    return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
  };
  var isSubscriber = function(value) {
    return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Observable = undefined;
  var Subscriber_1 = require_Subscriber();
  var Subscription_1 = require_Subscription();
  var observable_1 = require_observable();
  var pipe_1 = require_pipe();
  var config_1 = require_config();
  var isFunction_1 = require_isFunction2();
  var errorContext_1 = require_errorContext();
  var Observable = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable = new Observable2;
      observable.source = this;
      observable.operator = operator;
      return observable;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
      errorContext_1.errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === undefined ? undefined : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable_1.observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipe_1.pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  exports.Observable = Observable;
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS((exports) => {
  var hasLift = function(source) {
    return isFunction_1.isFunction(source === null || source === undefined ? undefined : source.lift);
  };
  var operate = function(init) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.operate = exports.hasLift = undefined;
  var isFunction_1 = require_isFunction2();
  exports.hasLift = hasLift;
  exports.operate = operate;
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS((exports) => {
  var createOperatorSubscriber = function(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperatorSubscriber = exports.createOperatorSubscriber = undefined;
  var Subscriber_1 = require_Subscriber();
  exports.createOperatorSubscriber = createOperatorSubscriber;
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === undefined || _a.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber_1.Subscriber);
  exports.OperatorSubscriber = OperatorSubscriber;
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS((exports) => {
  var refCount = function() {
    return lift_1.operate(function(source, subscriber) {
      var connection = null;
      source._refCount++;
      var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, undefined, function() {
        if (!source || source._refCount <= 0 || 0 < --source._refCount) {
          connection = null;
          return;
        }
        var sharedConnection = source._connection;
        var conn = connection;
        connection = null;
        if (sharedConnection && (!conn || sharedConnection === conn)) {
          sharedConnection.unsubscribe();
        }
        subscriber.unsubscribe();
      });
      source.subscribe(refCounter);
      if (!refCounter.closed) {
        connection = source.connect();
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.refCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.refCount = refCount;
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectableObservable = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var refCount_1 = require_refCount();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  var ConnectableObservable = function(_super) {
    __extends(ConnectableObservable2, _super);
    function ConnectableObservable2(source, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._subject = null;
      _this._refCount = 0;
      _this._connection = null;
      if (lift_1.hasLift(source)) {
        _this.lift = source.lift;
      }
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype._teardown = function() {
      this._refCount = 0;
      var _connection = this._connection;
      this._subject = this._connection = null;
      _connection === null || _connection === undefined || _connection.unsubscribe();
    };
    ConnectableObservable2.prototype.connect = function() {
      var _this = this;
      var connection = this._connection;
      if (!connection) {
        connection = this._connection = new Subscription_1.Subscription;
        var subject_1 = this.getSubject();
        connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, undefined, function() {
          _this._teardown();
          subject_1.complete();
        }, function(err) {
          _this._teardown();
          subject_1.error(err);
        }, function() {
          return _this._teardown();
        })));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription_1.Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount_1.refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable_1.Observable);
  exports.ConnectableObservable = ConnectableObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.performanceTimestampProvider = undefined;
  exports.performanceTimestampProvider = {
    now: function() {
      return (exports.performanceTimestampProvider.delegate || performance).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrameProvider = undefined;
  var Subscription_1 = require_Subscription();
  exports.animationFrameProvider = {
    schedule: function(callback) {
      var request = requestAnimationFrame;
      var cancel = cancelAnimationFrame;
      var delegate = exports.animationFrameProvider.delegate;
      if (delegate) {
        request = delegate.requestAnimationFrame;
        cancel = delegate.cancelAnimationFrame;
      }
      var handle = request(function(timestamp) {
        cancel = undefined;
        callback(timestamp);
      });
      return new Subscription_1.Subscription(function() {
        return cancel === null || cancel === undefined ? undefined : cancel(handle);
      });
    },
    requestAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.requestAnimationFrame) || requestAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    cancelAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS((exports) => {
  var animationFrames = function(timestampProvider) {
    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
  };
  var animationFramesFactory = function(timestampProvider) {
    return new Observable_1.Observable(function(subscriber) {
      var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
      var start = provider.now();
      var id = 0;
      var run = function() {
        if (!subscriber.closed) {
          id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
            id = 0;
            var now = provider.now();
            subscriber.next({
              timestamp: timestampProvider ? now : timestamp,
              elapsed: now - start
            });
            run();
          });
        }
      };
      run();
      return function() {
        if (id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        }
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrames = undefined;
  var Observable_1 = require_Observable();
  var performanceTimestampProvider_1 = require_performanceTimestampProvider();
  var animationFrameProvider_1 = require_animationFrameProvider();
  exports.animationFrames = animationFrames;
  var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ObjectUnsubscribedError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnonymousSubject = exports.Subject = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  var arrRemove_1 = require_arrRemove();
  var errorContext_1 = require_errorContext();
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError;
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext_1.errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next();!_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === undefined ? undefined : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return Subscription_1.EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription_1.Subscription(function() {
        _this.currentObservers = null;
        arrRemove_1.arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable = new Observable_1.Observable;
      observable.source = this;
      return observable;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable_1.Observable);
  exports.Subject = Subject;
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.next) === null || _b === undefined || _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.error) === null || _b === undefined || _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === undefined ? undefined : _a.complete) === null || _b === undefined || _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === undefined ? undefined : _a.subscribe(subscriber)) !== null && _b !== undefined ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);
  exports.AnonymousSubject = AnonymousSubject;
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BehaviorSubject = undefined;
  var Subject_1 = require_Subject();
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject_1.Subject);
  exports.BehaviorSubject = BehaviorSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dateTimestampProvider = undefined;
  exports.dateTimestampProvider = {
    now: function() {
      return (exports.dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplaySubject = undefined;
  var Subject_1 = require_Subject();
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var ReplaySubject = function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === undefined) {
        _bufferSize = Infinity;
      }
      if (_windowTime === undefined) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === undefined) {
        _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value) {
      var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
      if (!isStopped) {
        _buffer.push(value);
        !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
      var copy = _buffer.slice();
      for (var i = 0;i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy[i]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last = 0;
        for (var i = 1;i < _buffer.length && _buffer[i] <= now; i += 2) {
          last = i;
        }
        last && _buffer.splice(0, last + 1);
      }
    };
    return ReplaySubject2;
  }(Subject_1.Subject);
  exports.ReplaySubject = ReplaySubject;
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncSubject = undefined;
  var Subject_1 = require_Subject();
  var AsyncSubject = function(_super) {
    __extends(AsyncSubject2, _super);
    function AsyncSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._value = null;
      _this._hasValue = false;
      _this._isComplete = false;
      return _this;
    }
    AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped || _isComplete) {
        _hasValue && subscriber.next(_value);
        subscriber.complete();
      }
    };
    AsyncSubject2.prototype.next = function(value) {
      if (!this.isStopped) {
        this._value = value;
        this._hasValue = true;
      }
    };
    AsyncSubject2.prototype.complete = function() {
      var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
      if (!_isComplete) {
        this._isComplete = true;
        _hasValue && _super.prototype.next.call(this, _value);
        _super.prototype.complete.call(this);
      }
    };
    return AsyncSubject2;
  }(Subject_1.Subject);
  exports.AsyncSubject = AsyncSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action2 = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Action = undefined;
  var Subscription_1 = require_Subscription();
  var Action = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return this;
    };
    return Action2;
  }(Subscription_1.Subscription);
  exports.Action = Action;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.intervalProvider = undefined;
  exports.intervalProvider = {
    setInterval: function(handler, timeout) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports.intervalProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setInterval.apply(undefined, __spreadArray([handler, timeout], __read(args)));
    },
    clearInterval: function(handle) {
      var delegate = exports.intervalProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncAction = undefined;
  var Action_1 = require_Action2();
  var intervalProvider_1 = require_intervalProvider();
  var arrRemove_1 = require_arrRemove();
  var AsyncAction = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay);
      }
      this.pending = true;
      this.delay = delay;
      this.id = (_a = this.id) !== null && _a !== undefined ? _a : this.requestAsyncId(scheduler, this.id, delay);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && this.delay === delay && this.pending === false) {
        return id;
      }
      if (id != null) {
        intervalProvider_1.intervalProvider.clearInterval(id);
      }
      return;
    };
    AsyncAction2.prototype.execute = function(state, delay) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error = this._execute(state, delay);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a = this, id = _a.id, scheduler = _a.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove_1.arrRemove(actions, this);
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action_1.Action);
  exports.AsyncAction = AsyncAction;
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS((exports) => {
  var findAndClearHandle = function(handle) {
    if (handle in activeHandles) {
      delete activeHandles[handle];
      return true;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TestTools = exports.Immediate = undefined;
  var nextHandle = 1;
  var resolved;
  var activeHandles = {};
  exports.Immediate = {
    setImmediate: function(cb) {
      var handle = nextHandle++;
      activeHandles[handle] = true;
      if (!resolved) {
        resolved = Promise.resolve();
      }
      resolved.then(function() {
        return findAndClearHandle(handle) && cb();
      });
      return handle;
    },
    clearImmediate: function(handle) {
      findAndClearHandle(handle);
    }
  };
  exports.TestTools = {
    pending: function() {
      return Object.keys(activeHandles).length;
    }
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.immediateProvider = undefined;
  var Immediate_1 = require_Immediate();
  var setImmediate2 = Immediate_1.Immediate.setImmediate;
  var clearImmediate2 = Immediate_1.Immediate.clearImmediate;
  exports.immediateProvider = {
    setImmediate: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.setImmediate) || setImmediate2).apply(undefined, __spreadArray([], __read(args)));
    },
    clearImmediate: function(handle) {
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearImmediate) || clearImmediate2)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsapAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var immediateProvider_1 = require_immediateProvider();
  var AsapAction = function(_super) {
    __extends(AsapAction2, _super);
    function AsapAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
    };
    AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a = actions[actions.length - 1]) === null || _a === undefined ? undefined : _a.id) !== id) {
        immediateProvider_1.immediateProvider.clearImmediate(id);
        if (scheduler._scheduled === id) {
          scheduler._scheduled = undefined;
        }
      }
      return;
    };
    return AsapAction2;
  }(AsyncAction_1.AsyncAction);
  exports.AsapAction = AsapAction;
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Scheduler = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var Scheduler = function() {
    function Scheduler2(schedulerActionCtor, now) {
      if (now === undefined) {
        now = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function(work, delay, state) {
      if (delay === undefined) {
        delay = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
    return Scheduler2;
  }();
  exports.Scheduler = Scheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncScheduler = undefined;
  var Scheduler_1 = require_Scheduler();
  var AsyncScheduler = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === undefined) {
        now = Scheduler_1.Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error;
      this._active = true;
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler_1.Scheduler);
  exports.AsyncScheduler = AsyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsapScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AsapScheduler = function(_super) {
    __extends(AsapScheduler2, _super);
    function AsapScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = undefined;
      var actions = this.actions;
      var error;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsapScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.AsapScheduler = AsapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.asap = exports.asapScheduler = undefined;
  var AsapAction_1 = require_AsapAction();
  var AsapScheduler_1 = require_AsapScheduler();
  exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
  exports.asap = exports.asapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.async = exports.asyncScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var AsyncScheduler_1 = require_AsyncScheduler();
  exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
  exports.async = exports.asyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueueAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var QueueAction = function(_super) {
    __extends(QueueAction2, _super);
    function QueueAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay > 0) {
        return _super.prototype.schedule.call(this, state, delay);
      }
      this.delay = delay;
      this.state = state;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state, delay) {
      return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && delay > 0 || delay == null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.flush(this);
      return 0;
    };
    return QueueAction2;
  }(AsyncAction_1.AsyncAction);
  exports.QueueAction = QueueAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueueScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var QueueScheduler = function(_super) {
    __extends(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.QueueScheduler = QueueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.queue = exports.queueScheduler = undefined;
  var QueueAction_1 = require_QueueAction();
  var QueueScheduler_1 = require_QueueScheduler();
  exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
  exports.queue = exports.queueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnimationFrameAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var animationFrameProvider_1 = require_animationFrameProvider();
  var AnimationFrameAction = function(_super) {
    __extends(AnimationFrameAction2, _super);
    function AnimationFrameAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
        return scheduler.flush(undefined);
      }));
    };
    AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a = actions[actions.length - 1]) === null || _a === undefined ? undefined : _a.id) !== id) {
        animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        scheduler._scheduled = undefined;
      }
      return;
    };
    return AnimationFrameAction2;
  }(AsyncAction_1.AsyncAction);
  exports.AnimationFrameAction = AnimationFrameAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnimationFrameScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AnimationFrameScheduler = function(_super) {
    __extends(AnimationFrameScheduler2, _super);
    function AnimationFrameScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = undefined;
      var actions = this.actions;
      var error;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AnimationFrameScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.AnimationFrameScheduler = AnimationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrame = exports.animationFrameScheduler = undefined;
  var AnimationFrameAction_1 = require_AnimationFrameAction();
  var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
  exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
  exports.animationFrame = exports.animationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VirtualAction = exports.VirtualTimeScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var Subscription_1 = require_Subscription();
  var AsyncScheduler_1 = require_AsyncScheduler();
  var VirtualTimeScheduler = function(_super) {
    __extends(VirtualTimeScheduler2, _super);
    function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
      if (schedulerActionCtor === undefined) {
        schedulerActionCtor = VirtualAction;
      }
      if (maxFrames === undefined) {
        maxFrames = Infinity;
      }
      var _this = _super.call(this, schedulerActionCtor, function() {
        return _this.frame;
      }) || this;
      _this.maxFrames = maxFrames;
      _this.frame = 0;
      _this.index = -1;
      return _this;
    }
    VirtualTimeScheduler2.prototype.flush = function() {
      var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
      var error;
      var action;
      while ((action = actions[0]) && action.delay <= maxFrames) {
        actions.shift();
        this.frame = action.delay;
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      }
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    VirtualTimeScheduler2.frameTimeFactor = 10;
    return VirtualTimeScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.VirtualTimeScheduler = VirtualTimeScheduler;
  var VirtualAction = function(_super) {
    __extends(VirtualAction2, _super);
    function VirtualAction2(scheduler, work, index) {
      if (index === undefined) {
        index = scheduler.index += 1;
      }
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.index = index;
      _this.active = true;
      _this.index = scheduler.index = index;
      return _this;
    }
    VirtualAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (Number.isFinite(delay)) {
        if (!this.id) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
      } else {
        return Subscription_1.Subscription.EMPTY;
      }
    };
    VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      this.delay = scheduler.frame + delay;
      var actions = scheduler.actions;
      actions.push(this);
      actions.sort(VirtualAction2.sortActions);
      return 1;
    };
    VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return;
    };
    VirtualAction2.prototype._execute = function(state, delay) {
      if (this.active === true) {
        return _super.prototype._execute.call(this, state, delay);
      }
    };
    VirtualAction2.sortActions = function(a, b) {
      if (a.delay === b.delay) {
        if (a.index === b.index) {
          return 0;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return -1;
        }
      } else if (a.delay > b.delay) {
        return 1;
      } else {
        return -1;
      }
    };
    return VirtualAction2;
  }(AsyncAction_1.AsyncAction);
  exports.VirtualAction = VirtualAction;
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS((exports) => {
  var empty = function(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
  };
  var emptyScheduled = function(scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      return scheduler.schedule(function() {
        return subscriber.complete();
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.empty = exports.EMPTY = undefined;
  var Observable_1 = require_Observable();
  exports.EMPTY = new Observable_1.Observable(function(subscriber) {
    return subscriber.complete();
  });
  exports.empty = empty;
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS((exports) => {
  var isScheduler = function(value) {
    return value && isFunction_1.isFunction(value.schedule);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isScheduler = undefined;
  var isFunction_1 = require_isFunction2();
  exports.isScheduler = isScheduler;
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS((exports) => {
  var last = function(arr) {
    return arr[arr.length - 1];
  };
  var popResultSelector = function(args) {
    return isFunction_1.isFunction(last(args)) ? args.pop() : undefined;
  };
  var popScheduler = function(args) {
    return isScheduler_1.isScheduler(last(args)) ? args.pop() : undefined;
  };
  var popNumber = function(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.popNumber = exports.popScheduler = exports.popResultSelector = undefined;
  var isFunction_1 = require_isFunction2();
  var isScheduler_1 = require_isScheduler();
  exports.popResultSelector = popResultSelector;
  exports.popScheduler = popScheduler;
  exports.popNumber = popNumber;
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isArrayLike = undefined;
  exports.isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS((exports) => {
  var isPromise = function(value) {
    return isFunction_1.isFunction(value === null || value === undefined ? undefined : value.then);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPromise = undefined;
  var isFunction_1 = require_isFunction2();
  exports.isPromise = isPromise;
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS((exports) => {
  var isInteropObservable = function(input) {
    return isFunction_1.isFunction(input[observable_1.observable]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isInteropObservable = undefined;
  var observable_1 = require_observable();
  var isFunction_1 = require_isFunction2();
  exports.isInteropObservable = isInteropObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS((exports) => {
  var isAsyncIterable = function(obj) {
    return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj[Symbol.asyncIterator]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAsyncIterable = undefined;
  var isFunction_1 = require_isFunction2();
  exports.isAsyncIterable = isAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS((exports) => {
  var createInvalidObservableTypeError = function(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createInvalidObservableTypeError = undefined;
  exports.createInvalidObservableTypeError = createInvalidObservableTypeError;
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS((exports) => {
  var getSymbolIterator = function() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iterator = exports.getSymbolIterator = undefined;
  exports.getSymbolIterator = getSymbolIterator;
  exports.iterator = getSymbolIterator();
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS((exports) => {
  var isIterable = function(input) {
    return isFunction_1.isFunction(input === null || input === undefined ? undefined : input[iterator_1.iterator]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isIterable = undefined;
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction2();
  exports.isIterable = isIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS((exports) => {
  var readableStreamLikeToAsyncGenerator = function(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            if (false)
              ;
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done)
              return [3, 5];
            return [4, __await(undefined)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  };
  var isReadableStreamLike = function(obj) {
    return isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj.getReader);
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = undefined;
  var isFunction_1 = require_isFunction2();
  exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
  exports.isReadableStreamLike = isReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS((exports) => {
  var innerFrom = function(input) {
    if (input instanceof Observable_1.Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise_1.isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable_1.isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  };
  var fromInteropObservable = function(obj) {
    return new Observable_1.Observable(function(subscriber) {
      var obs = obj[observable_1.observable]();
      if (isFunction_1.isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  };
  var fromArrayLike = function(array) {
    return new Observable_1.Observable(function(subscriber) {
      for (var i = 0;i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  };
  var fromPromise = function(promise) {
    return new Observable_1.Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError_1.reportUnhandledError);
    });
  };
  var fromIterable = function(iterable) {
    return new Observable_1.Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next();!iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  };
  var fromAsyncIterable = function(asyncIterable) {
    return new Observable_1.Observable(function(subscriber) {
      process2(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  };
  var fromReadableStreamLike = function(readableStream) {
    return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
  };
  var process2 = function(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, undefined, undefined, function() {
      var value, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = undefined;
  var isArrayLike_1 = require_isArrayLike();
  var isPromise_1 = require_isPromise();
  var Observable_1 = require_Observable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isIterable_1 = require_isIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var isFunction_1 = require_isFunction2();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var observable_1 = require_observable();
  exports.innerFrom = innerFrom;
  exports.fromInteropObservable = fromInteropObservable;
  exports.fromArrayLike = fromArrayLike;
  exports.fromPromise = fromPromise;
  exports.fromIterable = fromIterable;
  exports.fromAsyncIterable = fromAsyncIterable;
  exports.fromReadableStreamLike = fromReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS((exports) => {
  var executeSchedule = function(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === undefined) {
      delay = 0;
    }
    if (repeat === undefined) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.executeSchedule = undefined;
  exports.executeSchedule = executeSchedule;
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS((exports) => {
  var observeOn = function(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay);
      }, function() {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeOn = undefined;
  var executeSchedule_1 = require_executeSchedule();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.observeOn = observeOn;
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS((exports) => {
  var subscribeOn = function(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.subscribeOn = undefined;
  var lift_1 = require_lift();
  exports.subscribeOn = subscribeOn;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS((exports) => {
  var scheduleObservable = function(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleObservable = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  exports.scheduleObservable = scheduleObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS((exports) => {
  var schedulePromise = function(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.schedulePromise = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  exports.schedulePromise = schedulePromise;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS((exports) => {
  var scheduleArray = function(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var i = 0;
      return scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleArray = undefined;
  var Observable_1 = require_Observable();
  exports.scheduleArray = scheduleArray;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS((exports) => {
  var scheduleIterable = function(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var iterator;
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        iterator = input[iterator_1.iterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value;
          var done;
          try {
            _a = iterator.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction_1.isFunction(iterator === null || iterator === undefined ? undefined : iterator.return) && iterator.return();
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleIterable = undefined;
  var Observable_1 = require_Observable();
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction2();
  var executeSchedule_1 = require_executeSchedule();
  exports.scheduleIterable = scheduleIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS((exports) => {
  var scheduleAsyncIterable = function(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable_1.Observable(function(subscriber) {
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        var iterator = input[Symbol.asyncIterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleAsyncIterable = undefined;
  var Observable_1 = require_Observable();
  var executeSchedule_1 = require_executeSchedule();
  exports.scheduleAsyncIterable = scheduleAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS((exports) => {
  var scheduleReadableStreamLike = function(input, scheduler) {
    return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleReadableStreamLike = undefined;
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  exports.scheduleReadableStreamLike = scheduleReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS((exports) => {
  var scheduled = function(input, scheduler) {
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return scheduleObservable_1.scheduleObservable(input, scheduler);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return scheduleArray_1.scheduleArray(input, scheduler);
      }
      if (isPromise_1.isPromise(input)) {
        return schedulePromise_1.schedulePromise(input, scheduler);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable_1.isIterable(input)) {
        return scheduleIterable_1.scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduled = undefined;
  var scheduleObservable_1 = require_scheduleObservable();
  var schedulePromise_1 = require_schedulePromise();
  var scheduleArray_1 = require_scheduleArray();
  var scheduleIterable_1 = require_scheduleIterable();
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isPromise_1 = require_isPromise();
  var isArrayLike_1 = require_isArrayLike();
  var isIterable_1 = require_isIterable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
  exports.scheduled = scheduled;
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS((exports) => {
  var from = function(input, scheduler) {
    return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.from = undefined;
  var scheduled_1 = require_scheduled();
  var innerFrom_1 = require_innerFrom();
  exports.from = from;
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS((exports) => {
  var of = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return from_1.from(args, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.of = undefined;
  var args_1 = require_args();
  var from_1 = require_from();
  exports.of = of;
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS((exports) => {
  var throwError = function(errorOrErrorFactory, scheduler) {
    var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
      return errorOrErrorFactory;
    };
    var init = function(subscriber) {
      return subscriber.error(errorFactory());
    };
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      return scheduler.schedule(init, 0, subscriber);
    } : init);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throwError = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction2();
  exports.throwError = throwError;
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS((exports) => {
  var observeNotification = function(notification, observer) {
    var _a, _b, _c;
    var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
    if (typeof kind !== "string") {
      throw new TypeError('Invalid notification, missing "kind"');
    }
    kind === "N" ? (_a = observer.next) === null || _a === undefined || _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === undefined || _b.call(observer, error) : (_c = observer.complete) === null || _c === undefined || _c.call(observer);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeNotification = exports.Notification = exports.NotificationKind = undefined;
  var empty_1 = require_empty();
  var of_1 = require_of();
  var throwError_1 = require_throwError();
  var isFunction_1 = require_isFunction2();
  var NotificationKind;
  (function(NotificationKind2) {
    NotificationKind2["NEXT"] = "N";
    NotificationKind2["ERROR"] = "E";
    NotificationKind2["COMPLETE"] = "C";
  })(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
  var Notification = function() {
    function Notification2(kind, value, error) {
      this.kind = kind;
      this.value = value;
      this.error = error;
      this.hasValue = kind === "N";
    }
    Notification2.prototype.observe = function(observer) {
      return observeNotification(this, observer);
    };
    Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
      var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
      return kind === "N" ? nextHandler === null || nextHandler === undefined ? undefined : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === undefined ? undefined : errorHandler(error) : completeHandler === null || completeHandler === undefined ? undefined : completeHandler();
    };
    Notification2.prototype.accept = function(nextOrObserver, error, complete) {
      var _a;
      return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === undefined ? undefined : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
    };
    Notification2.prototype.toObservable = function() {
      var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
      var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
        return error;
      }) : kind === "C" ? empty_1.EMPTY : 0;
      if (!result) {
        throw new TypeError("Unexpected notification kind " + kind);
      }
      return result;
    };
    Notification2.createNext = function(value) {
      return new Notification2("N", value);
    };
    Notification2.createError = function(err) {
      return new Notification2("E", undefined, err);
    };
    Notification2.createComplete = function() {
      return Notification2.completeNotification;
    };
    Notification2.completeNotification = new Notification2("C");
    return Notification2;
  }();
  exports.Notification = Notification;
  exports.observeNotification = observeNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS((exports) => {
  var isObservable = function(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObservable = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction2();
  exports.isObservable = isObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmptyError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS((exports) => {
  var lastValueFrom = function(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var _hasValue = false;
      var _value;
      source.subscribe({
        next: function(value) {
          _value = value;
          _hasValue = true;
        },
        error: reject,
        complete: function() {
          if (_hasValue) {
            resolve(_value);
          } else if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lastValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  exports.lastValueFrom = lastValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS((exports) => {
  var firstValueFrom = function(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var subscriber = new Subscriber_1.SafeSubscriber({
        next: function(value) {
          resolve(value);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
      source.subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.firstValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  var Subscriber_1 = require_Subscriber();
  exports.firstValueFrom = firstValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ArgumentOutOfRangeError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
    return function ArgumentOutOfRangeErrorImpl() {
      _super(this);
      this.name = "ArgumentOutOfRangeError";
      this.message = "argument out of range";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NotFoundError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
    return function NotFoundErrorImpl(message) {
      _super(this);
      this.name = "NotFoundError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SequenceError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
    return function SequenceErrorImpl(message) {
      _super(this);
      this.name = "SequenceError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS((exports) => {
  var isValidDate = function(value) {
    return value instanceof Date && !isNaN(value);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidDate = undefined;
  exports.isValidDate = isValidDate;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS((exports) => {
  var timeout = function(config, schedulerArg) {
    var _a = isDate_1.isValidDate(config) ? { first: config } : typeof config === "number" ? { each: config } : config, first = _a.first, each = _a.each, _b = _a.with, _with = _b === undefined ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === undefined ? schedulerArg !== null && schedulerArg !== undefined ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === undefined ? null : _d;
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return lift_1.operate(function(source, subscriber) {
      var originalSourceSubscription;
      var timerSubscription;
      var lastValue = null;
      var seen = 0;
      var startTimer = function(delay) {
        timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          try {
            originalSourceSubscription.unsubscribe();
            innerFrom_1.innerFrom(_with({
              meta,
              lastValue,
              seen
            })).subscribe(subscriber);
          } catch (err) {
            subscriber.error(err);
          }
        }, delay);
      };
      originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        seen++;
        subscriber.next(lastValue = value);
        each > 0 && startTimer(each);
      }, undefined, undefined, function() {
        if (!(timerSubscription === null || timerSubscription === undefined ? undefined : timerSubscription.closed)) {
          timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        }
        lastValue = null;
      }));
      !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
    });
  };
  var timeoutErrorFactory = function(info) {
    throw new exports.TimeoutError(info);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeout = exports.TimeoutError = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var createErrorClass_1 = require_createErrorClass();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
    return function TimeoutErrorImpl(info) {
      if (info === undefined) {
        info = null;
      }
      _super(this);
      this.message = "Timeout has occurred";
      this.name = "TimeoutError";
      this.info = info;
    };
  });
  exports.timeout = timeout;
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS((exports) => {
  var map = function(project, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.map = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.map = map;
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS((exports) => {
  var callOrApply = function(fn, args) {
    return isArray(args) ? fn.apply(undefined, __spreadArray([], __read(args))) : fn(args);
  };
  var mapOneOrManyArgs = function(fn) {
    return map_1.map(function(args) {
      return callOrApply(fn, args);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapOneOrManyArgs = undefined;
  var map_1 = require_map();
  var isArray = Array.isArray;
  exports.mapOneOrManyArgs = mapOneOrManyArgs;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS((exports) => {
  var bindCallbackInternals = function(isNodeStyle, callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
      if (isScheduler_1.isScheduler(resultSelector)) {
        scheduler = resultSelector;
      } else {
        return function() {
          var args = [];
          for (var _i = 0;_i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        };
      }
    }
    if (scheduler) {
      return function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
      };
    }
    return function() {
      var _this = this;
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var subject = new AsyncSubject_1.AsyncSubject;
      var uninitialized = true;
      return new Observable_1.Observable(function(subscriber) {
        var subs = subject.subscribe(subscriber);
        if (uninitialized) {
          uninitialized = false;
          var isAsync_1 = false;
          var isComplete_1 = false;
          callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
            function() {
              var results = [];
              for (var _i2 = 0;_i2 < arguments.length; _i2++) {
                results[_i2] = arguments[_i2];
              }
              if (isNodeStyle) {
                var err = results.shift();
                if (err != null) {
                  subject.error(err);
                  return;
                }
              }
              subject.next(1 < results.length ? results : results[0]);
              isComplete_1 = true;
              if (isAsync_1) {
                subject.complete();
              }
            }
          ]));
          if (isComplete_1) {
            subject.complete();
          }
          isAsync_1 = true;
        }
        return subs;
      });
    };
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindCallbackInternals = undefined;
  var isScheduler_1 = require_isScheduler();
  var Observable_1 = require_Observable();
  var subscribeOn_1 = require_subscribeOn();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var observeOn_1 = require_observeOn();
  var AsyncSubject_1 = require_AsyncSubject();
  exports.bindCallbackInternals = bindCallbackInternals;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS((exports) => {
  var bindCallback = function(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  exports.bindCallback = bindCallback;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS((exports) => {
  var bindNodeCallback = function(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindNodeCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  exports.bindNodeCallback = bindNodeCallback;
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS((exports) => {
  var argsArgArrayOrObject = function(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  };
  var isPOJO = function(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsArgArrayOrObject = undefined;
  var isArray = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  exports.argsArgArrayOrObject = argsArgArrayOrObject;
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS((exports) => {
  var createObject = function(keys, values) {
    return keys.reduce(function(result, key, i) {
      return result[key] = values[i], result;
    }, {});
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createObject = undefined;
  exports.createObject = createObject;
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS((exports) => {
  var combineLatest = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var resultSelector = args_1.popResultSelector(args);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) {
      return from_1.from([], scheduler);
    }
    var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject_1.createObject(keys, values);
    } : identity_1.identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  };
  var combineLatestInit = function(observables, scheduler, valueTransform) {
    if (valueTransform === undefined) {
      valueTransform = identity_1.identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i2) {
          maybeSchedule(scheduler, function() {
            var source = from_1.from(observables[i2], scheduler);
            var hasFirstValue = false;
            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              values[i2] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i = 0;i < length; i++) {
          _loop_1(i);
        }
      }, subscriber);
    };
  };
  var maybeSchedule = function(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule_1.executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestInit = exports.combineLatest = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var from_1 = require_from();
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var args_1 = require_args();
  var createObject_1 = require_createObject();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  exports.combineLatest = combineLatest;
  exports.combineLatestInit = combineLatestInit;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS((exports) => {
  var mergeInternals = function(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === undefined || onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, undefined, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) {
                executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === undefined || additionalFinalizer();
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeInternals = undefined;
  var innerFrom_1 = require_innerFrom();
  var executeSchedule_1 = require_executeSchedule();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.mergeInternals = mergeInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS((exports) => {
  var mergeMap = function(project, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap(function(a, i) {
        return map_1.map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        })(innerFrom_1.innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  var isFunction_1 = require_isFunction2();
  exports.mergeMap = mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS((exports) => {
  var mergeAll = function(concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeAll = undefined;
  var mergeMap_1 = require_mergeMap();
  var identity_1 = require_identity();
  exports.mergeAll = mergeAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS((exports) => {
  var concatAll = function() {
    return mergeAll_1.mergeAll(1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatAll = undefined;
  var mergeAll_1 = require_mergeAll();
  exports.concatAll = concatAll;
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS((exports) => {
  var concat = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = undefined;
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.concat = concat;
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS((exports) => {
  var defer = function(observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defer = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  exports.defer = defer;
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS((exports) => {
  var connectable = function(source, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connection = null;
    var { connector, resetOnDisconnect: _a } = config, resetOnDisconnect = _a === undefined ? true : _a;
    var subject = connector();
    var result = new Observable_1.Observable(function(subscriber) {
      return subject.subscribe(subscriber);
    });
    result.connect = function() {
      if (!connection || connection.closed) {
        connection = defer_1.defer(function() {
          return source;
        }).subscribe(subject);
        if (resetOnDisconnect) {
          connection.add(function() {
            return subject = connector();
          });
        }
      }
      return connection;
    };
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connectable = undefined;
  var Subject_1 = require_Subject();
  var Observable_1 = require_Observable();
  var defer_1 = require_defer();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    },
    resetOnDisconnect: true
  };
  exports.connectable = connectable;
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS((exports) => {
  var forkJoin = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
    var result = new Observable_1.Observable(function(subscriber) {
      var length = sources.length;
      if (!length) {
        subscriber.complete();
        return;
      }
      var values = new Array(length);
      var remainingCompletions = length;
      var remainingEmissions = length;
      var _loop_1 = function(sourceIndex2) {
        var hasValue = false;
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!hasValue) {
            hasValue = true;
            remainingEmissions--;
          }
          values[sourceIndex2] = value;
        }, function() {
          return remainingCompletions--;
        }, undefined, function() {
          if (!remainingCompletions || !hasValue) {
            if (!remainingEmissions) {
              subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
            }
            subscriber.complete();
          }
        }));
      };
      for (var sourceIndex = 0;sourceIndex < length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
    });
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.forkJoin = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var innerFrom_1 = require_innerFrom();
  var args_1 = require_args();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var createObject_1 = require_createObject();
  exports.forkJoin = forkJoin;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS((exports) => {
  var fromEvent = function(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
      resultSelector = options;
      options = undefined;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
    if (!add) {
      if (isArrayLike_1.isArrayLike(target)) {
        return mergeMap_1.mergeMap(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom_1.innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  };
  var toCommonHandlerRegistry = function(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  };
  var isNodeStyleEventEmitter = function(target) {
    return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
  };
  var isJQueryStyleEventEmitter = function(target) {
    return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
  };
  var isEventTarget = function(target) {
    return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEvent = undefined;
  var innerFrom_1 = require_innerFrom();
  var Observable_1 = require_Observable();
  var mergeMap_1 = require_mergeMap();
  var isArrayLike_1 = require_isArrayLike();
  var isFunction_1 = require_isFunction2();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  exports.fromEvent = fromEvent;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS((exports) => {
  var fromEventPattern = function(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
      return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var e = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          e[_i] = arguments[_i];
        }
        return subscriber.next(e.length === 1 ? e[0] : e);
      };
      var retValue = addHandler(handler);
      return isFunction_1.isFunction(removeHandler) ? function() {
        return removeHandler(handler, retValue);
      } : undefined;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEventPattern = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction2();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  exports.fromEventPattern = fromEventPattern;
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS((exports) => {
  var generate = function(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
    var _a, _b;
    var resultSelector;
    var initialState;
    if (arguments.length === 1) {
      _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === undefined ? identity_1.identity : _b, scheduler = _a.scheduler;
    } else {
      initialState = initialStateOrOptions;
      if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrScheduler;
      } else {
        resultSelector = resultSelectorOrScheduler;
      }
    }
    function gen() {
      var state;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            state = initialState;
            _a2.label = 1;
          case 1:
            if (!(!condition || condition(state)))
              return [3, 4];
            return [4, resultSelector(state)];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            state = iterate(state);
            return [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return defer_1.defer(scheduler ? function() {
      return scheduleIterable_1.scheduleIterable(gen(), scheduler);
    } : gen);
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generate = undefined;
  var identity_1 = require_identity();
  var isScheduler_1 = require_isScheduler();
  var defer_1 = require_defer();
  var scheduleIterable_1 = require_scheduleIterable();
  exports.generate = generate;
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS((exports) => {
  var iif = function(condition, trueResult, falseResult) {
    return defer_1.defer(function() {
      return condition() ? trueResult : falseResult;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iif = undefined;
  var defer_1 = require_defer();
  exports.iif = iif;
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS((exports) => {
  var timer = function(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === undefined) {
      dueTime = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler_1.isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable_1.Observable(function(subscriber) {
      var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n++);
          if (0 <= intervalDuration) {
            this.schedule(undefined, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timer = undefined;
  var Observable_1 = require_Observable();
  var async_1 = require_async();
  var isScheduler_1 = require_isScheduler();
  var isDate_1 = require_isDate();
  exports.timer = timer;
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS((exports) => {
  var interval = function(period, scheduler) {
    if (period === undefined) {
      period = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    if (period < 0) {
      period = 0;
    }
    return timer_1.timer(period, period, scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = undefined;
  var async_1 = require_async();
  var timer_1 = require_timer();
  exports.interval = interval;
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS((exports) => {
  var merge = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var mergeAll_1 = require_mergeAll();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS((exports) => {
  var never = function() {
    return exports.NEVER;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.never = exports.NEVER = undefined;
  var Observable_1 = require_Observable();
  var noop_1 = require_noop2();
  exports.NEVER = new Observable_1.Observable(noop_1.noop);
  exports.never = never;
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS((exports) => {
  var argsOrArgArray = function(args) {
    return args.length === 1 && isArray(args[0]) ? args[0] : args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsOrArgArray = undefined;
  var isArray = Array.isArray;
  exports.argsOrArgArray = argsOrArgArray;
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS((exports) => {
  var onErrorResumeNext = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return new Observable_1.Observable(function(subscriber) {
      var sourceIndex = 0;
      var subscribeNext = function() {
        if (sourceIndex < nextSources.length) {
          var nextSource = undefined;
          try {
            nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
          } catch (err) {
            subscribeNext();
            return;
          }
          var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, undefined, noop_1.noop, noop_1.noop);
          nextSource.subscribe(innerSubscriber);
          innerSubscriber.add(subscribeNext);
        } else {
          subscriber.complete();
        }
      };
      subscribeNext();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onErrorResumeNext = undefined;
  var Observable_1 = require_Observable();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop2();
  var innerFrom_1 = require_innerFrom();
  exports.onErrorResumeNext = onErrorResumeNext;
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS((exports) => {
  var pairs = function(obj, scheduler) {
    return from_1.from(Object.entries(obj), scheduler);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pairs = undefined;
  var from_1 = require_from();
  exports.pairs = pairs;
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS((exports) => {
  var not = function(pred, thisArg) {
    return function(value, index) {
      return !pred.call(thisArg, value, index);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.not = undefined;
  exports.not = not;
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS((exports) => {
  var filter = function(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filter = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.filter = filter;
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS((exports) => {
  var partition = function(source, predicate, thisArg) {
    return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.partition = undefined;
  var not_1 = require_not();
  var filter_1 = require_filter();
  var innerFrom_1 = require_innerFrom();
  exports.partition = partition;
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS((exports) => {
  var race = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    sources = argsOrArgArray_1.argsOrArgArray(sources);
    return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
  };
  var raceInit = function(sources) {
    return function(subscriber) {
      var subscriptions = [];
      var _loop_1 = function(i2) {
        subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (subscriptions) {
            for (var s = 0;s < subscriptions.length; s++) {
              s !== i2 && subscriptions[s].unsubscribe();
            }
            subscriptions = null;
          }
          subscriber.next(value);
        })));
      };
      for (var i = 0;subscriptions && !subscriber.closed && i < sources.length; i++) {
        _loop_1(i);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.raceInit = exports.race = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.race = race;
  exports.raceInit = raceInit;
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS((exports) => {
  var range = function(start, count, scheduler) {
    if (count == null) {
      count = start;
      start = 0;
    }
    if (count <= 0) {
      return empty_1.EMPTY;
    }
    var end = count + start;
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      var n = start;
      return scheduler.schedule(function() {
        if (n < end) {
          subscriber.next(n++);
          this.schedule();
        } else {
          subscriber.complete();
        }
      });
    } : function(subscriber) {
      var n = start;
      while (n < end && !subscriber.closed) {
        subscriber.next(n++);
      }
      subscriber.complete();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.range = undefined;
  var Observable_1 = require_Observable();
  var empty_1 = require_empty();
  exports.range = range;
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS((exports) => {
  var using = function(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      var resource = resourceFactory();
      var result = observableFactory(resource);
      var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
      source.subscribe(subscriber);
      return function() {
        if (resource) {
          resource.unsubscribe();
        }
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.using = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty();
  exports.using = using;
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS((exports) => {
  var zip = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var sources = argsOrArgArray_1.argsOrArgArray(args);
    return sources.length ? new Observable_1.Observable(function(subscriber) {
      var buffers = sources.map(function() {
        return [];
      });
      var completed = sources.map(function() {
        return false;
      });
      subscriber.add(function() {
        buffers = completed = null;
      });
      var _loop_1 = function(sourceIndex2) {
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffers[sourceIndex2].push(value);
          if (buffers.every(function(buffer) {
            return buffer.length;
          })) {
            var result = buffers.map(function(buffer) {
              return buffer.shift();
            });
            subscriber.next(resultSelector ? resultSelector.apply(undefined, __spreadArray([], __read(result))) : result);
            if (buffers.some(function(buffer, i) {
              return !buffer.length && completed[i];
            })) {
              subscriber.complete();
            }
          }
        }, function() {
          completed[sourceIndex2] = true;
          !buffers[sourceIndex2].length && subscriber.complete();
        }));
      };
      for (var sourceIndex = 0;!subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
      return function() {
        buffers = completed = null;
      };
    }) : empty_1.EMPTY;
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zip = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var empty_1 = require_empty();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var args_1 = require_args();
  exports.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS((exports) => {
  var audit = function(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var isComplete = false;
      var endDuration = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
        isComplete && subscriber.complete();
      };
      var cleanupDuration = function() {
        durationSubscriber = null;
        isComplete && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
        if (!durationSubscriber) {
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
        }
      }, function() {
        isComplete = true;
        (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.audit = undefined;
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.audit = audit;
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS((exports) => {
  var auditTime = function(duration, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return audit_1.audit(function() {
      return timer_1.timer(duration, scheduler);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.auditTime = undefined;
  var async_1 = require_async();
  var audit_1 = require_audit();
  var timer_1 = require_timer();
  exports.auditTime = auditTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS((exports) => {
  var buffer = function(closingNotifier) {
    return lift_1.operate(function(source, subscriber) {
      var currentBuffer = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return currentBuffer.push(value);
      }, function() {
        subscriber.next(currentBuffer);
        subscriber.complete();
      }));
      innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        var b = currentBuffer;
        currentBuffer = [];
        subscriber.next(b);
      }, noop_1.noop));
      return function() {
        currentBuffer = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buffer = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop2();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.buffer = buffer;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS((exports) => {
  var bufferCount = function(bufferSize, startBufferEvery) {
    if (startBufferEvery === undefined) {
      startBufferEvery = null;
    }
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== undefined ? startBufferEvery : bufferSize;
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      var count = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a, e_2, _b;
        var toEmit = null;
        if (count++ % startBufferEvery === 0) {
          buffers.push([]);
        }
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer = buffers_1_1.value;
            buffer.push(value);
            if (bufferSize <= buffer.length) {
              toEmit = toEmit !== null && toEmit !== undefined ? toEmit : [];
              toEmit.push(buffer);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
              _a.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (toEmit) {
          try {
            for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next();!toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
              var buffer = toEmit_1_1.value;
              arrRemove_1.arrRemove(buffers, buffer);
              subscriber.next(buffer);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                _b.call(toEmit_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      }, function() {
        var e_3, _a;
        try {
          for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next();!buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
            var buffer = buffers_2_1.value;
            subscriber.next(buffer);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
              _a.call(buffers_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffers = null;
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  exports.bufferCount = bufferCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS((exports) => {
  var bufferTime = function(bufferTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== undefined ? _a : async_1.asyncScheduler;
    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== undefined ? _b : null;
    var maxBufferSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var bufferRecords = [];
      var restartOnEmit = false;
      var emit = function(record) {
        var { buffer, subs } = record;
        subs.unsubscribe();
        arrRemove_1.arrRemove(bufferRecords, record);
        subscriber.next(buffer);
        restartOnEmit && startBuffer();
      };
      var startBuffer = function() {
        if (bufferRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var buffer = [];
          var record_1 = {
            buffer,
            subs
          };
          bufferRecords.push(record_1);
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return emit(record_1);
          }, bufferTimeSpan);
        }
      };
      if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
      } else {
        restartOnEmit = true;
      }
      startBuffer();
      var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2;
        var recordsCopy = bufferRecords.slice();
        try {
          for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next();!recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
            var record = recordsCopy_1_1.value;
            var buffer = record.buffer;
            buffer.push(value);
            maxBufferSize <= buffer.length && emit(record);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
              _a2.call(recordsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (bufferRecords === null || bufferRecords === undefined ? undefined : bufferRecords.length) {
          subscriber.next(bufferRecords.shift().buffer);
        }
        bufferTimeSubscriber === null || bufferTimeSubscriber === undefined || bufferTimeSubscriber.unsubscribe();
        subscriber.complete();
        subscriber.unsubscribe();
      }, undefined, function() {
        return bufferRecords = null;
      });
      source.subscribe(bufferTimeSubscriber);
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferTime = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var async_1 = require_async();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  exports.bufferTime = bufferTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS((exports) => {
  var bufferToggle = function(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var buffer = [];
        buffers.push(buffer);
        var closingSubscription = new Subscription_1.Subscription;
        var emitBuffer = function() {
          arrRemove_1.arrRemove(buffers, buffer);
          subscriber.next(buffer);
          closingSubscription.unsubscribe();
        };
        closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer = buffers_1_1.value;
            buffer.push(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
              _a.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (buffers.length > 0) {
          subscriber.next(buffers.shift());
        }
        subscriber.complete();
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferToggle = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop2();
  var arrRemove_1 = require_arrRemove();
  exports.bufferToggle = bufferToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS((exports) => {
  var bufferWhen = function(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffer = null;
      var closingSubscriber = null;
      var openBuffer = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        var b = buffer;
        buffer = [];
        b && subscriber.next(b);
        innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
      };
      openBuffer();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return buffer === null || buffer === undefined ? undefined : buffer.push(value);
      }, function() {
        buffer && subscriber.next(buffer);
        subscriber.complete();
      }, undefined, function() {
        return buffer = closingSubscriber = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferWhen = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop2();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.bufferWhen = bufferWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS((exports) => {
  var catchError = function(selector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err) {
        handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.catchError = undefined;
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  exports.catchError = catchError;
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS((exports) => {
  var scanInternals = function(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i = index++;
        state = hasState ? accumulator(state, value, i) : (hasState = true, value);
        emitOnNext && subscriber.next(state);
      }, emitBeforeComplete && function() {
        hasState && subscriber.next(state);
        subscriber.complete();
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scanInternals = undefined;
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.scanInternals = scanInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS((exports) => {
  var reduce = function(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reduce = undefined;
  var scanInternals_1 = require_scanInternals();
  var lift_1 = require_lift();
  exports.reduce = reduce;
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS((exports) => {
  var toArray = function() {
    return lift_1.operate(function(source, subscriber) {
      reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toArray = undefined;
  var reduce_1 = require_reduce();
  var lift_1 = require_lift();
  var arrReducer = function(arr, value) {
    return arr.push(value), arr;
  };
  exports.toArray = toArray;
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS((exports) => {
  var joinAllInternals = function(joinFn, project) {
    return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
      return joinFn(sources);
    }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.joinAllInternals = undefined;
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var mergeMap_1 = require_mergeMap();
  var toArray_1 = require_toArray();
  exports.joinAllInternals = joinAllInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS((exports) => {
  var combineLatestAll = function(project) {
    return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestAll = undefined;
  var combineLatest_1 = require_combineLatest();
  var joinAllInternals_1 = require_joinAllInternals();
  exports.combineLatestAll = combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineAll = undefined;
  var combineLatestAll_1 = require_combineLatestAll();
  exports.combineAll = combineLatestAll_1.combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS((exports) => {
  var combineLatest = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    return resultSelector ? pipe_1.pipe(combineLatest.apply(undefined, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
      combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatest = undefined;
  var combineLatest_1 = require_combineLatest();
  var lift_1 = require_lift();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var args_1 = require_args();
  exports.combineLatest = combineLatest;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS((exports) => {
  var combineLatestWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return combineLatest_1.combineLatest.apply(undefined, __spreadArray([], __read(otherSources)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestWith = undefined;
  var combineLatest_1 = require_combineLatest2();
  exports.combineLatestWith = combineLatestWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS((exports) => {
  var concatMap = function(project, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction2();
  exports.concatMap = concatMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS((exports) => {
  var concatMapTo = function(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
      return innerObservable;
    }, resultSelector) : concatMap_1.concatMap(function() {
      return innerObservable;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatMapTo = undefined;
  var concatMap_1 = require_concatMap();
  var isFunction_1 = require_isFunction2();
  exports.concatMapTo = concatMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS((exports) => {
  var concat = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return lift_1.operate(function(source, subscriber) {
      concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = undefined;
  var lift_1 = require_lift();
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.concat = concat;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS((exports) => {
  var concatWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return concat_1.concat.apply(undefined, __spreadArray([], __read(otherSources)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatWith = undefined;
  var concat_1 = require_concat2();
  exports.concatWith = concatWith;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS((exports) => {
  var fromSubscribable = function(subscribable) {
    return new Observable_1.Observable(function(subscriber) {
      return subscribable.subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromSubscribable = undefined;
  var Observable_1 = require_Observable();
  exports.fromSubscribable = fromSubscribable;
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect2 = __commonJS((exports) => {
  var connect = function(selector, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connector = config.connector;
    return lift_1.operate(function(source, subscriber) {
      var subject = connector();
      innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
      subscriber.add(source.subscribe(subject));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connect = undefined;
  var Subject_1 = require_Subject();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var fromSubscribable_1 = require_fromSubscribable();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    }
  };
  exports.connect = connect;
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS((exports) => {
  var count = function(predicate) {
    return reduce_1.reduce(function(total, value, i) {
      return !predicate || predicate(value, i) ? total + 1 : total;
    }, 0);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.count = undefined;
  var reduce_1 = require_reduce();
  exports.count = count;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS((exports) => {
  var debounce = function(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var emit = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        hasValue = true;
        lastValue = value;
        durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
        innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = durationSubscriber = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debounce = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop2();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.debounce = debounce;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS((exports) => {
  var debounceTime = function(dueTime, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var activeTask = null;
      var lastValue = null;
      var lastTime = null;
      var emit = function() {
        if (activeTask) {
          activeTask.unsubscribe();
          activeTask = null;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      function emitWhenIdle() {
        var targetTime = lastTime + dueTime;
        var now = scheduler.now();
        if (now < targetTime) {
          activeTask = this.schedule(undefined, targetTime - now);
          subscriber.add(activeTask);
          return;
        }
        emit();
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        lastValue = value;
        lastTime = scheduler.now();
        if (!activeTask) {
          activeTask = scheduler.schedule(emitWhenIdle, dueTime);
          subscriber.add(activeTask);
        }
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = activeTask = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debounceTime = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.debounceTime = debounceTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS((exports) => {
  var defaultIfEmpty = function(defaultValue) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultIfEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.defaultIfEmpty = defaultIfEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS((exports) => {
  var take = function(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.take = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.take = take;
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS((exports) => {
  var ignoreElements = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ignoreElements = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop2();
  exports.ignoreElements = ignoreElements;
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS((exports) => {
  var mapTo = function(value) {
    return map_1.map(function() {
      return value;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapTo = undefined;
  var map_1 = require_map();
  exports.mapTo = mapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS((exports) => {
  var delayWhen = function(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
      return function(source) {
        return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
      };
    }
    return mergeMap_1.mergeMap(function(value, index) {
      return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delayWhen = undefined;
  var concat_1 = require_concat();
  var take_1 = require_take();
  var ignoreElements_1 = require_ignoreElements();
  var mapTo_1 = require_mapTo();
  var mergeMap_1 = require_mergeMap();
  var innerFrom_1 = require_innerFrom();
  exports.delayWhen = delayWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS((exports) => {
  var delay = function(due, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration = timer_1.timer(due, scheduler);
    return delayWhen_1.delayWhen(function() {
      return duration;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = undefined;
  var async_1 = require_async();
  var delayWhen_1 = require_delayWhen();
  var timer_1 = require_timer();
  exports.delay = delay;
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS((exports) => {
  var dematerialize = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
        return Notification_1.observeNotification(notification, subscriber);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dematerialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.dematerialize = dematerialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS((exports) => {
  var distinct = function(keySelector, flushes) {
    return lift_1.operate(function(source, subscriber) {
      var distinctKeys = new Set;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var key = keySelector ? keySelector(value) : value;
        if (!distinctKeys.has(key)) {
          distinctKeys.add(key);
          subscriber.next(value);
        }
      }));
      flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return distinctKeys.clear();
      }, noop_1.noop));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinct = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop2();
  var innerFrom_1 = require_innerFrom();
  exports.distinct = distinct;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS((exports) => {
  var distinctUntilChanged = function(comparator, keySelector) {
    if (keySelector === undefined) {
      keySelector = identity_1.identity;
    }
    comparator = comparator !== null && comparator !== undefined ? comparator : defaultCompare;
    return lift_1.operate(function(source, subscriber) {
      var previousKey;
      var first = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var currentKey = keySelector(value);
        if (first || !comparator(previousKey, currentKey)) {
          first = false;
          previousKey = currentKey;
          subscriber.next(value);
        }
      }));
    });
  };
  var defaultCompare = function(a, b) {
    return a === b;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinctUntilChanged = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.distinctUntilChanged = distinctUntilChanged;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS((exports) => {
  var distinctUntilKeyChanged = function(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
      return compare ? compare(x[key], y[key]) : x[key] === y[key];
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinctUntilKeyChanged = undefined;
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS((exports) => {
  var throwIfEmpty = function(errorFactory) {
    if (errorFactory === undefined) {
      errorFactory = defaultErrorFactory;
    }
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  };
  var defaultErrorFactory = function() {
    return new EmptyError_1.EmptyError;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throwIfEmpty = undefined;
  var EmptyError_1 = require_EmptyError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.throwIfEmpty = throwIfEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS((exports) => {
  var elementAt = function(index, defaultValue) {
    if (index < 0) {
      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    }
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(filter_1.filter(function(v, i) {
        return i === index;
      }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.elementAt = undefined;
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  var filter_1 = require_filter();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var take_1 = require_take();
  exports.elementAt = elementAt;
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS((exports) => {
  var endWith = function() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    return function(source) {
      return concat_1.concat(source, of_1.of.apply(undefined, __spreadArray([], __read(values))));
    };
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.endWith = undefined;
  var concat_1 = require_concat();
  var of_1 = require_of();
  exports.endWith = endWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS((exports) => {
  var every = function(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (!predicate.call(thisArg, value, index++, source)) {
          subscriber.next(false);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.every = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.every = every;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS((exports) => {
  var exhaustMap = function(project, resultSelector) {
    if (resultSelector) {
      return function(source) {
        return source.pipe(exhaustMap(function(a, i) {
          return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          }));
        }));
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      var innerSub = null;
      var isComplete = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
        if (!innerSub) {
          innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
            innerSub = null;
            isComplete && subscriber.complete();
          });
          innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
        }
      }, function() {
        isComplete = true;
        !innerSub && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaustMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.exhaustMap = exhaustMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS((exports) => {
  var exhaustAll = function() {
    return exhaustMap_1.exhaustMap(identity_1.identity);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaustAll = undefined;
  var exhaustMap_1 = require_exhaustMap();
  var identity_1 = require_identity();
  exports.exhaustAll = exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaust = undefined;
  var exhaustAll_1 = require_exhaustAll();
  exports.exhaust = exhaustAll_1.exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS((exports) => {
  var expand = function(project, concurrent, scheduler) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.expand = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  exports.expand = expand;
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS((exports) => {
  var finalize = function(callback) {
    return lift_1.operate(function(source, subscriber) {
      try {
        source.subscribe(subscriber);
      } finally {
        subscriber.add(callback);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.finalize = undefined;
  var lift_1 = require_lift();
  exports.finalize = finalize;
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS((exports) => {
  var find = function(predicate, thisArg) {
    return lift_1.operate(createFind(predicate, thisArg, "value"));
  };
  var createFind = function(predicate, thisArg, emit) {
    var findIndex = emit === "index";
    return function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i = index++;
        if (predicate.call(thisArg, value, i, source)) {
          subscriber.next(findIndex ? i : value);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(findIndex ? -1 : undefined);
        subscriber.complete();
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFind = exports.find = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.find = find;
  exports.createFind = createFind;
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS((exports) => {
  var findIndex = function(predicate, thisArg) {
    return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findIndex = undefined;
  var lift_1 = require_lift();
  var find_1 = require_find();
  exports.findIndex = findIndex;
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS((exports) => {
  var first = function(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.first = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var take_1 = require_take();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var identity_1 = require_identity();
  exports.first = first;
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS((exports) => {
  var groupBy = function(keySelector, elementOrOptions, duration, connector) {
    return lift_1.operate(function(source, subscriber) {
      var element;
      if (!elementOrOptions || typeof elementOrOptions === "function") {
        element = elementOrOptions;
      } else {
        duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
      }
      var groups = new Map;
      var notify = function(cb) {
        groups.forEach(cb);
        cb(subscriber);
      };
      var handleError = function(err) {
        return notify(function(consumer) {
          return consumer.error(err);
        });
      };
      var activeGroups = 0;
      var teardownAttempted = false;
      var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
        try {
          var key_1 = keySelector(value);
          var group_1 = groups.get(key_1);
          if (!group_1) {
            groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject);
            var grouped = createGroupedObservable(key_1, group_1);
            subscriber.next(grouped);
            if (duration) {
              var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                group_1.complete();
                durationSubscriber_1 === null || durationSubscriber_1 === undefined || durationSubscriber_1.unsubscribe();
              }, undefined, undefined, function() {
                return groups.delete(key_1);
              });
              groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
            }
          }
          group_1.next(element ? element(value) : value);
        } catch (err) {
          handleError(err);
        }
      }, function() {
        return notify(function(consumer) {
          return consumer.complete();
        });
      }, handleError, function() {
        return groups.clear();
      }, function() {
        teardownAttempted = true;
        return activeGroups === 0;
      });
      source.subscribe(groupBySourceSubscriber);
      function createGroupedObservable(key, groupSubject) {
        var result = new Observable_1.Observable(function(groupSubscriber) {
          activeGroups++;
          var innerSub = groupSubject.subscribe(groupSubscriber);
          return function() {
            innerSub.unsubscribe();
            --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
          };
        });
        result.key = key;
        return result;
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.groupBy = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.groupBy = groupBy;
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS((exports) => {
  var isEmpty = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        subscriber.next(false);
        subscriber.complete();
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.isEmpty = isEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS((exports) => {
  var takeLast = function(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var buffer = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        buffer.push(value);
        count < buffer.length && buffer.shift();
      }, function() {
        var e_1, _a;
        try {
          for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next();!buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
            var value = buffer_1_1.value;
            subscriber.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
              _a.call(buffer_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffer = null;
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeLast = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.takeLast = takeLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS((exports) => {
  var last = function(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.last = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var takeLast_1 = require_takeLast();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var identity_1 = require_identity();
  exports.last = last;
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS((exports) => {
  var materialize = function() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(Notification_1.Notification.createNext(value));
      }, function() {
        subscriber.next(Notification_1.Notification.createComplete());
        subscriber.complete();
      }, function(err) {
        subscriber.next(Notification_1.Notification.createError(err));
        subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.materialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.materialize = materialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS((exports) => {
  var max = function(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
      return comparer(x, y) > 0 ? x : y;
    } : function(x, y) {
      return x > y ? x : y;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.max = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction2();
  exports.max = max;
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  exports.flatMap = mergeMap_1.mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS((exports) => {
  var mergeMapTo = function(innerObservable, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, resultSelector, concurrent);
    }
    if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function() {
      return innerObservable;
    }, concurrent);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeMapTo = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction2();
  exports.mergeMapTo = mergeMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS((exports) => {
  var mergeScan = function(accumulator, seed, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
        return accumulator(state, value, index);
      }, concurrent, function(value) {
        state = value;
      }, false, undefined, function() {
        return state = null;
      });
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeScan = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  exports.mergeScan = mergeScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS((exports) => {
  var merge = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    args = argsOrArgArray_1.argsOrArgArray(args);
    return lift_1.operate(function(source, subscriber) {
      mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var lift_1 = require_lift();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var mergeAll_1 = require_mergeAll();
  var args_1 = require_args();
  var from_1 = require_from();
  exports.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS((exports) => {
  var mergeWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return merge_1.merge.apply(undefined, __spreadArray([], __read(otherSources)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeWith = undefined;
  var merge_1 = require_merge2();
  exports.mergeWith = mergeWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS((exports) => {
  var min = function(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
      return comparer(x, y) < 0 ? x : y;
    } : function(x, y) {
      return x < y ? x : y;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.min = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction2();
  exports.min = min;
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS((exports) => {
  var multicast = function(subjectOrSubjectFactory, selector) {
    var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
      return subjectOrSubjectFactory;
    };
    if (isFunction_1.isFunction(selector)) {
      return connect_1.connect(selector, {
        connector: subjectFactory
      });
    }
    return function(source) {
      return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multicast = undefined;
  var ConnectableObservable_1 = require_ConnectableObservable();
  var isFunction_1 = require_isFunction2();
  var connect_1 = require_connect2();
  exports.multicast = multicast;
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS((exports) => {
  var onErrorResumeNextWith = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return function(source) {
      return onErrorResumeNext_1.onErrorResumeNext.apply(undefined, __spreadArray([source], __read(nextSources)));
    };
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onErrorResumeNext = exports.onErrorResumeNextWith = undefined;
  var argsOrArgArray_1 = require_argsOrArgArray();
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  exports.onErrorResumeNextWith = onErrorResumeNextWith;
  exports.onErrorResumeNext = onErrorResumeNextWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS((exports) => {
  var pairwise = function() {
    return lift_1.operate(function(source, subscriber) {
      var prev;
      var hasPrev = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var p = prev;
        prev = value;
        hasPrev && subscriber.next([p, value]);
        hasPrev = true;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pairwise = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.pairwise = pairwise;
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS((exports) => {
  var pluck = function() {
    var properties = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
      throw new Error("list of properties cannot be empty.");
    }
    return map_1.map(function(x) {
      var currentProp = x;
      for (var i = 0;i < length; i++) {
        var p = currentProp === null || currentProp === undefined ? undefined : currentProp[properties[i]];
        if (typeof p !== "undefined") {
          currentProp = p;
        } else {
          return;
        }
      }
      return currentProp;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pluck = undefined;
  var map_1 = require_map();
  exports.pluck = pluck;
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS((exports) => {
  var publish = function(selector) {
    return selector ? function(source) {
      return connect_1.connect(selector)(source);
    } : function(source) {
      return multicast_1.multicast(new Subject_1.Subject)(source);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publish = undefined;
  var Subject_1 = require_Subject();
  var multicast_1 = require_multicast();
  var connect_1 = require_connect2();
  exports.publish = publish;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS((exports) => {
  var publishBehavior = function(initialValue) {
    return function(source) {
      var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishBehavior = undefined;
  var BehaviorSubject_1 = require_BehaviorSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  exports.publishBehavior = publishBehavior;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS((exports) => {
  var publishLast = function() {
    return function(source) {
      var subject = new AsyncSubject_1.AsyncSubject;
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishLast = undefined;
  var AsyncSubject_1 = require_AsyncSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  exports.publishLast = publishLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS((exports) => {
  var publishReplay = function(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
    if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
      timestampProvider = selectorOrScheduler;
    }
    var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
    return function(source) {
      return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var multicast_1 = require_multicast();
  var isFunction_1 = require_isFunction2();
  exports.publishReplay = publishReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS((exports) => {
  var raceWith = function() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.raceWith = undefined;
  var race_1 = require_race();
  var lift_1 = require_lift();
  var identity_1 = require_identity();
  exports.raceWith = raceWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS((exports) => {
  var repeat = function(countOrConfig) {
    var _a;
    var count = Infinity;
    var delay;
    if (countOrConfig != null) {
      if (typeof countOrConfig === "object") {
        _a = countOrConfig.count, count = _a === undefined ? Infinity : _a, delay = countOrConfig.delay;
      } else {
        count = countOrConfig;
      }
    }
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var sourceSub;
      var resubscribe = function() {
        sourceSub === null || sourceSub === undefined || sourceSub.unsubscribe();
        sourceSub = null;
        if (delay != null) {
          var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
          var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            notifierSubscriber_1.unsubscribe();
            subscribeToSource();
          });
          notifier.subscribe(notifierSubscriber_1);
        } else {
          subscribeToSource();
        }
      };
      var subscribeToSource = function() {
        var syncUnsub = false;
        sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          if (++soFar < count) {
            if (sourceSub) {
              resubscribe();
            } else {
              syncUnsub = true;
            }
          } else {
            subscriber.complete();
          }
        }));
        if (syncUnsub) {
          resubscribe();
        }
      };
      subscribeToSource();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.repeat = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var timer_1 = require_timer();
  exports.repeat = repeat;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS((exports) => {
  var repeatWhen = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var completions$;
      var isNotifierComplete = false;
      var isMainComplete = false;
      var checkComplete = function() {
        return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
      };
      var getCompletionSubject = function() {
        if (!completions$) {
          completions$ = new Subject_1.Subject;
          innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            if (innerSub) {
              subscribeForRepeatWhen();
            } else {
              syncResub = true;
            }
          }, function() {
            isNotifierComplete = true;
            checkComplete();
          }));
        }
        return completions$;
      };
      var subscribeForRepeatWhen = function() {
        isMainComplete = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          isMainComplete = true;
          !checkComplete() && getCompletionSubject().next();
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRepeatWhen();
        }
      };
      subscribeForRepeatWhen();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.repeatWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.repeatWhen = repeatWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS((exports) => {
  var retry = function(configOrCount) {
    if (configOrCount === undefined) {
      configOrCount = Infinity;
    }
    var config;
    if (configOrCount && typeof configOrCount === "object") {
      config = configOrCount;
    } else {
      config = {
        count: configOrCount
      };
    }
    var _a = config.count, count = _a === undefined ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === undefined ? false : _b;
    return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var innerSub;
      var subscribeForRetry = function() {
        var syncUnsub = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (resetOnSuccess) {
            soFar = 0;
          }
          subscriber.next(value);
        }, undefined, function(err) {
          if (soFar++ < count) {
            var resub_1 = function() {
              if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
              } else {
                syncUnsub = true;
              }
            };
            if (delay != null) {
              var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
              var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                resub_1();
              }, function() {
                subscriber.complete();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              resub_1();
            }
          } else {
            subscriber.error(err);
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          subscribeForRetry();
        }
      };
      subscribeForRetry();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retry = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  var timer_1 = require_timer();
  var innerFrom_1 = require_innerFrom();
  exports.retry = retry;
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS((exports) => {
  var retryWhen = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var errors$;
      var subscribeForRetryWhen = function() {
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err) {
          if (!errors$) {
            errors$ = new Subject_1.Subject;
            innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              return innerSub ? subscribeForRetryWhen() : syncResub = true;
            }));
          }
          if (errors$) {
            errors$.next(err);
          }
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRetryWhen();
        }
      };
      subscribeForRetryWhen();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.retryWhen = retryWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS((exports) => {
  var sample = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
      }));
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      }, noop_1.noop));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sample = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var noop_1 = require_noop2();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.sample = sample;
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS((exports) => {
  var sampleTime = function(period, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return sample_1.sample(interval_1.interval(period, scheduler));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sampleTime = undefined;
  var async_1 = require_async();
  var sample_1 = require_sample();
  var interval_1 = require_interval();
  exports.sampleTime = sampleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS((exports) => {
  var scan = function(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scan = undefined;
  var lift_1 = require_lift();
  var scanInternals_1 = require_scanInternals();
  exports.scan = scan;
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS((exports) => {
  var sequenceEqual = function(compareTo, comparator) {
    if (comparator === undefined) {
      comparator = function(a, b) {
        return a === b;
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var aState = createState();
      var bState = createState();
      var emit = function(isEqual) {
        subscriber.next(isEqual);
        subscriber.complete();
      };
      var createSubscriber = function(selfState, otherState) {
        var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
          var { buffer, complete } = otherState;
          if (buffer.length === 0) {
            complete ? emit(false) : selfState.buffer.push(a);
          } else {
            !comparator(a, buffer.shift()) && emit(false);
          }
        }, function() {
          selfState.complete = true;
          var { complete, buffer } = otherState;
          complete && emit(buffer.length === 0);
          sequenceEqualSubscriber === null || sequenceEqualSubscriber === undefined || sequenceEqualSubscriber.unsubscribe();
        });
        return sequenceEqualSubscriber;
      };
      source.subscribe(createSubscriber(aState, bState));
      innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
    });
  };
  var createState = function() {
    return {
      buffer: [],
      complete: false
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sequenceEqual = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.sequenceEqual = sequenceEqual;
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS((exports) => {
  var share = function(options) {
    if (options === undefined) {
      options = {};
    }
    var _a = options.connector, connector = _a === undefined ? function() {
      return new Subject_1.Subject;
    } : _a, _b = options.resetOnError, resetOnError = _b === undefined ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === undefined ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === undefined ? true : _d;
    return function(wrapperSource) {
      var connection;
      var resetConnection;
      var subject;
      var refCount = 0;
      var hasCompleted = false;
      var hasErrored = false;
      var cancelReset = function() {
        resetConnection === null || resetConnection === undefined || resetConnection.unsubscribe();
        resetConnection = undefined;
      };
      var reset = function() {
        cancelReset();
        connection = subject = undefined;
        hasCompleted = hasErrored = false;
      };
      var resetAndUnsubscribe = function() {
        var conn = connection;
        reset();
        conn === null || conn === undefined || conn.unsubscribe();
      };
      return lift_1.operate(function(source, subscriber) {
        refCount++;
        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }
        var dest = subject = subject !== null && subject !== undefined ? subject : connector();
        subscriber.add(function() {
          refCount--;
          if (refCount === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);
        if (!connection && refCount > 0) {
          connection = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              return dest.next(value);
            },
            error: function(err) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err);
              dest.error(err);
            },
            complete: function() {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          innerFrom_1.innerFrom(source).subscribe(connection);
        }
      })(wrapperSource);
    };
  };
  var handleReset = function(reset, on) {
    var args = [];
    for (var _i = 2;_i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    if (on === true) {
      reset();
      return;
    }
    if (on === false) {
      return;
    }
    var onSubscriber = new Subscriber_1.SafeSubscriber({
      next: function() {
        onSubscriber.unsubscribe();
        reset();
      }
    });
    return innerFrom_1.innerFrom(on.apply(undefined, __spreadArray([], __read(args)))).subscribe(onSubscriber);
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.share = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var Subscriber_1 = require_Subscriber();
  var lift_1 = require_lift();
  exports.share = share;
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS((exports) => {
  var shareReplay = function(configOrBufferSize, windowTime, scheduler) {
    var _a, _b, _c;
    var bufferSize;
    var refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === "object") {
      _a = configOrBufferSize.bufferSize, bufferSize = _a === undefined ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === undefined ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === undefined ? false : _c, scheduler = configOrBufferSize.scheduler;
    } else {
      bufferSize = configOrBufferSize !== null && configOrBufferSize !== undefined ? configOrBufferSize : Infinity;
    }
    return share_1.share({
      connector: function() {
        return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
      },
      resetOnError: true,
      resetOnComplete: false,
      resetOnRefCountZero: refCount
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shareReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var share_1 = require_share();
  exports.shareReplay = shareReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS((exports) => {
  var single = function(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var singleValue;
      var seenValue = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        seenValue = true;
        if (!predicate || predicate(value, index++, source)) {
          hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
          hasValue = true;
          singleValue = value;
        }
      }, function() {
        if (hasValue) {
          subscriber.next(singleValue);
          subscriber.complete();
        } else {
          subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError);
        }
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.single = undefined;
  var EmptyError_1 = require_EmptyError();
  var SequenceError_1 = require_SequenceError();
  var NotFoundError_1 = require_NotFoundError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.single = single;
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS((exports) => {
  var skip = function(count) {
    return filter_1.filter(function(_, index) {
      return count <= index;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skip = undefined;
  var filter_1 = require_filter();
  exports.skip = skip;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS((exports) => {
  var skipLast = function(skipCount) {
    return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var ring = new Array(skipCount);
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var valueIndex = seen++;
        if (valueIndex < skipCount) {
          ring[valueIndex] = value;
        } else {
          var index = valueIndex % skipCount;
          var oldValue = ring[index];
          ring[index] = value;
          subscriber.next(oldValue);
        }
      }));
      return function() {
        ring = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipLast = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.skipLast = skipLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS((exports) => {
  var skipUntil = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        skipSubscriber === null || skipSubscriber === undefined || skipSubscriber.unsubscribe();
        taking = true;
      }, noop_1.noop);
      innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return taking && subscriber.next(value);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop2();
  exports.skipUntil = skipUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS((exports) => {
  var skipWhile = function(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.skipWhile = skipWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS((exports) => {
  var startWith = function() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(values);
    return lift_1.operate(function(source, subscriber) {
      (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.startWith = undefined;
  var concat_1 = require_concat();
  var args_1 = require_args();
  var lift_1 = require_lift();
  exports.startWith = startWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS((exports) => {
  var switchMap = function(project, resultSelector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === undefined || innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchMap = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.switchMap = switchMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS((exports) => {
  var switchAll = function() {
    return switchMap_1.switchMap(identity_1.identity);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchAll = undefined;
  var switchMap_1 = require_switchMap();
  var identity_1 = require_identity();
  exports.switchAll = switchAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS((exports) => {
  var switchMapTo = function(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
      return innerObservable;
    }, resultSelector) : switchMap_1.switchMap(function() {
      return innerObservable;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchMapTo = undefined;
  var switchMap_1 = require_switchMap();
  var isFunction_1 = require_isFunction2();
  exports.switchMapTo = switchMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS((exports) => {
  var switchScan = function(accumulator, seed) {
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      switchMap_1.switchMap(function(value, index) {
        return accumulator(state, value, index);
      }, function(_, innerValue) {
        return state = innerValue, innerValue;
      })(source).subscribe(subscriber);
      return function() {
        state = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchScan = undefined;
  var switchMap_1 = require_switchMap();
  var lift_1 = require_lift();
  exports.switchScan = switchScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS((exports) => {
  var takeUntil = function(notifier) {
    return lift_1.operate(function(source, subscriber) {
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop_1.noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop2();
  exports.takeUntil = takeUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS((exports) => {
  var takeWhile = function(predicate, inclusive) {
    if (inclusive === undefined) {
      inclusive = false;
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var result = predicate(value, index++);
        (result || inclusive) && subscriber.next(value);
        !result && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.takeWhile = takeWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS((exports) => {
  var tap = function(observerOrNext, error, complete) {
    var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
    return tapObserver ? lift_1.operate(function(source, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === undefined || _a.call(tapObserver);
      var isUnsub = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === undefined || _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === undefined || _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === undefined || _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === undefined || _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === undefined || _b.call(tapObserver);
      }));
    }) : identity_1.identity;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tap = undefined;
  var isFunction_1 = require_isFunction2();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  exports.tap = tap;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS((exports) => {
  var throttle = function(durationSelector, config) {
    return lift_1.operate(function(source, subscriber) {
      var _a = config !== null && config !== undefined ? config : {}, _b = _a.leading, leading = _b === undefined ? true : _b, _c = _a.trailing, trailing = _c === undefined ? false : _c;
      var hasValue = false;
      var sendValue = null;
      var throttled = null;
      var isComplete = false;
      var endThrottling = function() {
        throttled === null || throttled === undefined || throttled.unsubscribe();
        throttled = null;
        if (trailing) {
          send();
          isComplete && subscriber.complete();
        }
      };
      var cleanupThrottling = function() {
        throttled = null;
        isComplete && subscriber.complete();
      };
      var startThrottle = function(value) {
        return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
      };
      var send = function() {
        if (hasValue) {
          hasValue = false;
          var value = sendValue;
          sendValue = null;
          subscriber.next(value);
          !isComplete && startThrottle(value);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        sendValue = value;
        !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
      }, function() {
        isComplete = true;
        !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttle = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.throttle = throttle;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS((exports) => {
  var throttleTime = function(duration, scheduler, config) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration$ = timer_1.timer(duration, scheduler);
    return throttle_1.throttle(function() {
      return duration$;
    }, config);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttleTime = undefined;
  var async_1 = require_async();
  var throttle_1 = require_throttle();
  var timer_1 = require_timer();
  exports.throttleTime = throttleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS((exports) => {
  var timeInterval = function(scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var last = scheduler.now();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var now = scheduler.now();
        var interval = now - last;
        last = now;
        subscriber.next(new TimeInterval(value, interval));
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TimeInterval = exports.timeInterval = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.timeInterval = timeInterval;
  var TimeInterval = function() {
    function TimeInterval2(value, interval) {
      this.value = value;
      this.interval = interval;
    }
    return TimeInterval2;
  }();
  exports.TimeInterval = TimeInterval;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS((exports) => {
  var timeoutWith = function(due, withObservable, scheduler) {
    var first;
    var each;
    var _with;
    scheduler = scheduler !== null && scheduler !== undefined ? scheduler : async_1.async;
    if (isDate_1.isValidDate(due)) {
      first = due;
    } else if (typeof due === "number") {
      each = due;
    }
    if (withObservable) {
      _with = function() {
        return withObservable;
      };
    } else {
      throw new TypeError("No observable provided to switch to");
    }
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return timeout_1.timeout({
      first,
      each,
      scheduler,
      with: _with
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutWith = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var timeout_1 = require_timeout();
  exports.timeoutWith = timeoutWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var timestamp = function(timestampProvider) {
    if (timestampProvider === undefined) {
      timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
    }
    return map_1.map(function(value) {
      return { value, timestamp: timestampProvider.now() };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timestamp = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var map_1 = require_map();
  exports.timestamp = timestamp;
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS((exports) => {
  var window2 = function(windowBoundaries) {
    return lift_1.operate(function(source, subscriber) {
      var windowSubject = new Subject_1.Subject;
      subscriber.next(windowSubject.asObservable());
      var errorHandler = function(err) {
        windowSubject.error(err);
        subscriber.error(err);
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return windowSubject === null || windowSubject === undefined ? undefined : windowSubject.next(value);
      }, function() {
        windowSubject.complete();
        subscriber.complete();
      }, errorHandler));
      innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        windowSubject.complete();
        subscriber.next(windowSubject = new Subject_1.Subject);
      }, noop_1.noop, errorHandler));
      return function() {
        windowSubject === null || windowSubject === undefined || windowSubject.unsubscribe();
        windowSubject = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.window = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop2();
  var innerFrom_1 = require_innerFrom();
  exports.window = window2;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS((exports) => {
  var windowCount = function(windowSize, startWindowEvery) {
    if (startWindowEvery === undefined) {
      startWindowEvery = 0;
    }
    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
    return lift_1.operate(function(source, subscriber) {
      var windows = [new Subject_1.Subject];
      var starts = [];
      var count = 0;
      subscriber.next(windows[0].asObservable());
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        try {
          for (var windows_1 = __values(windows), windows_1_1 = windows_1.next();!windows_1_1.done; windows_1_1 = windows_1.next()) {
            var window_1 = windows_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
              _a.call(windows_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var c = count - windowSize + 1;
        if (c >= 0 && c % startEvery === 0) {
          windows.shift().complete();
        }
        if (++count % startEvery === 0) {
          var window_2 = new Subject_1.Subject;
          windows.push(window_2);
          subscriber.next(window_2.asObservable());
        }
      }, function() {
        while (windows.length > 0) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, function(err) {
        while (windows.length > 0) {
          windows.shift().error(err);
        }
        subscriber.error(err);
      }, function() {
        starts = null;
        windows = null;
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowCount = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  exports.windowCount = windowCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS((exports) => {
  var windowTime = function(windowTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== undefined ? _a : async_1.asyncScheduler;
    var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== undefined ? _b : null;
    var maxWindowSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var windowRecords = [];
      var restartOnClose = false;
      var closeWindow = function(record) {
        var { window: window2, subs } = record;
        window2.complete();
        subs.unsubscribe();
        arrRemove_1.arrRemove(windowRecords, record);
        restartOnClose && startWindow();
      };
      var startWindow = function() {
        if (windowRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var window_1 = new Subject_1.Subject;
          var record_1 = {
            window: window_1,
            subs,
            seen: 0
          };
          windowRecords.push(record_1);
          subscriber.next(window_1.asObservable());
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return closeWindow(record_1);
          }, windowTimeSpan);
        }
      };
      if (windowCreationInterval !== null && windowCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
      } else {
        restartOnClose = true;
      }
      startWindow();
      var loop = function(cb) {
        return windowRecords.slice().forEach(cb);
      };
      var terminate = function(cb) {
        loop(function(_a2) {
          var window2 = _a2.window;
          return cb(window2);
        });
        cb(subscriber);
        subscriber.unsubscribe();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        loop(function(record) {
          record.window.next(value);
          maxWindowSize <= ++record.seen && closeWindow(record);
        });
      }, function() {
        return terminate(function(consumer) {
          return consumer.complete();
        });
      }, function(err) {
        return terminate(function(consumer) {
          return consumer.error(err);
        });
      }));
      return function() {
        windowRecords = null;
      };
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowTime = undefined;
  var Subject_1 = require_Subject();
  var async_1 = require_async();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  exports.windowTime = windowTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS((exports) => {
  var windowToggle = function(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var windows = [];
      var handleError = function(err) {
        while (0 < windows.length) {
          windows.shift().error(err);
        }
        subscriber.error(err);
      };
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var window2 = new Subject_1.Subject;
        windows.push(window2);
        var closingSubscription = new Subscription_1.Subscription;
        var closeWindow = function() {
          arrRemove_1.arrRemove(windows, window2);
          window2.complete();
          closingSubscription.unsubscribe();
        };
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
        } catch (err) {
          handleError(err);
          return;
        }
        subscriber.next(window2.asObservable());
        closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a;
        var windowsCopy = windows.slice();
        try {
          for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next();!windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
            var window_1 = windowsCopy_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
              _a.call(windowsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (0 < windows.length) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, handleError, function() {
        while (0 < windows.length) {
          windows.shift().unsubscribe();
        }
      }));
    });
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = undefined;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowToggle = undefined;
  var Subject_1 = require_Subject();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop2();
  var arrRemove_1 = require_arrRemove();
  exports.windowToggle = windowToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS((exports) => {
  var windowWhen = function(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var window2;
      var closingSubscriber;
      var handleError = function(err) {
        window2.error(err);
        subscriber.error(err);
      };
      var openWindow = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 === null || window2 === undefined || window2.complete();
        window2 = new Subject_1.Subject;
        subscriber.next(window2.asObservable());
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector());
        } catch (err) {
          handleError(err);
          return;
        }
        closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
      };
      openWindow();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return window2.next(value);
      }, function() {
        window2.complete();
        subscriber.complete();
      }, handleError, function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 = null;
      }));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowWhen = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  exports.windowWhen = windowWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS((exports) => {
  var withLatestFrom = function() {
    var inputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      inputs[_i] = arguments[_i];
    }
    var project = args_1.popResultSelector(inputs);
    return lift_1.operate(function(source, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function() {
        return false;
      });
      var ready = false;
      var _loop_1 = function(i2) {
        innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          otherValues[i2] = value;
          if (!ready && !hasValue[i2]) {
            hasValue[i2] = true;
            (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
          }
        }, noop_1.noop));
      };
      for (var i = 0;i < len; i++) {
        _loop_1(i);
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (ready) {
          var values = __spreadArray([value], __read(otherValues));
          subscriber.next(project ? project.apply(undefined, __spreadArray([], __read(values))) : values);
        }
      }));
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.withLatestFrom = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var identity_1 = require_identity();
  var noop_1 = require_noop2();
  var args_1 = require_args();
  exports.withLatestFrom = withLatestFrom;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS((exports) => {
  var zipAll = function(project) {
    return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zipAll = undefined;
  var zip_1 = require_zip();
  var joinAllInternals_1 = require_joinAllInternals();
  exports.zipAll = zipAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS((exports) => {
  var zip = function() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    return lift_1.operate(function(source, subscriber) {
      zip_1.zip.apply(undefined, __spreadArray([source], __read(sources))).subscribe(subscriber);
    });
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zip = undefined;
  var zip_1 = require_zip();
  var lift_1 = require_lift();
  exports.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS((exports) => {
  var zipWith = function() {
    var otherInputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherInputs[_i] = arguments[_i];
    }
    return zip_1.zip.apply(undefined, __spreadArray([], __read(otherInputs)));
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i = 0, il = from.length, j = to.length;i < il; i++, j++)
      to[j] = from[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zipWith = undefined;
  var zip_1 = require_zip2();
  exports.zipWith = zipWith;
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = undefined;
  exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = undefined;
  exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = undefined;
  exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = undefined;
  var Observable_1 = require_Observable();
  Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
    return Observable_1.Observable;
  } });
  var ConnectableObservable_1 = require_ConnectableObservable();
  Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
    return ConnectableObservable_1.ConnectableObservable;
  } });
  var observable_1 = require_observable();
  Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
    return observable_1.observable;
  } });
  var animationFrames_1 = require_animationFrames();
  Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
    return animationFrames_1.animationFrames;
  } });
  var Subject_1 = require_Subject();
  Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
    return Subject_1.Subject;
  } });
  var BehaviorSubject_1 = require_BehaviorSubject();
  Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
    return BehaviorSubject_1.BehaviorSubject;
  } });
  var ReplaySubject_1 = require_ReplaySubject();
  Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
    return ReplaySubject_1.ReplaySubject;
  } });
  var AsyncSubject_1 = require_AsyncSubject();
  Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
    return AsyncSubject_1.AsyncSubject;
  } });
  var asap_1 = require_asap();
  Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
    return asap_1.asap;
  } });
  Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
    return asap_1.asapScheduler;
  } });
  var async_1 = require_async();
  Object.defineProperty(exports, "async", { enumerable: true, get: function() {
    return async_1.async;
  } });
  Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
    return async_1.asyncScheduler;
  } });
  var queue_1 = require_queue();
  Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
    return queue_1.queue;
  } });
  Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
    return queue_1.queueScheduler;
  } });
  var animationFrame_1 = require_animationFrame();
  Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
    return animationFrame_1.animationFrame;
  } });
  Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
    return animationFrame_1.animationFrameScheduler;
  } });
  var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
  Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualTimeScheduler;
  } });
  Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualAction;
  } });
  var Scheduler_1 = require_Scheduler();
  Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
    return Scheduler_1.Scheduler;
  } });
  var Subscription_1 = require_Subscription();
  Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
    return Subscription_1.Subscription;
  } });
  var Subscriber_1 = require_Subscriber();
  Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
    return Subscriber_1.Subscriber;
  } });
  var Notification_1 = require_Notification();
  Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
    return Notification_1.Notification;
  } });
  Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
    return Notification_1.NotificationKind;
  } });
  var pipe_1 = require_pipe();
  Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
    return pipe_1.pipe;
  } });
  var noop_1 = require_noop2();
  Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
    return noop_1.noop;
  } });
  var identity_1 = require_identity();
  Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
    return identity_1.identity;
  } });
  var isObservable_1 = require_isObservable();
  Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
    return isObservable_1.isObservable;
  } });
  var lastValueFrom_1 = require_lastValueFrom();
  Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
    return lastValueFrom_1.lastValueFrom;
  } });
  var firstValueFrom_1 = require_firstValueFrom();
  Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
    return firstValueFrom_1.firstValueFrom;
  } });
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
    return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
  } });
  var EmptyError_1 = require_EmptyError();
  Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
    return EmptyError_1.EmptyError;
  } });
  var NotFoundError_1 = require_NotFoundError();
  Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
    return NotFoundError_1.NotFoundError;
  } });
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
    return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
  } });
  var SequenceError_1 = require_SequenceError();
  Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
    return SequenceError_1.SequenceError;
  } });
  var timeout_1 = require_timeout();
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_1.TimeoutError;
  } });
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
    return UnsubscriptionError_1.UnsubscriptionError;
  } });
  var bindCallback_1 = require_bindCallback();
  Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
    return bindCallback_1.bindCallback;
  } });
  var bindNodeCallback_1 = require_bindNodeCallback();
  Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
    return bindNodeCallback_1.bindNodeCallback;
  } });
  var combineLatest_1 = require_combineLatest();
  Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
    return combineLatest_1.combineLatest;
  } });
  var concat_1 = require_concat();
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_1.concat;
  } });
  var connectable_1 = require_connectable();
  Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
    return connectable_1.connectable;
  } });
  var defer_1 = require_defer();
  Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
    return defer_1.defer;
  } });
  var empty_1 = require_empty();
  Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
    return empty_1.empty;
  } });
  var forkJoin_1 = require_forkJoin();
  Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
    return forkJoin_1.forkJoin;
  } });
  var from_1 = require_from();
  Object.defineProperty(exports, "from", { enumerable: true, get: function() {
    return from_1.from;
  } });
  var fromEvent_1 = require_fromEvent();
  Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
    return fromEvent_1.fromEvent;
  } });
  var fromEventPattern_1 = require_fromEventPattern();
  Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
    return fromEventPattern_1.fromEventPattern;
  } });
  var generate_1 = require_generate();
  Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
    return generate_1.generate;
  } });
  var iif_1 = require_iif();
  Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
    return iif_1.iif;
  } });
  var interval_1 = require_interval();
  Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
    return interval_1.interval;
  } });
  var merge_1 = require_merge();
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_1.merge;
  } });
  var never_1 = require_never();
  Object.defineProperty(exports, "never", { enumerable: true, get: function() {
    return never_1.never;
  } });
  var of_1 = require_of();
  Object.defineProperty(exports, "of", { enumerable: true, get: function() {
    return of_1.of;
  } });
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
    return onErrorResumeNext_1.onErrorResumeNext;
  } });
  var pairs_1 = require_pairs();
  Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
    return pairs_1.pairs;
  } });
  var partition_1 = require_partition();
  Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
    return partition_1.partition;
  } });
  var race_1 = require_race();
  Object.defineProperty(exports, "race", { enumerable: true, get: function() {
    return race_1.race;
  } });
  var range_1 = require_range();
  Object.defineProperty(exports, "range", { enumerable: true, get: function() {
    return range_1.range;
  } });
  var throwError_1 = require_throwError();
  Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
    return throwError_1.throwError;
  } });
  var timer_1 = require_timer();
  Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
    return timer_1.timer;
  } });
  var using_1 = require_using();
  Object.defineProperty(exports, "using", { enumerable: true, get: function() {
    return using_1.using;
  } });
  var zip_1 = require_zip();
  Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
    return zip_1.zip;
  } });
  var scheduled_1 = require_scheduled();
  Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
    return scheduled_1.scheduled;
  } });
  var empty_2 = require_empty();
  Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
    return empty_2.EMPTY;
  } });
  var never_2 = require_never();
  Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
    return never_2.NEVER;
  } });
  __exportStar(require_types(), exports);
  var config_1 = require_config();
  Object.defineProperty(exports, "config", { enumerable: true, get: function() {
    return config_1.config;
  } });
  var audit_1 = require_audit();
  Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
    return audit_1.audit;
  } });
  var auditTime_1 = require_auditTime();
  Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
    return auditTime_1.auditTime;
  } });
  var buffer_1 = require_buffer();
  Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
    return buffer_1.buffer;
  } });
  var bufferCount_1 = require_bufferCount();
  Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
    return bufferCount_1.bufferCount;
  } });
  var bufferTime_1 = require_bufferTime();
  Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
    return bufferTime_1.bufferTime;
  } });
  var bufferToggle_1 = require_bufferToggle();
  Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
    return bufferToggle_1.bufferToggle;
  } });
  var bufferWhen_1 = require_bufferWhen();
  Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
    return bufferWhen_1.bufferWhen;
  } });
  var catchError_1 = require_catchError();
  Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
    return catchError_1.catchError;
  } });
  var combineAll_1 = require_combineAll();
  Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
    return combineAll_1.combineAll;
  } });
  var combineLatestAll_1 = require_combineLatestAll();
  Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
    return combineLatestAll_1.combineLatestAll;
  } });
  var combineLatestWith_1 = require_combineLatestWith();
  Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
    return combineLatestWith_1.combineLatestWith;
  } });
  var concatAll_1 = require_concatAll();
  Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
    return concatAll_1.concatAll;
  } });
  var concatMap_1 = require_concatMap();
  Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
    return concatMap_1.concatMap;
  } });
  var concatMapTo_1 = require_concatMapTo();
  Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
    return concatMapTo_1.concatMapTo;
  } });
  var concatWith_1 = require_concatWith();
  Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
    return concatWith_1.concatWith;
  } });
  var connect_1 = require_connect2();
  Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
    return connect_1.connect;
  } });
  var count_1 = require_count();
  Object.defineProperty(exports, "count", { enumerable: true, get: function() {
    return count_1.count;
  } });
  var debounce_1 = require_debounce();
  Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
    return debounce_1.debounce;
  } });
  var debounceTime_1 = require_debounceTime();
  Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
    return debounceTime_1.debounceTime;
  } });
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
    return defaultIfEmpty_1.defaultIfEmpty;
  } });
  var delay_1 = require_delay();
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_1.delay;
  } });
  var delayWhen_1 = require_delayWhen();
  Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
    return delayWhen_1.delayWhen;
  } });
  var dematerialize_1 = require_dematerialize();
  Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
    return dematerialize_1.dematerialize;
  } });
  var distinct_1 = require_distinct();
  Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
    return distinct_1.distinct;
  } });
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
    return distinctUntilChanged_1.distinctUntilChanged;
  } });
  var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
  Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
    return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
  } });
  var elementAt_1 = require_elementAt();
  Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
    return elementAt_1.elementAt;
  } });
  var endWith_1 = require_endWith();
  Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
    return endWith_1.endWith;
  } });
  var every_1 = require_every();
  Object.defineProperty(exports, "every", { enumerable: true, get: function() {
    return every_1.every;
  } });
  var exhaust_1 = require_exhaust();
  Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
    return exhaust_1.exhaust;
  } });
  var exhaustAll_1 = require_exhaustAll();
  Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
    return exhaustAll_1.exhaustAll;
  } });
  var exhaustMap_1 = require_exhaustMap();
  Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
    return exhaustMap_1.exhaustMap;
  } });
  var expand_1 = require_expand();
  Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
    return expand_1.expand;
  } });
  var filter_1 = require_filter();
  Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
    return filter_1.filter;
  } });
  var finalize_1 = require_finalize();
  Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
    return finalize_1.finalize;
  } });
  var find_1 = require_find();
  Object.defineProperty(exports, "find", { enumerable: true, get: function() {
    return find_1.find;
  } });
  var findIndex_1 = require_findIndex();
  Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
    return findIndex_1.findIndex;
  } });
  var first_1 = require_first();
  Object.defineProperty(exports, "first", { enumerable: true, get: function() {
    return first_1.first;
  } });
  var groupBy_1 = require_groupBy();
  Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
    return groupBy_1.groupBy;
  } });
  var ignoreElements_1 = require_ignoreElements();
  Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
    return ignoreElements_1.ignoreElements;
  } });
  var isEmpty_1 = require_isEmpty();
  Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
    return isEmpty_1.isEmpty;
  } });
  var last_1 = require_last();
  Object.defineProperty(exports, "last", { enumerable: true, get: function() {
    return last_1.last;
  } });
  var map_1 = require_map();
  Object.defineProperty(exports, "map", { enumerable: true, get: function() {
    return map_1.map;
  } });
  var mapTo_1 = require_mapTo();
  Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
    return mapTo_1.mapTo;
  } });
  var materialize_1 = require_materialize();
  Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
    return materialize_1.materialize;
  } });
  var max_1 = require_max();
  Object.defineProperty(exports, "max", { enumerable: true, get: function() {
    return max_1.max;
  } });
  var mergeAll_1 = require_mergeAll();
  Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
    return mergeAll_1.mergeAll;
  } });
  var flatMap_1 = require_flatMap();
  Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
    return flatMap_1.flatMap;
  } });
  var mergeMap_1 = require_mergeMap();
  Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
    return mergeMap_1.mergeMap;
  } });
  var mergeMapTo_1 = require_mergeMapTo();
  Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
    return mergeMapTo_1.mergeMapTo;
  } });
  var mergeScan_1 = require_mergeScan();
  Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
    return mergeScan_1.mergeScan;
  } });
  var mergeWith_1 = require_mergeWith();
  Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
    return mergeWith_1.mergeWith;
  } });
  var min_1 = require_min();
  Object.defineProperty(exports, "min", { enumerable: true, get: function() {
    return min_1.min;
  } });
  var multicast_1 = require_multicast();
  Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
    return multicast_1.multicast;
  } });
  var observeOn_1 = require_observeOn();
  Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
    return observeOn_1.observeOn;
  } });
  var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
  Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
    return onErrorResumeNextWith_1.onErrorResumeNextWith;
  } });
  var pairwise_1 = require_pairwise();
  Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
    return pairwise_1.pairwise;
  } });
  var pluck_1 = require_pluck();
  Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
    return pluck_1.pluck;
  } });
  var publish_1 = require_publish();
  Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
    return publish_1.publish;
  } });
  var publishBehavior_1 = require_publishBehavior();
  Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
    return publishBehavior_1.publishBehavior;
  } });
  var publishLast_1 = require_publishLast();
  Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
    return publishLast_1.publishLast;
  } });
  var publishReplay_1 = require_publishReplay();
  Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
    return publishReplay_1.publishReplay;
  } });
  var raceWith_1 = require_raceWith();
  Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
    return raceWith_1.raceWith;
  } });
  var reduce_1 = require_reduce();
  Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
    return reduce_1.reduce;
  } });
  var repeat_1 = require_repeat();
  Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
    return repeat_1.repeat;
  } });
  var repeatWhen_1 = require_repeatWhen();
  Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
    return repeatWhen_1.repeatWhen;
  } });
  var retry_1 = require_retry();
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var retryWhen_1 = require_retryWhen();
  Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
    return retryWhen_1.retryWhen;
  } });
  var refCount_1 = require_refCount();
  Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
    return refCount_1.refCount;
  } });
  var sample_1 = require_sample();
  Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
    return sample_1.sample;
  } });
  var sampleTime_1 = require_sampleTime();
  Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
    return sampleTime_1.sampleTime;
  } });
  var scan_1 = require_scan();
  Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
    return scan_1.scan;
  } });
  var sequenceEqual_1 = require_sequenceEqual();
  Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
    return sequenceEqual_1.sequenceEqual;
  } });
  var share_1 = require_share();
  Object.defineProperty(exports, "share", { enumerable: true, get: function() {
    return share_1.share;
  } });
  var shareReplay_1 = require_shareReplay();
  Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
    return shareReplay_1.shareReplay;
  } });
  var single_1 = require_single();
  Object.defineProperty(exports, "single", { enumerable: true, get: function() {
    return single_1.single;
  } });
  var skip_1 = require_skip();
  Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
    return skip_1.skip;
  } });
  var skipLast_1 = require_skipLast();
  Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
    return skipLast_1.skipLast;
  } });
  var skipUntil_1 = require_skipUntil();
  Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
    return skipUntil_1.skipUntil;
  } });
  var skipWhile_1 = require_skipWhile();
  Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
    return skipWhile_1.skipWhile;
  } });
  var startWith_1 = require_startWith();
  Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
    return startWith_1.startWith;
  } });
  var subscribeOn_1 = require_subscribeOn();
  Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
    return subscribeOn_1.subscribeOn;
  } });
  var switchAll_1 = require_switchAll();
  Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
    return switchAll_1.switchAll;
  } });
  var switchMap_1 = require_switchMap();
  Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
    return switchMap_1.switchMap;
  } });
  var switchMapTo_1 = require_switchMapTo();
  Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
    return switchMapTo_1.switchMapTo;
  } });
  var switchScan_1 = require_switchScan();
  Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
    return switchScan_1.switchScan;
  } });
  var take_1 = require_take();
  Object.defineProperty(exports, "take", { enumerable: true, get: function() {
    return take_1.take;
  } });
  var takeLast_1 = require_takeLast();
  Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
    return takeLast_1.takeLast;
  } });
  var takeUntil_1 = require_takeUntil();
  Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
    return takeUntil_1.takeUntil;
  } });
  var takeWhile_1 = require_takeWhile();
  Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
    return takeWhile_1.takeWhile;
  } });
  var tap_1 = require_tap();
  Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
    return tap_1.tap;
  } });
  var throttle_1 = require_throttle();
  Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
    return throttle_1.throttle;
  } });
  var throttleTime_1 = require_throttleTime();
  Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
    return throttleTime_1.throttleTime;
  } });
  var throwIfEmpty_1 = require_throwIfEmpty();
  Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
    return throwIfEmpty_1.throwIfEmpty;
  } });
  var timeInterval_1 = require_timeInterval();
  Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
    return timeInterval_1.timeInterval;
  } });
  var timeout_2 = require_timeout();
  Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
    return timeout_2.timeout;
  } });
  var timeoutWith_1 = require_timeoutWith();
  Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
    return timeoutWith_1.timeoutWith;
  } });
  var timestamp_1 = require_timestamp();
  Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
    return timestamp_1.timestamp;
  } });
  var toArray_1 = require_toArray();
  Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
    return toArray_1.toArray;
  } });
  var window_1 = require_window();
  Object.defineProperty(exports, "window", { enumerable: true, get: function() {
    return window_1.window;
  } });
  var windowCount_1 = require_windowCount();
  Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
    return windowCount_1.windowCount;
  } });
  var windowTime_1 = require_windowTime();
  Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
    return windowTime_1.windowTime;
  } });
  var windowToggle_1 = require_windowToggle();
  Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
    return windowToggle_1.windowToggle;
  } });
  var windowWhen_1 = require_windowWhen();
  Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
    return windowWhen_1.windowWhen;
  } });
  var withLatestFrom_1 = require_withLatestFrom();
  Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
    return withLatestFrom_1.withLatestFrom;
  } });
  var zipAll_1 = require_zipAll();
  Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
    return zipAll_1.zipAll;
  } });
  var zipWith_1 = require_zipWith();
  Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
    return zipWith_1.zipWith;
  } });
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports, module) => {
  var DelayedStream = function() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  };
  var Stream = __require("stream").Stream;
  var util = __require("util");
  module.exports = DelayedStream;
  util.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this;
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {
    });
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports, module) => {
  var CombinedStream = function() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  };
  var util = __require("util");
  var Stream = __require("stream").Stream;
  var DelayedStream = require_delayed_stream();
  module.exports = CombinedStream;
  util.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this;
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, { end: false });
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
      this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
      this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  var charset = function(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  };
  var contentType = function(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  };
  var extension = function(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  };
  var lookup = function(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  };
  var populateMaps = function(extensions, types) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  };
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = __require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
});

// node_modules/asynckit/lib/defer.js
var require_defer2 = __commonJS((exports, module) => {
  var defer = function(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  };
  module.exports = defer;
});

// node_modules/asynckit/lib/async.js
var require_async2 = __commonJS((exports, module) => {
  var async = function(callback) {
    var isAsync = false;
    defer(function() {
      isAsync = true;
    });
    return function async_callback(err, result) {
      if (isAsync) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  };
  var defer = require_defer2();
  module.exports = async;
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports, module) => {
  var abort = function(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    state.jobs = {};
  };
  var clean = function(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  };
  module.exports = abort;
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports, module) => {
  var iterate = function(list, iterator, state, callback) {
    var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
      if (!(key in state.jobs)) {
        return;
      }
      delete state.jobs[key];
      if (error) {
        abort(state);
      } else {
        state.results[key] = output;
      }
      callback(error, state.results);
    });
  };
  var runJob = function(iterator, key, item, callback) {
    var aborter;
    if (iterator.length == 2) {
      aborter = iterator(item, async(callback));
    } else {
      aborter = iterator(item, key, async(callback));
    }
    return aborter;
  };
  var async = require_async2();
  var abort = require_abort();
  module.exports = iterate;
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports, module) => {
  var state = function(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  };
  module.exports = state;
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports, module) => {
  var terminator = function(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  };
  var abort = require_abort();
  var async = require_async2();
  module.exports = terminator;
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports, module) => {
  var parallel = function(list, iterator, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator, state, function(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  };
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = parallel;
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports, module) => {
  var serialOrdered = function(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  };
  var ascending = function(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  };
  var descending = function(a, b) {
    return -1 * ascending(a, b);
  };
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module.exports = serialOrdered;
  module.exports.ascending = ascending;
  module.exports.descending = descending;
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS((exports, module) => {
  var serial = function(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
  };
  var serialOrdered = require_serialOrdered();
  module.exports = serial;
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports, module) => {
  module.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered()
  };
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports, module) => {
  module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports, module) => {
  var FormData2 = function(options) {
    if (!(this instanceof FormData2)) {
      return new FormData2(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  };
  var CombinedStream = require_combined_stream();
  var util = __require("util");
  var path = __require("path");
  var http = __require("http");
  var https = __require("https");
  var parseUrl = __require("url").parse;
  var fs = __require("fs");
  var Stream = __require("stream").Stream;
  var mime = require_mime_types();
  var asynckit = require_asynckit();
  var populate = require_populate();
  module.exports = FormData2;
  util.inherits(FormData2, CombinedStream);
  FormData2.LINE_BREAK = "\r\n";
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options == "string") {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number") {
      value = "" + value;
    }
    if (util.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    if (value.hasOwnProperty("fd")) {
      if (value.end != null && value.end != Infinity && value.start != null) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (value.hasOwnProperty("httpVersion")) {
      callback(null, +value.headers["content-length"]);
    } else if (value.hasOwnProperty("httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, +response.headers["content-length"]);
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header == "object") {
      populate(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (!headers.hasOwnProperty(prop))
        continue;
      header = headers[prop];
      if (header == null) {
        continue;
      }
      if (!Array.isArray(header)) {
        header = [header];
      }
      if (header.length) {
        contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
      }
    }
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === "string") {
      filename = path.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value.name || value.path) {
      filename = path.basename(options.filename || value.name || value.path);
    } else if (value.readable && value.hasOwnProperty("httpVersion")) {
      filename = path.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && typeof value == "object") {
      contentType = FormData2.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData2.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData2.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (userHeaders.hasOwnProperty(header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData2.prototype.setBoundary = function(boundary) {
    this._boundary = boundary;
  };
  FormData2.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i = 0, len = this._streams.length;i < len; i++) {
      if (typeof this._streams[i] !== "function") {
        if (Buffer.isBuffer(this._streams[i])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
        }
        if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0;i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request, options, defaults = { method: "post" };
    if (typeof params == "string") {
      params = parseUrl(params);
      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults);
    } else {
      options = populate(params, defaults);
      if (!options.port) {
        options.port = options.protocol == "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request.setHeader("Content-Length", length);
      }
      this.pipe(request);
      if (cb) {
        var onResponse;
        var callback = function(error, responce) {
          request.removeListener("error", callback);
          request.removeListener("response", onResponse);
          return cb.call(this, error, responce);
        };
        onResponse = callback.bind(this, null);
        request.on("error", callback);
        request.on("response", onResponse);
      }
    }.bind(this));
    return request;
  };
  FormData2.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug;
  module.exports = function() {
    if (!debug) {
      try {
        debug = (()=>{throw new Error(`Cannot require module "debug"`);})()("follow-redirects");
      } catch (error) {
      }
      if (typeof debug !== "function") {
        debug = function() {
        };
      }
    }
    debug.apply(null, arguments);
  };
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS((exports, module) => {
  var RedirectableRequest = function(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      try {
        self2._processResponse(response);
      } catch (cause) {
        self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
      }
    };
    this._performRequest();
  };
  var wrap = function(protocols) {
    var exports2 = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
      function request(input, options, callback) {
        if (isURL(input)) {
          input = spreadUrlObject(input);
        } else if (isString2(input)) {
          input = spreadUrlObject(parseUrl2(input));
        } else {
          callback = options;
          options = validateUrl(input);
          input = { protocol };
        }
        if (isFunction2(options)) {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports2.maxRedirects,
          maxBodyLength: exports2.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        if (!isString2(options.host) && !isString2(options.hostname)) {
          options.hostname = "::1";
        }
        assert.equal(options.protocol, protocol, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: { value: request, configurable: true, enumerable: true, writable: true },
        get: { value: get, configurable: true, enumerable: true, writable: true }
      });
    });
    return exports2;
  };
  var noop2 = function() {
  };
  var parseUrl2 = function(input) {
    var parsed;
    if (useNativeURL) {
      parsed = new URL2(input);
    } else {
      parsed = validateUrl(url2.parse(input));
      if (!isString2(parsed.protocol)) {
        throw new InvalidUrlError({ input });
      }
    }
    return parsed;
  };
  var resolveUrl = function(relative, base) {
    return useNativeURL ? new URL2(relative, base) : parseUrl2(url2.resolve(base, relative));
  };
  var validateUrl = function(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    return input;
  };
  var spreadUrlObject = function(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields) {
      spread[key] = urlObject[key];
    }
    if (spread.hostname.startsWith("[")) {
      spread.hostname = spread.hostname.slice(1, -1);
    }
    if (spread.port !== "") {
      spread.port = Number(spread.port);
    }
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
  };
  var removeMatchingHeaders = function(regex, headers) {
    var lastValue;
    for (var header in headers) {
      if (regex.test(header)) {
        lastValue = headers[header];
        delete headers[header];
      }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
  };
  var createErrorType = function(code, message, baseClass) {
    function CustomError(properties) {
      Error.captureStackTrace(this, this.constructor);
      Object.assign(this, properties || {});
      this.code = code;
      this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    CustomError.prototype = new (baseClass || Error);
    Object.defineProperties(CustomError.prototype, {
      constructor: {
        value: CustomError,
        enumerable: false
      },
      name: {
        value: "Error [" + code + "]",
        enumerable: false
      }
    });
    return CustomError;
  };
  var destroyRequest = function(request, error) {
    for (var event of events) {
      request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop2);
    request.destroy(error);
  };
  var isSubdomain = function(subdomain, domain) {
    assert(isString2(subdomain) && isString2(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
  };
  var isString2 = function(value) {
    return typeof value === "string" || value instanceof String;
  };
  var isFunction2 = function(value) {
    return typeof value === "function";
  };
  var isBuffer2 = function(value) {
    return typeof value === "object" && "length" in value;
  };
  var isURL = function(value) {
    return URL2 && value instanceof URL2;
  };
  var url2 = __require("url");
  var URL2 = url2.URL;
  var http = __require("http");
  var https = __require("https");
  var Writable = __require("stream").Writable;
  var assert = __require("assert");
  var debug = require_debug();
  var useNativeURL = false;
  try {
    assert(new URL2);
  } catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
  }
  var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
  ];
  var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
  var eventHandlers = Object.create(null);
  events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
  var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
  var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
  var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
  var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  var destroy = Writable.prototype.destroy || noop2;
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
  };
  RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
  };
  RedirectableRequest.prototype.write = function(data, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError;
    }
    if (!isString2(data) && !isBuffer2(data)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (data.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data.length;
      this._requestBodyBuffers.push({ data, encoding });
      this._currentRequest.write(data, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError);
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data, encoding, callback) {
    if (isFunction2(data)) {
      callback = data;
      data = encoding = null;
    } else if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (!data) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    function destroyOnTimeout(socket) {
      socket.setTimeout(msecs);
      socket.removeListener("timeout", socket.destroy);
      socket.addListener("timeout", socket.destroy);
    }
    function startTimer(socket) {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
      destroyOnTimeout(socket);
    }
    function clearTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
        self2._timeout = null;
      }
      self2.removeListener("abort", clearTimer);
      self2.removeListener("error", clearTimer);
      self2.removeListener("response", clearTimer);
      self2.removeListener("close", clearTimer);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!self2.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (callback) {
      this.on("timeout", callback);
    }
    if (this.socket) {
      startTimer(this.socket);
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      throw new TypeError("Unsupported protocol " + protocol);
    }
    if (this._options.agents) {
      var scheme = protocol.slice(0, -1);
      this._options.agent = this._options.agents[scheme];
    }
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events) {
      request.on(event, eventHandlers[event]);
    }
    this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : this._options.path;
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error) {
        if (request === self2._currentRequest) {
          if (error) {
            self2.emit("error", error);
          } else if (i < buffers.length) {
            var buffer = buffers[i++];
            if (!request.finished) {
              request.write(buffer.data, buffer.encoding, writeNext);
            }
          } else if (self2._ended) {
            request.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
      return;
    }
    destroyRequest(this._currentRequest);
    response.destroy();
    if (++this._redirectCount > this._options.maxRedirects) {
      throw new TooManyRedirectsError;
    }
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
      requestHeaders = Object.assign({
        Host: response.req.getHeader("host")
      }, this._options.headers);
    }
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    var currentUrlParts = parseUrl2(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
      removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
    }
    if (isFunction2(beforeRedirect)) {
      var responseDetails = {
        headers: response.headers,
        statusCode
      };
      var requestDetails = {
        url: currentUrl,
        method,
        headers: requestHeaders
      };
      beforeRedirect(this._options, responseDetails, requestDetails);
      this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  module.exports = wrap({ http, https });
  module.exports.wrap = wrap;
});

// node_modules/dotenv/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.4.4",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      "lint-readme": "standard-markdown",
      pretest: "npm run lint && npm run dts-check",
      test: "tap tests/*.js --100 -Rspec",
      "test:coverage": "tap --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@definitelytyped/dtslint": "^0.0.133",
      "@types/node": "^18.11.3",
      decache: "^4.6.1",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-markdown": "^7.1.0",
      "standard-version": "^9.5.0",
      tap: "^16.3.0",
      tar: "^6.1.11",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main2 = __commonJS((exports, module) => {
  var parse2 = function(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match2;
    while ((match2 = LINE.exec(lines)) != null) {
      const key = match2[1];
      let value = match2[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, "\n");
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  };
  var _parseVault = function(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  };
  var _log = function(message) {
    console.log(`[dotenv@${version}][INFO] ${message}`);
  };
  var _warn = function(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  };
  var _debug = function(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  };
  var _dotenvKey = function(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  };
  var _instructions = function(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  };
  var _vaultPath = function(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  };
  var _resolveHome = function(envPath) {
    return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  };
  var _configVault = function(options) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  };
  var configDotenv = function(options) {
    const dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPathsThatExist = [];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        if (fs.existsSync(options.path)) {
          optionPathsThatExist = [_resolveHome(options.path)];
        }
      } else {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            optionPathsThatExist.push(_resolveHome(filepath));
          }
        }
      }
      if (!optionPathsThatExist.length) {
        optionPathsThatExist = [dotenvPath];
      }
    }
    const pathsToProcess = optionPathsThatExist.length ? optionPathsThatExist : [dotenvPath];
    const parsed = {};
    try {
      for (const path2 of pathsToProcess) {
        const singleFileParsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
        DotenvModule.populate(parsed, singleFileParsed, options);
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
    } catch (e) {
      if (debug) {
        _debug(`Failed to load ${pathsToProcess} ${e.message}`);
      }
      return { error: e };
    }
    return { parsed };
  };
  var config = function(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  };
  var decrypt = function(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error;
      }
    }
  };
  var populate = function(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  };
  var fs = __require("fs");
  var path = __require("path");
  var os = __require("os");
  var crypto = __require("crypto");
  var packageJson = require_package2();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse: parse2,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// bot.ts
var import_discord3 = __toESM(require_src(), 1);

// client.ts
var import_discord = __toESM(require_src(), 1);
function sendMessage(message) {
  if (!process.env.DISCORD_CHANNEL_ID)
    return;
  const channel = client.channels.cache.get(process.env.DISCORD_CHANNEL_ID);
  if (!channel || !channel.isTextBased())
    return;
  return channel.send({ embeds: [message] });
}
var client = new import_discord.Client({ intents: [import_discord.GatewayIntentBits.Guilds, import_discord.GatewayIntentBits.GuildMessages] });

// products-checker.ts
var import_rxjs = __toESM(require_cjs4(), 1);

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var isBuffer = function(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
};
var isArrayBufferView = function(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
};
var forEach = function(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length;i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0;i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
};
var findKey = function(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
};
var merge = function() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length;i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
};
var isSpecCompliantForm = function(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
};
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
var isArrayBuffer = kindOfTest("ArrayBuffer");
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method \'" + name + "\'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = undefined;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/AxiosError.js
var AxiosError = function(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
};
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

// node_modules/axios/lib/helpers/toFormData.js
var isVisitable = function(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
};
var removeBrackets = function(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
};
var renderKey = function(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
};
var isFlatArray = function(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
};
var toFormData = function(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData);
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(formData, el, utils_default.isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
};
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
var encode = function(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
};
var AxiosURLSearchParams = function(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
};
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
var encode2 = function(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
};
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
import url from "url";
var URLSearchParams_default = url.URLSearchParams;

// node_modules/axios/lib/platform/node/index.js
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  protocols: ["http", "https", "file", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var exports_utils = {};
__export(exports_utils, {
  hasStandardBrowserWebWorkerEnv: () => {
    {
      return hasStandardBrowserWebWorkerEnv;
    }
  },
  hasStandardBrowserEnv: () => {
    {
      return hasStandardBrowserEnv;
    }
  },
  hasBrowserEnv: () => {
    {
      return hasBrowserEnv;
    }
  }
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...exports_utils,
  ...node_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams, Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
var parsePropPath = function(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
};
var arrayToObject = function(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0;i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
};
var formDataToJSON = function(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
};
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
var stringifySafely = function(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
};
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(isFileList2 ? { "files[]": data } : data, _FormData && new _FormData, this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": undefined
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var normalizeHeader = function(header) {
  return header && String(header).trim().toLowerCase();
};
var normalizeValue = function(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
};
var parseTokens = function(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
};
var matchHeaderValue = function(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
};
var formatHeader = function(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
};
var buildAccessors = function(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
};
var $internals = Symbol("internals");
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === undefined || _rewrite === true || _rewrite === undefined && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
var CanceledError = function(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
};
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default("Request failed with status code " + response.status, [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/proxy-from-env/index.js
var getProxyForUrl = function(url2) {
  var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
    return "";
  }
  proto = proto.split(":", 1)[0];
  hostname = hostname.replace(/:\d*$/, "");
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return "";
  }
  var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
  if (proxy && proxy.indexOf("://") === -1) {
    proxy = proto + "://" + proxy;
  }
  return proxy;
};
var shouldProxy = function(hostname, port) {
  var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
  if (!NO_PROXY) {
    return true;
  }
  if (NO_PROXY === "*") {
    return false;
  }
  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;
    }
    if (!/^[.*]/.test(parsedProxyHostname)) {
      return hostname !== parsedProxyHostname;
    }
    if (parsedProxyHostname.charAt(0) === "*") {
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
};
var getEnv = function(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
};
var parseUrl = __require("url").parse;
var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};
var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
};
var $getProxyForUrl = getProxyForUrl;

// node_modules/axios/lib/adapters/http.js
var import_follow_redirects = __toESM(require_follow_redirects(), 1);
import http from "http";
import https from "https";
import util from "util";
import zlib from "zlib";

// node_modules/axios/lib/env/data.js
var VERSION = "1.6.7";

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// node_modules/axios/lib/adapters/http.js
import stream3 from "stream";

// node_modules/axios/lib/helpers/AxiosTransformStream.js
import stream from "stream";

// node_modules/axios/lib/helpers/throttle.js
var throttle = function(fn, freq) {
  let timestamp = 0;
  const threshold = 1000 / freq;
  let timer = null;
  return function throttled(force, args) {
    const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now;
      return fn.apply(null, args);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, args);
      }, threshold - (now - timestamp));
    }
  };
};
var throttle_default = throttle;

// node_modules/axios/lib/helpers/speedometer.js
var speedometer = function(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== undefined ? min : 1000;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
};
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/AxiosTransformStream.js
var kInternals = Symbol("internals");

class AxiosTransformStream extends stream.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const self2 = this;
    const internals = this[kInternals] = {
      length: options.length,
      timeWindow: options.timeWindow,
      ticksRate: options.ticksRate,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    const _speedometer = speedometer_default(internals.ticksRate * options.samplesCount, internals.timeWindow);
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
    let bytesNotified = 0;
    internals.updateProgress = throttle_default(function throttledHandler() {
      const totalBytes = internals.length;
      const bytesTransferred = internals.bytesSeen;
      const progressBytes = bytesTransferred - bytesNotified;
      if (!progressBytes || self2.destroyed)
        return;
      const rate = _speedometer(progressBytes);
      bytesNotified = bytesTransferred;
      process.nextTick(() => {
        self2.emit("progress", {
          loaded: bytesTransferred,
          total: totalBytes,
          progress: totalBytes ? bytesTransferred / totalBytes : undefined,
          bytes: progressBytes,
          rate: rate ? rate : undefined,
          estimated: rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : undefined
        });
      });
    }, internals.ticksRate);
    const onFinish = () => {
      internals.updateProgress(true);
    };
    this.once("end", onFinish);
    this.once("error", onFinish);
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const self2 = this;
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1000 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    function pushChunk(_chunk, _callback) {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      if (internals.isCaptured) {
        internals.updateProgress();
      }
      if (self2.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    }
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
  setLength(length) {
    this[kInternals].length = +length;
    return this;
  }
}
var AxiosTransformStream_default = AxiosTransformStream;

// node_modules/axios/lib/adapters/http.js
import EventEmitter from "events";

// node_modules/axios/lib/helpers/formDataToStream.js
import {TextEncoder as TextEncoder2} from "util";
import {Readable} from "stream";

// node_modules/axios/lib/helpers/readBlob.js
var { asyncIterator } = Symbol;
var readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
var readBlob_default = readBlob;

// node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = utils_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder = new TextEncoder2;
var CRLF = "\r\n";
var CRLF_BYTES = textEncoder.encode(CRLF);
var CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async* encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
}
var formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + utils_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
var formDataToStream_default = formDataToStream;

// node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
import stream2 from "stream";

class ZlibHeaderTransformStream extends stream2.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
}
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// node_modules/axios/lib/helpers/callbackify.js
var callbackify = (fn, reducer) => {
  return utils_default.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
var callbackify_default = callbackify;

// node_modules/axios/lib/adapters/http.js
var dispatchBeforeRedirect = function(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
};
var setProxy = function(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = $getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
};
var zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(zlib.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = platform_default.protocols.map((protocol) => {
  return protocol + ":";
});
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone)
        return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
var resolveFamily = ({ address, family }) => {
  if (!utils_default.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
var buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family });
var http_default = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let { data: data2, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify_default(lookup, (value) => utils_default.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new EventEmitter;
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    const parsed = new URL(fullPath, "http://localhost");
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = stream3.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default,
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_BAD_REQUEST, config));
    }
    const headers = AxiosHeaders_default.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const onDownloadProgress = config.onDownloadProgress;
    const onUploadProgress = config.onUploadProgress;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;
    if (utils_default.isSpecCompliantForm(data2)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data2 = formDataToStream_default(data2, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
    } else if (utils_default.isFormData(data2) && utils_default.isFunction(data2.getHeaders)) {
      headers.set(data2.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util.promisify(data2.getLength).call(data2);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils_default.isBlob(data2)) {
      data2.size && headers.setContentType(data2.type || "application/octet-stream");
      headers.setContentLength(data2.size || 0);
      data2 = stream3.Readable.from(readBlob_default(data2));
    } else if (data2 && !utils_default.isStream(data2)) {
      if (Buffer.isBuffer(data2)) {
      } else if (utils_default.isArrayBuffer(data2)) {
        data2 = Buffer.from(new Uint8Array(data2));
      } else if (utils_default.isString(data2)) {
        data2 = Buffer.from(data2, "utf-8");
      } else {
        return reject(new AxiosError_default("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", AxiosError_default.ERR_BAD_REQUEST, config));
      }
      headers.setContentLength(data2.length, false);
      if (config.maxBodyLength > -1 && data2.length > config.maxBodyLength) {
        return reject(new AxiosError_default("Request body larger than maxBodyLength limit", AxiosError_default.ERR_BAD_REQUEST, config));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data2 && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data2)) {
        data2 = stream3.Readable.from(data2, { objectMode: false });
      }
      data2 = stream3.pipeline([data2, new AxiosTransformStream_default({
        length: contentLength,
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data2.on("progress", (progress) => {
        onUploadProgress(Object.assign(progress, {
          upload: true
        }));
      });
    }
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path;
    try {
      path = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set("Accept-Encoding", "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""), false);
    const options = {
      path,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils_default.isUndefined(lookup) && (options.lookup = lookup);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https : http;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed)
        return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress) {
        const transformStream = new AxiosTransformStream_default({
          length: utils_default.toFiniteNumber(responseLength),
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", (progress) => {
          onDownloadProgress(Object.assign(progress, {
            download: true
          }));
        });
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream_default);
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(zlib.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? stream3.pipeline(streams, utils_default.noop) : streams[0];
      const offListeners = stream3.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError_default.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError_default.ERR_BAD_RESPONSE, config, lastRequest);
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed)
            return;
          reject(AxiosError_default.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError_default.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1000 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError_default("error trying to parse `config.timeout` to int", AxiosError_default.ERR_BAD_OPTION_VALUE, config, req));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone)
          return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional3 = config.transitional || transitional_default;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(timeoutErrorMessage, transitional3.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, req));
        abort();
      });
    }
    if (utils_default.isStream(data2)) {
      let ended = false;
      let errored = false;
      data2.on("end", () => {
        ended = true;
      });
      data2.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data2.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError_default("Request stream has been aborted", config, req));
        }
      });
      data2.pipe(req);
    } else {
      req.end(data2);
    }
  });
};

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? {
  write(name, value, expires, path, domain, secure) {
    const cookie = [name + "=" + encodeURIComponent(value)];
    utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
    utils_default.isString(path) && cookie.push("path=" + path);
    utils_default.isString(domain) && cookie.push("domain=" + domain);
    secure === true && cookie.push("secure");
    document.cookie = cookie.join("; ");
  },
  read(name) {
    const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
    return match ? decodeURIComponent(match[3]) : null;
  },
  remove(name) {
    this.write(name, "", Date.now() - 86400000);
  }
} : {
  write() {
  },
  read() {
    return null;
  },
  remove() {
  }
};

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? function standardBrowserEnv() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement("a");
  let originURL;
  function resolveURL(url2) {
    let href = url2;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin(requestURL) {
    const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

// node_modules/axios/lib/adapters/xhr.js
var progressEventReducer = function(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };
    data2[isDownloadStream ? "download" : "upload"] = true;
    listener(data2);
  };
};
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils_default.isFormData(requestData)) {
      if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional4 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(timeoutErrorMessage, transitional4.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    if (platform_default.hasStandardBrowserEnv) {
      withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === undefined && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0;i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === undefined) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(`There is no suitable adapter to dispatch the request ` + s, "ERR_NOT_SUPPORT");
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
var throwIfCancellationRequested = function(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
};
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(config, config.transformRequest);
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/validator.js
var assertOptions = function(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
};
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional4(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option \'" + opt + "\'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), AxiosError_default.ERR_DEPRECATED);
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;

class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default,
      response: new InterceptorManager_default
    };
  }
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error;
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        if (!err.stack) {
          err.stack = stack;
        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
          err.stack += "\n" + stack;
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional5, paramsSerializer, headers } = config;
    if (transitional5 !== undefined) {
      validator_default.assertOptions(transitional5, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(headers.common, headers[config.method]);
    headers && utils_default.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (method) => {
      delete headers[method];
    });
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data3, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data: data3
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
var createInstance = function(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
};
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// create-message.ts
var import_discord2 = __toESM(require_src(), 1);
var sanitizeUrl = function(url2) {
  return new URL(url2).toString();
};
function createProductMessage(boxDetails) {
  return new import_discord2.EmbedBuilder().setColor(16711680).setTitle(`Quantity: ${boxDetails.ecomQuantityOnHand}`).setAuthor({ name: boxDetails.boxName, iconURL: sanitizeUrl(boxDetails.imageUrls.small), url: `https://wss2.cex.uk.webuy.io/v3/boxes/${boxDetails.boxId}/detail` }).setDescription(`${boxDetails.superCatFriendlyName} / ${boxDetails.categoryFriendlyName}`).setThumbnail(sanitizeUrl(boxDetails.imageUrls.medium)).setTimestamp();
}
function createNoProductMessage() {
  return new import_discord2.EmbedBuilder().setColor(8421504).setTitle("No products available").setDescription("Check back later!").setTimestamp();
}

// node_modules/luxon/src/errors.js
class LuxonError extends Error {
}

class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}

class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}

class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}

class ConflictingSpecificationError extends LuxonError {
}

class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
}

class InvalidArgumentError extends LuxonError {
}

class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}

// node_modules/luxon/src/impl/formats.js
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

// node_modules/luxon/src/zone.js
class Zone {
  get type() {
    throw new ZoneIsAbstractError;
  }
  get name() {
    throw new ZoneIsAbstractError;
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new ZoneIsAbstractError;
  }
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError;
  }
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError;
  }
  offset(ts) {
    throw new ZoneIsAbstractError;
  }
  equals(otherZone) {
    throw new ZoneIsAbstractError;
  }
  get isValid() {
    throw new ZoneIsAbstractError;
  }
}

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;

class SystemZone extends Zone {
  static get instance() {
    if (singleton === null) {
      singleton = new SystemZone;
    }
    return singleton;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  equals(otherZone) {
    return otherZone.type === "system";
  }
  get isValid() {
    return true;
  }
}

// node_modules/luxon/src/zones/IANAZone.js
var makeDTF = function(zone3) {
  if (!dtfCache[zone3]) {
    dtfCache[zone3] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone3,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone3];
};
var hackyOffset = function(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
};
var partsOffset = function(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0;i < formatted.length; i++) {
    const { type, value } = formatted[i];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined2(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
};
var dtfCache = {};
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
var ianaZoneCache = {};

class IANAZone extends Zone {
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  static isValidZone(zone3) {
    if (!zone3) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone3 }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = IANAZone.isValidZone(name);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return (asUTC - asTS) / (60 * 1000);
  }
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
}

// node_modules/luxon/src/impl/locale.js
var getCachedLF = function(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
};
var getCachedDTF = function(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
};
var getCachedINF = function(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
};
var getCachedRTF = function(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
};
var systemLocale = function() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
};
var getCachedWeekInfo = function(locString) {
  let data4 = weekInfoCache[locString];
  if (!data4) {
    const locale = new Intl.Locale(locString);
    data4 = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    weekInfoCache[locString] = data4;
  }
  return data4;
};
var parseLocaleString = function(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
};
var intlConfigString = function(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
};
var mapMonths = function(f) {
  const ms = [];
  for (let i = 1;i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
};
var mapWeekdays = function(f) {
  const ms = [];
  for (let i = 1;i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
};
var listStuff = function(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
};
var supportsFastNumbers = function(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
};
var intlLFCache = {};
var intlDTCache = {};
var intlNumCache = {};
var intlRelCache = {};
var sysLocaleCache = null;
var weekInfoCache = {};

class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
}

class PolyDateFormatter {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = undefined;
    let z = undefined;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}

class PolyRelFormatter {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
}
var fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};

class Locale {
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.weekSettings, opts.defaultToEN);
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, validateWeekSettings(alts.weekSettings) || this.weekSettings, alts.defaultToEN || false);
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format = false) {
    return listStuff(this, length, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false) {
    return listStuff(this, length, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(this, undefined, () => meridiems, () => {
      if (!this.meridiemCache) {
        const intl = { hour: "numeric", hourCycle: "h12" };
        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((dt) => this.extract(dt, intl, "dayperiod"));
      }
      return this.meridiemCache;
    });
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
}

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;

class FixedOffsetZone extends Zone {
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new FixedOffsetZone(0);
    }
    return singleton2;
  }
  static instance(offset) {
    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
  }
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset) {
    super();
    this.fixed = offset;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  offsetName() {
    return this.name;
  }
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  get isUniversal() {
    return true;
  }
  offset() {
    return this.fixed;
  }
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  get isValid() {
    return true;
  }
}

// node_modules/luxon/src/zones/invalidZone.js
class InvalidZone extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return false;
  }
  get isValid() {
    return false;
  }
}

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone) {
  let offset;
  if (isUndefined2(input) || input === null) {
    return defaultZone;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString2(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber2(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var twoDigitCutoffYear = 60;
var throwOnInvalid;
var defaultWeekSettings = null;

class Settings {
  static get now() {
    return now;
  }
  static set now(n2) {
    now = n2;
  }
  static set defaultZone(zone6) {
    defaultZone = zone6;
  }
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  static get defaultLocale() {
    return defaultLocale;
  }
  static set defaultLocale(locale2) {
    defaultLocale = locale2;
  }
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
}

// node_modules/luxon/src/impl/invalid.js
class Invalid {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}

// node_modules/luxon/src/impl/conversions.js
var unitOutOfRange = function(unit, value) {
  return new Invalid("unit out of range", `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`);
};
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
var computeOrdinal = function(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
};
var uncomputeOrdinal = function(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
};
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined2(obj.localWeekday) || !isUndefined2(obj.localWeekNumber) || !isUndefined2(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined2(obj.weekday) || !isUndefined2(obj.weekNumber) || !isUndefined2(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError("Cannot mix locale-based week fields with ISO-based week fields");
    }
    if (!isUndefined2(obj.localWeekday))
      obj.weekday = obj.localWeekday;
    if (!isUndefined2(obj.localWeekNumber))
      obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined2(obj.localWeekYear))
      obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

// node_modules/luxon/src/impl/util.js
function isUndefined2(o) {
  return typeof o === "undefined";
}
function isNumber2(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString2(o) {
  return typeof o === "string";
}
function isDate2(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && (("weekInfo" in Intl.Locale.prototype) || ("getWeekInfo" in Intl.Locale.prototype));
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings3) {
  if (settings3 == null) {
    return null;
  } else if (typeof settings3 !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings3.firstDay, 1, 7) || !integerBetween(settings3.minimalDays, 1, 7) || !Array.isArray(settings3.weekend) || settings3.weekend.some((v) => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings3.firstDay,
      minimalDays: settings3.minimalDays,
      weekend: Array.from(settings3.weekend)
    };
  }
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined2(string) || string === null || string === "") {
    return;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined2(string) || string === null || string === "") {
    return;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined2(fraction) || fraction === null || fraction === "") {
    return;
  } else {
    const f = parseFloat("0." + fraction) * 1000;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
var firstWeekOffset = function(year, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
};
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > Settings.twoDigitCutoffYear ? 1900 + year : 2000 + year;
}
function parseZoneInfo(ts, offsetFormat, locale2, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale2, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty2(obj, u)) {
      const v = obj[u];
      if (v === undefined || v === null)
        continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset, format) {
  const hours = Math.trunc(Math.abs(offset / 60)), minutes = Math.trunc(Math.abs(offset % 60)), sign = offset >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

// node_modules/luxon/src/impl/english.js
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];

// node_modules/luxon/src/impl/formatter.js
var stringifyTokens = function(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
};
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};

class Formatter {
  static create(locale2, opts = {}) {
    return new Formatter(locale2, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0;i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale2, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale2;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" }, "weekday"), maybeMacro = (token) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "n":
          return this.num(dt.localWeekNumber);
        case "nn":
          return this.num(dt.localWeekNumber, 2);
        case "ii":
          return this.num(dt.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(dt.localWeekYear, 4);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1000));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, { literal, val }) => literal ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
}

// node_modules/luxon/src/impl/regexParser.js
var combineRegexes = function(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}\$`);
};
var combineExtractors = function(...extractors) {
  return (m) => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
    const [val, zone6, next] = ex(m, cursor);
    return [{ ...mergedVals, ...val }, zone6 || mergedZone, next];
  }, [{}, null, 1]).slice(0, 2);
};
var parse = function(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
};
var simpleParse = function(...keys) {
  return (match, cursor) => {
    const ret = {};
    let i;
    for (i = 0;i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
};
var int = function(match, pos, fallback) {
  const m = match[pos];
  return isUndefined2(m) ? fallback : parseInteger(m);
};
var extractISOYmd = function(match, cursor) {
  const item = {
    year: int(match, cursor),
    month: int(match, cursor + 1, 1),
    day: int(match, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
};
var extractISOTime = function(match, cursor) {
  const item = {
    hours: int(match, cursor, 0),
    minutes: int(match, cursor + 1, 0),
    seconds: int(match, cursor + 2, 0),
    milliseconds: parseMillis(match[cursor + 3])
  };
  return [item, null, cursor + 4];
};
var extractISOOffset = function(match, cursor) {
  const local = !match[cursor] && !match[cursor + 1], fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]), zone6 = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone6, cursor + 3];
};
var extractIANAZone = function(match, cursor) {
  const zone6 = match[cursor] ? IANAZone.create(match[cursor]) : null;
  return [{}, zone6, cursor + 1];
};
var extractISODuration = function(match) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== undefined && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
};
var fromStrings = function(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
};
var extractRFC2822 = function(match) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset;
  if (obsOffset) {
    offset = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset = 0;
  } else {
    offset = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset)];
};
var preprocessRFC2822 = function(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
};
var extractRFC1123Or850 = function(match) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
};
var extractASCII = function(match) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
};
function parseISODate(s2) {
  return parse(s2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
}
function parseRFC2822Date(s2) {
  return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse(s2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
}
function parseISODuration(s2) {
  return parse(s2, [isoDuration, extractISODuration]);
}
function parseISOTimeOnly(s2) {
  return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
}
function parseSQL(s2) {
  return parse(s2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
}
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}\$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
var extractISOTimeOnly = combineExtractors(extractISOTime);
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);

// node_modules/luxon/src/duration.js
var clone = function(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
};
var durationToMillis = function(matrix, vals) {
  let sum = vals.milliseconds ?? 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
};
var normalizeValues = function(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits.reduceRight((previous, current) => {
    if (!isUndefined2(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  orderedUnits.reduce((previous, current) => {
    if (!isUndefined2(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
};
var removeZeroes = function(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
};
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1000
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1000
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },
  minutes: { seconds: 60, milliseconds: 60 * 1000 },
  seconds: { milliseconds: 1000 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1000
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1000
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1000
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
  },
  ...lowOrderMatrix
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();

class Duration {
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  static fromMillis(count, opts) {
    return Duration.fromObject({ milliseconds: count }, opts);
  }
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  static fromDurationLike(durationLike) {
    if (isNumber2(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
    }
  }
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid3 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid3);
    } else {
      return new Duration({ invalid: invalid3 });
    }
  }
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  toHuman(opts = {}) {
    if (!this.isValid)
      return INVALID;
    const l2 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined2(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  toObject() {
    if (!this.isValid)
      return {};
    return { ...this.values };
  }
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 86400000)
      return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  toMillis() {
    if (!this.isValid)
      return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  valueOf() {
    return this.toMillis();
  }
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration), result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty2(dur.values, k) || hasOwnProperty2(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone(this, { values: result }, true);
  }
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone(this, { values: result }, true);
  }
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  set(values) {
    if (!this.isValid)
      return this;
    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
    return clone(this, { values: mixed });
  }
  reconfigure({ locale: locale3, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale: locale3, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone(this, opts);
  }
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  rescale() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone(this, { values: vals }, true);
  }
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber2(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1000 - i * 1000) / 1000;
      } else if (isNumber2(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone(this, { values: built }, true);
  }
  shiftToAll() {
    if (!this.isValid)
      return this;
    return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
  }
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, { values: negated }, true);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === undefined || v1 === 0)
        return v2 === undefined || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
}

// node_modules/luxon/src/interval.js
var validateStartEnd = function(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
  } else {
    return null;
  }
};
var INVALID2 = "Invalid Interval";

class Interval {
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid4 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid4);
    } else {
      return new Interval({ invalid: invalid4 });
    }
  }
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  static after(start, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  static before(end, duration2) {
    const dur = Duration.fromDurationLike(duration2), dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  static fromISO(text, opts) {
    const [s2, e] = (text || "").split("/", 2);
    if (s2 && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e2) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e2) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  count(unit = "milliseconds", opts) {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit, opts);
    let end;
    if (opts?.useLocaleWeeks) {
      end = this.end.reconfigure({ locale: start.locale });
    } else {
      end = this.end;
    }
    end = end.startOf(unit, opts);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  splitBy(duration2) {
    const dur = Duration.fromDurationLike(duration2);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s2, e);
    }
  }
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s2, e);
  }
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(([sofar, current], item) => {
      if (!current) {
        return [sofar, item];
      } else if (current.overlaps(item) || current.abutsStart(item)) {
        return [sofar, current.union(item)];
      } else {
        return [sofar.concat([current]), item];
      }
    }, [[], null]);
    if (final) {
      found.push(final);
    }
    return found;
  }
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  toString() {
    if (!this.isValid)
      return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
  }
  toISO(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  toISODate() {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
}

// node_modules/luxon/src/info.js
class Info {
  static hasDST(zone6 = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone6).set({ month: 12 });
    return !zone6.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  static isValidIANAZone(zone6) {
    return IANAZone.isValidZone(zone6);
  }
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  static getStartOfWeek({ locale: locale4 = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale4)).getStartOfWeek();
  }
  static getMinimumDaysInFirstWeek({ locale: locale4 = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale4)).getMinDaysInFirstWeek();
  }
  static getWeekendWeekdays({ locale: locale4 = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale4)).getWeekendDays().slice();
  }
  static months(length = "long", { locale: locale4 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale4, numberingSystem, outputCalendar)).months(length);
  }
  static monthsFormat(length = "long", { locale: locale4 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale4, numberingSystem, outputCalendar)).months(length, true);
  }
  static weekdays(length = "long", { locale: locale4 = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale4, numberingSystem, null)).weekdays(length);
  }
  static weekdaysFormat(length = "long", { locale: locale4 = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale4, numberingSystem, null)).weekdays(length, true);
  }
  static meridiems({ locale: locale4 = null } = {}) {
    return Locale.create(locale4).meridiems();
  }
  static eras(length = "short", { locale: locale4 = null } = {}) {
    return Locale.create(locale4, null, "gregory").eras(length);
  }
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
}

// node_modules/luxon/src/impl/diff.js
var dayDiff = function(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
};
var highOrderDiffs = function(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
};
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter((u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0);
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration3 = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration3);
  } else {
    return duration3;
  }
}

// node_modules/luxon/src/impl/digits.js
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0;i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append2 = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append2}`);
}
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");

// node_modules/luxon/src/impl/tokenParser.js
var intUnit = function(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
};
var fixListRegex = function(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
};
var stripInsensitivities = function(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
};
var oneOf = function(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
};
var offset = function(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
};
var simple = function(regex) {
  return { regex, deser: ([s2]) => s2 };
};
var escapeToken = function(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
};
var unitForToken = function(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
    if (token.literal) {
      return literal(t);
    }
    switch (t.val) {
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
};
var tokenForPart = function(part, formatOpts, resolvedOpts) {
  const { type, value } = part;
  if (type === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type];
  let actualType = type;
  if (type === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return;
};
var buildRegex = function(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}\$`, units];
};
var match = function(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all2 = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty2(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all2[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all2];
  } else {
    return [matches, {}];
  }
};
var dateTimeFromMatches = function(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone6 = null;
  let specificOffset;
  if (!isUndefined2(matches.z)) {
    zone6 = IANAZone.create(matches.z);
  }
  if (!isUndefined2(matches.Z)) {
    if (!zone6) {
      zone6 = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined2(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined2(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined2(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone6, specificOffset];
};
var getDummyDateTime = function() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
};
var maybeExpandMacroToken = function(token, locale4) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale4);
  if (tokens == null || tokens.includes(undefined)) {
    return token;
  }
  return tokens;
};
function expandMacroTokens(tokens, locale4) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale4)));
}
function explainFromTokens(locale4, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale4), units = tokens.map((t) => unitForToken(t, locale4)), disqualifyingUnit = units.find((t) => t.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone6, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, undefined];
    if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
      throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
    }
    return { input, tokens, regex, rawMatches, matches, result, zone: zone6, specificOffset };
  }
}
function parseFromTokens(locale4, input, format) {
  const { result, zone: zone6, specificOffset, invalidReason } = explainFromTokens(locale4, input, format);
  return [result, zone6, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale4) {
  if (!formatOpts) {
    return null;
  }
  const formatter4 = Formatter.create(locale4, formatOpts);
  const df = formatter4.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
}
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
var dummyDateTimeCache = null;

// node_modules/luxon/src/datetime.js
var unsupportedZone = function(zone6) {
  return new Invalid("unsupported zone", `the zone "${zone6.name}" is not supported`);
};
var possiblyCachedWeekData = function(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
};
var possiblyCachedLocalWeekData = function(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(dt.c, dt.loc.getMinDaysInFirstWeek(), dt.loc.getStartOfWeek());
  }
  return dt.localWeekData;
};
var clone2 = function(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
};
var fixOffset = function(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1000;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1000;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
};
var tsToObj = function(ts, offset2) {
  ts += offset2 * 60 * 1000;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
};
var objToTS = function(obj, offset2, zone6) {
  return fixOffset(objToLocalTS(obj), offset2, zone6);
};
var adjustTime = function(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
};
var parseDataToDateTime = function(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone: zone6 } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone6, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone6);
  } else {
    return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`));
  }
};
var toTechFormat = function(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
};
var toISODate = function(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0)
    c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
};
var toISOTime = function(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
};
var normalizeUnit = function(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit);
  return normalized;
};
var normalizeUnitWithLocalWeeks = function(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
};
var quickDT = function(obj, opts) {
  const zone6 = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o;
  if (!isUndefined2(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined2(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid5 = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid5) {
      return DateTime.invalid(invalid5);
    }
    const offsetProvis = zone6.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone6);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone: zone6, loc, o });
};
var diffRelative = function(start, end, opts) {
  const round = isUndefined2(opts.round) ? true : opts.round, format = (c, unit) => {
    c = roundTo(c, round || opts.calendary ? 0 : 2, true);
    const formatter5 = end.loc.clone(opts).relFormatter(opts);
    return formatter5.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else
        return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
};
var lastOpts = function(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
  }
}
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 8640000000000000;
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

class DateTime {
  constructor(config) {
    const zone6 = config.zone || Settings.defaultZone;
    let invalid5 = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone6.isValid ? unsupportedZone(zone6) : null);
    this.ts = isUndefined2(config.ts) ? Settings.now() : config.ts;
    let c = null, o = null;
    if (!invalid5) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone6);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone6.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid5 = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid5 ? null : c;
        o = invalid5 ? null : ot;
      }
    }
    this._zone = zone6;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid5;
    this.weekData = null;
    this.localWeekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  static now() {
    return new DateTime({});
  }
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  static fromJSDate(date, options = {}) {
    const ts = isDate2(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber2(milliseconds)) {
      throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromSeconds(seconds, options = {}) {
    if (!isNumber2(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1000,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(), offsetProvis = !isUndefined2(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined2(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid5 = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid5) {
      return DateTime.invalid(invalid5);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
    }
    return inst;
  }
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined2(text) || isUndefined2(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale: locale5 = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale: locale5,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid5] = parseFromTokens(localeToUse, text, fmt);
    if (invalid5) {
      return DateTime.invalid(invalid5);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid5 = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid5);
    } else {
      return new DateTime({ invalid: invalid5 });
    }
  }
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
  }
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }
  get(unit) {
    return this[unit];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 86400000;
    const minuteMs = 60000;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
    }
    return [this];
  }
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN;
  }
  resolvedLocaleOptions(opts = {}) {
    const { locale: locale5, numberingSystem, calendar } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
    return { locale: locale5, numberingSystem, outputCalendar: calendar };
  }
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  setZone(zone6, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone6 = normalizeZone(zone6, Settings.defaultZone);
    if (zone6.equals(this.zone)) {
      return this;
    } else if (!zone6.isValid) {
      return DateTime.invalid(unsupportedZone(zone6));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone6.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone6);
      }
      return clone2(this, { ts: newTS, zone: zone6 });
    }
  }
  reconfigure({ locale: locale5, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale: locale5, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  setLocale(locale5) {
    return this.reconfigure({ locale: locale5 });
  }
  set(values) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined2(normalized.weekYear) || !isUndefined2(normalized.weekNumber) || !isUndefined2(normalized.weekday), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian({ ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized }, minDaysInFirstWeek, startOfWeek);
    } else if (!isUndefined2(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined2(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone2(this, { ts, o });
  }
  plus(duration4) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration4);
    return clone2(this, adjustTime(this, dur));
  }
  minus(duration4) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration4).negate();
    return clone2(this, adjustTime(this, dur));
  }
  startOf(unit, { useLocaleWeeks = false } = {}) {
    if (!this.isValid)
      return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const { weekday } = this;
        if (weekday < startOfWeek) {
          o.weekNumber = this.weekNumber - 1;
        }
        o.weekday = startOfWeek;
      } else {
        o.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  endOf(unit, opts) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
  }
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
  }
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1000 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1000) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = undefined;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale: locale5 = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale: locale5,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  static get DATE_MED() {
    return DATE_MED;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  static get DATE_FULL() {
    return DATE_FULL;
  }
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}

// log.ts
function log(message) {
  const _now = DateTime.now().setLocale("fr");
  console.log(`[${_now.toLocaleString(DateTime.DATE_SHORT)} ${_now.toLocaleString(DateTime.TIME_24_WITH_SECONDS)}] ${message}`);
}

// products.json
var products_default = [
  "SPS1G1144AB",
  "9312544025748ab",
  "013388160051ab",
  "3455194450099ab",
  "013388160044ab",
  "0317630557091ab",
  "4974365611866ab",
  "4012927080177a",
  "045496733445a",
  "0454967341211a",
  "785138320366b"
];

// products-checker.ts
async function initProductsChecker() {
  const checkProducts$ = new import_rxjs.BehaviorSubject(undefined);
  checkProducts$.pipe(import_rxjs.tap(() => log("Checking products...")), import_rxjs.concatMap(() => getProducts()), import_rxjs.tap((items) => {
    log(`Products checked! Waiting ${GET_PRODUCTS_LIST_INTERVAL}ms before checking again all products...`);
    if (items.every((item) => item === null || item.ecomQuantityOnHand === 0)) {
      sendMessage(createNoProductMessage());
    }
  }), import_rxjs.delay(GET_PRODUCTS_LIST_INTERVAL), import_rxjs.tap(() => checkProducts$.next())).subscribe();
}
var getProducts = function() {
  const i$ = new import_rxjs.BehaviorSubject(0);
  return i$.asObservable().pipe(import_rxjs.tap((i) => log(`Checking product ${products_default[i]}...`)), import_rxjs.concatMap((i) => fetchProductDetails(products_default[i])), import_rxjs.delay(GET_PRODUCT_INTERVAL), import_rxjs.tap(() => {
    const next = i$.value + 1;
    if (next < products_default.length) {
      i$.next(next);
    }
  }), import_rxjs.take(products_default.length), import_rxjs.toArray());
};
var fetchProductDetails = function(id) {
  return import_rxjs.from(axios_default.get(`https://wss2.cex.uk.webuy.io/v3/boxes/${id}/detail`)).pipe(import_rxjs.map((response) => {
    if (response.status === 200) {
      const product = response.data.response.data.boxDetails[0];
      log(`Product ${product.boxId} was checked. Waiting ${GET_PRODUCT_INTERVAL}ms seconds before checking the next product...`);
      sendMessage(createProductMessage(product));
      return product;
    } else {
      log(`Error ${response.status} while fetching product ${id}.`);
      return null;
    }
  }), import_rxjs.catchError((err) => {
    log(`Error ${err.toString()} while fetching product ${id}.`);
    return import_rxjs.of(null);
  }));
};
var GET_PRODUCTS_LIST_INTERVAL = 900000;
var GET_PRODUCT_INTERVAL = 5000;

// bot.ts
require_main2().config();
if (!process.env.DISCORD_TOKEN) {
  console.error("DISCORD_TOKEN is not defined .env");
  process.exit(1);
}
if (!process.env.DISCORD_CHANNEL_ID) {
  console.error("DISCORD_CHANNEL_ID is not defined in .env");
  process.exit(1);
}
client.once(import_discord3.Events.ClientReady, async (c) => {
  console.log(`Ready! Logged in as ${c.user.tag} \uD83C\uDF78`);
  await initProductsChecker();
});
client.login(process.env.DISCORD_TOKEN);
